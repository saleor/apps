import gql from 'graphql-tag';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
type JSONValue = string | number | boolean | null | { [key: string]: JSONValue } | JSONValue[];
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /**
   * The `Date` scalar type represents a Date
   * value as specified by
   * [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
   */
  Date: { input: string; output: string; }
  /**
   * The `DateTime` scalar type represents a DateTime
   * value as specified by
   * [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
   */
  DateTime: { input: string; output: string; }
  /** The `Day` scalar type represents number of days by integer value. */
  Day: { input: string; output: string; }
  /**
   * Custom Decimal implementation.
   *
   * Returns Decimal as a float in the API,
   * parses float to the Decimal on the way back.
   */
  Decimal: { input: number; output: number; }
  /**
   * The `GenericScalar` scalar type represents a generic
   * GraphQL scalar value that could be:
   * String, Boolean, Int, Float, List or Object.
   */
  GenericScalar: { input: JSONValue; output: JSONValue; }
  /** The `Hour` scalar type represents number of hours by integer value. */
  Hour: { input: number; output: number; }
  JSON: { input: JSONValue; output: JSONValue; }
  JSONString: { input: string; output: string; }
  /**
   * Metadata is a map of key-value pairs, both keys and values are `String`.
   *
   * Example:
   * ```
   * {
   *     "key1": "value1",
   *     "key2": "value2"
   * }
   * ```
   */
  Metadata: { input: Record<string, string>; output: Record<string, string>; }
  /** The `Minute` scalar type represents number of minutes by integer value. */
  Minute: { input: number; output: number; }
  /**
   * Nonnegative Decimal scalar implementation.
   *
   * Should be used in places where value must be nonnegative (0 or greater).
   */
  PositiveDecimal: { input: number; output: number; }
  /**
   * Positive Integer scalar implementation.
   *
   * Should be used in places where value must be positive (greater than 0).
   */
  PositiveInt: { input: number; output: number; }
  UUID: { input: string; output: string; }
  /** Variables of this type must be set to null in mutations. They will be replaced with a filename from a following multipart part containing a binary file. See: https://github.com/jaydenseric/graphql-multipart-request-spec. */
  Upload: { input: unknown; output: unknown; }
  WeightScalar: { input: number; output: number; }
  /** _Any value scalar as defined by Federation spec. */
  _Any: { input: unknown; output: unknown; }
};

/**
 * Create a new address for the customer.
 *
 * Requires one of following set of permissions: AUTHENTICATED_USER or AUTHENTICATED_APP + IMPERSONATE_USER.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_UPDATED (async): A customer account was updated.
 * - ADDRESS_CREATED (async): An address was created.
 */
export type AccountAddressCreate = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly address?: Maybe<Address>;
  readonly errors: ReadonlyArray<AccountError>;
  /** A user instance for which the address was created. */
  readonly user?: Maybe<User>;
};

/**
 * Deletes an address of the logged-in user. Requires one of the following permissions: MANAGE_USERS, IS_OWNER.
 *
 * Triggers the following webhook events:
 * - ADDRESS_DELETED (async): An address was deleted.
 */
export type AccountAddressDelete = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly address?: Maybe<Address>;
  readonly errors: ReadonlyArray<AccountError>;
  /** A user instance for which the address was deleted. */
  readonly user?: Maybe<User>;
};

/**
 * Updates an address of the logged-in user. Requires one of the following permissions: MANAGE_USERS, IS_OWNER.
 *
 * Triggers the following webhook events:
 * - ADDRESS_UPDATED (async): An address was updated.
 */
export type AccountAddressUpdate = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly address?: Maybe<Address>;
  readonly errors: ReadonlyArray<AccountError>;
  /** A user object for which the address was edited. */
  readonly user?: Maybe<User>;
};

/** Event sent when account change email is requested. */
export type AccountChangeEmailRequested = Event & {
  /** The channel data. */
  readonly channel?: Maybe<Channel>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The new email address the user wants to change to. */
  readonly newEmail?: Maybe<Scalars['String']['output']>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  readonly redirectUrl?: Maybe<Scalars['String']['output']>;
  /** Shop data. */
  readonly shop?: Maybe<Shop>;
  /** The token required to confirm request. */
  readonly token?: Maybe<Scalars['String']['output']>;
  /** The user the event relates to. */
  readonly user?: Maybe<User>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Event sent when account confirmation requested. This event is always sent. enableAccountConfirmationByEmail flag set to True is not required. */
export type AccountConfirmationRequested = Event & {
  /** The channel data. */
  readonly channel?: Maybe<Channel>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  readonly redirectUrl?: Maybe<Scalars['String']['output']>;
  /** Shop data. */
  readonly shop?: Maybe<Shop>;
  /** The token required to confirm request. */
  readonly token?: Maybe<Scalars['String']['output']>;
  /** The user the event relates to. */
  readonly user?: Maybe<User>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Event sent when account is confirmed. */
export type AccountConfirmed = Event & {
  /** The channel data. */
  readonly channel?: Maybe<Channel>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  readonly redirectUrl?: Maybe<Scalars['String']['output']>;
  /** Shop data. */
  readonly shop?: Maybe<Shop>;
  /** The token required to confirm request. */
  readonly token?: Maybe<Scalars['String']['output']>;
  /** The user the event relates to. */
  readonly user?: Maybe<User>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Remove user account.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - ACCOUNT_DELETED (async): Account was deleted.
 */
export type AccountDelete = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  readonly user?: Maybe<User>;
};

/** Event sent when account delete is requested. */
export type AccountDeleteRequested = Event & {
  /** The channel data. */
  readonly channel?: Maybe<Channel>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  readonly redirectUrl?: Maybe<Scalars['String']['output']>;
  /** Shop data. */
  readonly shop?: Maybe<Shop>;
  /** The token required to confirm request. */
  readonly token?: Maybe<Scalars['String']['output']>;
  /** The user the event relates to. */
  readonly user?: Maybe<User>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Event sent when account is deleted. */
export type AccountDeleted = Event & {
  /** The channel data. */
  readonly channel?: Maybe<Channel>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  readonly redirectUrl?: Maybe<Scalars['String']['output']>;
  /** Shop data. */
  readonly shop?: Maybe<Shop>;
  /** The token required to confirm request. */
  readonly token?: Maybe<Scalars['String']['output']>;
  /** The user the event relates to. */
  readonly user?: Maybe<User>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Event sent when account email is changed. */
export type AccountEmailChanged = Event & {
  /** The channel data. */
  readonly channel?: Maybe<Channel>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The new email address. */
  readonly newEmail?: Maybe<Scalars['String']['output']>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  readonly redirectUrl?: Maybe<Scalars['String']['output']>;
  /** Shop data. */
  readonly shop?: Maybe<Shop>;
  /** The token required to confirm request. */
  readonly token?: Maybe<Scalars['String']['output']>;
  /** The user the event relates to. */
  readonly user?: Maybe<User>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Represents errors in account mutations. */
export type AccountError = {
  /** A type of address that causes the error. */
  readonly addressType?: Maybe<AddressTypeEnum>;
  /** The error code. */
  readonly code: AccountErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type AccountErrorCode =
  | 'ACCOUNT_NOT_CONFIRMED'
  | 'ACTIVATE_OWN_ACCOUNT'
  | 'ACTIVATE_SUPERUSER_ACCOUNT'
  | 'CHANNEL_INACTIVE'
  | 'DEACTIVATE_OWN_ACCOUNT'
  | 'DEACTIVATE_SUPERUSER_ACCOUNT'
  | 'DELETE_NON_STAFF_USER'
  | 'DELETE_OWN_ACCOUNT'
  | 'DELETE_STAFF_ACCOUNT'
  | 'DELETE_SUPERUSER_ACCOUNT'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INACTIVE'
  | 'INVALID'
  | 'INVALID_CREDENTIALS'
  | 'INVALID_PASSWORD'
  | 'JWT_DECODE_ERROR'
  | 'JWT_INVALID_CSRF_TOKEN'
  | 'JWT_INVALID_TOKEN'
  | 'JWT_MISSING_TOKEN'
  | 'JWT_SIGNATURE_EXPIRED'
  | 'LEFT_NOT_MANAGEABLE_PERMISSION'
  | 'LOGIN_ATTEMPT_DELAYED'
  | 'MISSING_CHANNEL_SLUG'
  | 'NOT_FOUND'
  | 'OUT_OF_SCOPE_GROUP'
  | 'OUT_OF_SCOPE_PERMISSION'
  | 'OUT_OF_SCOPE_USER'
  | 'PASSWORD_ENTIRELY_NUMERIC'
  | 'PASSWORD_RESET_ALREADY_REQUESTED'
  | 'PASSWORD_TOO_COMMON'
  | 'PASSWORD_TOO_SHORT'
  | 'PASSWORD_TOO_SIMILAR'
  | 'REQUIRED'
  | 'UNIQUE'
  | 'UNKNOWN_IP_ADDRESS';

/** Fields required to update the user. */
export type AccountInput = {
  /** Billing address of the customer. */
  readonly defaultBillingAddress?: InputMaybe<AddressInput>;
  /** Shipping address of the customer. */
  readonly defaultShippingAddress?: InputMaybe<AddressInput>;
  /** Given name. */
  readonly firstName?: InputMaybe<Scalars['String']['input']>;
  /** User language code. */
  readonly languageCode?: InputMaybe<LanguageCodeEnum>;
  /** Family name. */
  readonly lastName?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the user metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
};

/**
 * Register a new user.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_CREATED (async): A new customer account was created.
 * - NOTIFY_USER (async): A notification for account confirmation.
 * - ACCOUNT_CONFIRMATION_REQUESTED (async): An user confirmation was requested. This event is always sent regardless of settings.
 */
export type AccountRegister = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  /** Informs whether users need to confirm their email address. */
  readonly requiresConfirmation?: Maybe<Scalars['Boolean']['output']>;
  /** @deprecated The field always returns a `User` object constructed from the input data. The `user.id` is always empty. To determine whether the user exists in Saleor, query via an external app with the required permissions. */
  readonly user?: Maybe<User>;
};

/** Fields required to create a user. */
export type AccountRegisterInput = {
  /** Slug of a channel which will be used to notify users. Optional when only one channel exists. */
  readonly channel?: InputMaybe<Scalars['String']['input']>;
  /** The email address of the user. */
  readonly email: Scalars['String']['input'];
  /** Given name. */
  readonly firstName?: InputMaybe<Scalars['String']['input']>;
  /** User language code. */
  readonly languageCode?: InputMaybe<LanguageCodeEnum>;
  /** Family name. */
  readonly lastName?: InputMaybe<Scalars['String']['input']>;
  /**
   * User public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Password. */
  readonly password: Scalars['String']['input'];
  /** Base of frontend URL that will be needed to create confirmation URL. Required when account confirmation is enabled. */
  readonly redirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Sends an email with the account removal link for the logged-in user.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - NOTIFY_USER (async): A notification for account delete request.
 * - ACCOUNT_DELETE_REQUESTED (async): An account delete requested.
 */
export type AccountRequestDeletion = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
};

/**
 * Sets a default address for the authenticated user.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_UPDATED (async): A customer's address was updated.
 */
export type AccountSetDefaultAddress = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  /** An updated user instance. */
  readonly user?: Maybe<User>;
};

/** Event sent when setting a new password is requested. */
export type AccountSetPasswordRequested = Event & {
  /** The channel data. */
  readonly channel?: Maybe<Channel>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  readonly redirectUrl?: Maybe<Scalars['String']['output']>;
  /** Shop data. */
  readonly shop?: Maybe<Shop>;
  /** The token required to confirm request. */
  readonly token?: Maybe<Scalars['String']['output']>;
  /** The user the event relates to. */
  readonly user?: Maybe<User>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Updates the account of the logged-in user.
 *
 * Requires one of following set of permissions: AUTHENTICATED_USER or AUTHENTICATED_APP + IMPERSONATE_USER.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_UPDATED (async): A customer account was updated.
 * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
 */
export type AccountUpdate = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  readonly user?: Maybe<User>;
};

/** Represents user address data. */
export type Address = Node & ObjectWithMetadata & {
  /** The city of the address. */
  readonly city: Scalars['String']['output'];
  /** The district of the address. */
  readonly cityArea: Scalars['String']['output'];
  /** Company or organization name. */
  readonly companyName: Scalars['String']['output'];
  /** The country of the address. */
  readonly country: CountryDisplay;
  /** The country area of the address. */
  readonly countryArea: Scalars['String']['output'];
  /** The given name of the address. */
  readonly firstName: Scalars['String']['output'];
  /** The ID of the address. */
  readonly id: Scalars['ID']['output'];
  /** Address is user's default billing address. */
  readonly isDefaultBillingAddress?: Maybe<Scalars['Boolean']['output']>;
  /** Address is user's default shipping address. */
  readonly isDefaultShippingAddress?: Maybe<Scalars['Boolean']['output']>;
  /** The family name of the address. */
  readonly lastName: Scalars['String']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** The phone number assigned the address. */
  readonly phone?: Maybe<Scalars['String']['output']>;
  /** The postal code of the address. */
  readonly postalCode: Scalars['String']['output'];
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** The first line of the address. */
  readonly streetAddress1: Scalars['String']['output'];
  /** The second line of the address. */
  readonly streetAddress2: Scalars['String']['output'];
};


/** Represents user address data. */
export type AddressMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents user address data. */
export type AddressMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents user address data. */
export type AddressPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents user address data. */
export type AddressPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/**
 * Creates user address.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - ADDRESS_CREATED (async): A new address was created.
 */
export type AddressCreate = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly address?: Maybe<Address>;
  readonly errors: ReadonlyArray<AccountError>;
  /** A user instance for which the address was created. */
  readonly user?: Maybe<User>;
};

/** Event sent when new address is created. */
export type AddressCreated = Event & {
  /** The address the event relates to. */
  readonly address?: Maybe<Address>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Deletes an address.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - ADDRESS_DELETED (async): An address was deleted.
 */
export type AddressDelete = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly address?: Maybe<Address>;
  readonly errors: ReadonlyArray<AccountError>;
  /** A user instance for which the address was deleted. */
  readonly user?: Maybe<User>;
};

/** Event sent when address is deleted. */
export type AddressDeleted = Event & {
  /** The address the event relates to. */
  readonly address?: Maybe<Address>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Filtering options for addresses. */
export type AddressFilterInput = {
  readonly country?: InputMaybe<CountryCodeEnumFilterInput>;
  readonly phoneNumber?: InputMaybe<StringFilterInput>;
};

export type AddressInput = {
  /** City. */
  readonly city?: InputMaybe<Scalars['String']['input']>;
  /** District. */
  readonly cityArea?: InputMaybe<Scalars['String']['input']>;
  /** Company or organization. */
  readonly companyName?: InputMaybe<Scalars['String']['input']>;
  /** Country. */
  readonly country?: InputMaybe<CountryCode>;
  /** State or province. */
  readonly countryArea?: InputMaybe<Scalars['String']['input']>;
  /** Given name. */
  readonly firstName?: InputMaybe<Scalars['String']['input']>;
  /** Family name. */
  readonly lastName?: InputMaybe<Scalars['String']['input']>;
  /**
   * Address public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /**
   * Phone number.
   *
   * Phone numbers are validated with Google's [libphonenumber](https://github.com/google/libphonenumber) library.
   */
  readonly phone?: InputMaybe<Scalars['String']['input']>;
  /** Postal code. */
  readonly postalCode?: InputMaybe<Scalars['String']['input']>;
  /**
   * Determine if the address should be validated. By default, Saleor accepts only address inputs matching ruleset from [Google Address Data]{https://chromium-i18n.appspot.com/ssl-address), using [i18naddress](https://github.com/mirumee/google-i18n-address) library. Some mutations may require additional permissions to use the the field. More info about permissions can be found in relevant mutation.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly skipValidation?: InputMaybe<Scalars['Boolean']['input']>;
  /** Address. */
  readonly streetAddress1?: InputMaybe<Scalars['String']['input']>;
  /** Address. */
  readonly streetAddress2?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Sets a default address for the given user.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_UPDATED (async): A customer was updated.
 */
export type AddressSetDefault = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  /** An updated user instance. */
  readonly user?: Maybe<User>;
};

export type AddressTypeEnum =
  | 'BILLING'
  | 'SHIPPING';

/**
 * Updates an address.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - ADDRESS_UPDATED (async): An address was updated.
 */
export type AddressUpdate = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly address?: Maybe<Address>;
  readonly errors: ReadonlyArray<AccountError>;
  /** A user object for which the address was edited. */
  readonly user?: Maybe<User>;
};

/** Event sent when address is updated. */
export type AddressUpdated = Event & {
  /** The address the event relates to. */
  readonly address?: Maybe<Address>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Represents address validation rules for a country. */
export type AddressValidationData = {
  /**
   * The address format of the address validation rule.
   *
   * Many fields in the JSON refer to address fields by one-letter abbreviations. These are defined as follows:
   *
   * - `N`: Name
   * - `O`: Organization
   * - `A`: Street Address Line(s)
   * - `D`: Dependent locality (may be an inner-city district or a suburb)
   * - `C`: City or Locality
   * - `S`: Administrative area such as a state, province, island etc
   * - `Z`: Zip or postal code
   * - `X`: Sorting code
   *
   * [Click here for more information.](https://github.com/google/libaddressinput/wiki/AddressValidationMetadata)
   */
  readonly addressFormat: Scalars['String']['output'];
  /**
   * The latin address format of the address validation rule.
   *
   * Many fields in the JSON refer to address fields by one-letter abbreviations. These are defined as follows:
   *
   * - `N`: Name
   * - `O`: Organization
   * - `A`: Street Address Line(s)
   * - `D`: Dependent locality (may be an inner-city district or a suburb)
   * - `C`: City or Locality
   * - `S`: Administrative area such as a state, province, island etc
   * - `Z`: Zip or postal code
   * - `X`: Sorting code
   *
   * [Click here for more information.](https://github.com/google/libaddressinput/wiki/AddressValidationMetadata)
   */
  readonly addressLatinFormat: Scalars['String']['output'];
  /** The allowed fields to use in address. */
  readonly allowedFields: ReadonlyArray<Scalars['String']['output']>;
  /** The available choices for the city area of the address validation rule. */
  readonly cityAreaChoices: ReadonlyArray<ChoiceValue>;
  /** The formal name of the city area of the address validation rule. */
  readonly cityAreaType: Scalars['String']['output'];
  /** The available choices for the city of the address validation rule. */
  readonly cityChoices: ReadonlyArray<ChoiceValue>;
  /** The formal name of the city of the address validation rule. */
  readonly cityType: Scalars['String']['output'];
  /** The available choices for the country area of the address validation rule. */
  readonly countryAreaChoices: ReadonlyArray<ChoiceValue>;
  /** The formal name of the county area of the address validation rule. */
  readonly countryAreaType: Scalars['String']['output'];
  /** The country code of the address validation rule. */
  readonly countryCode: Scalars['String']['output'];
  /** The country name of the address validation rule. */
  readonly countryName: Scalars['String']['output'];
  /** The example postal code of the address validation rule. */
  readonly postalCodeExamples: ReadonlyArray<Scalars['String']['output']>;
  /** The regular expression for postal code validation. */
  readonly postalCodeMatchers: ReadonlyArray<Scalars['String']['output']>;
  /** The postal code prefix of the address validation rule. */
  readonly postalCodePrefix: Scalars['String']['output'];
  /** The formal name of the postal code of the address validation rule. */
  readonly postalCodeType: Scalars['String']['output'];
  /** The required fields to create a valid address. */
  readonly requiredFields: ReadonlyArray<Scalars['String']['output']>;
  /** The list of fields that should be in upper case for address validation rule. */
  readonly upperFields: ReadonlyArray<Scalars['String']['output']>;
};

/** Represents allocation. */
export type Allocation = Node & {
  /** The ID of allocation. */
  readonly id: Scalars['ID']['output'];
  /**
   * Quantity allocated for orders.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  readonly quantity: Scalars['Int']['output'];
  /**
   * The warehouse were items were allocated.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  readonly warehouse: Warehouse;
};

/**
 * Determine the allocation strategy for the channel.
 *
 *     PRIORITIZE_SORTING_ORDER - allocate stocks according to the warehouses' order
 *     within the channel
 *
 *     PRIORITIZE_HIGH_STOCK - allocate stock in a warehouse with the most stock
 */
export type AllocationStrategyEnum =
  | 'PRIORITIZE_HIGH_STOCK'
  | 'PRIORITIZE_SORTING_ORDER';

/** Represents app data. */
export type App = Node & ObjectWithMetadata & {
  /** Description of this app. */
  readonly aboutApp?: Maybe<Scalars['String']['output']>;
  /** JWT token used to authenticate by third-party app. */
  readonly accessToken?: Maybe<Scalars['String']['output']>;
  /** URL to iframe with the app. */
  readonly appUrl?: Maybe<Scalars['String']['output']>;
  /** The App's author name. */
  readonly author?: Maybe<Scalars['String']['output']>;
  /** App's brand data. */
  readonly brand?: Maybe<AppBrand>;
  /**
   * Circuit breaker last state change date.
   *
   * Added in Saleor 3.21.
   */
  readonly breakerLastStateChange?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Circuit breaker state, if open, sync webhooks operation is disrupted.
   *
   * Added in Saleor 3.21.
   */
  readonly breakerState: CircuitBreakerStateEnum;
  /**
   * URL to iframe with the configuration for the app.
   * @deprecated Use `appUrl` instead.
   */
  readonly configurationUrl?: Maybe<Scalars['String']['output']>;
  /** The date and time when the app was created. */
  readonly created?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Description of the data privacy defined for this app.
   * @deprecated Use `dataPrivacyUrl` instead.
   */
  readonly dataPrivacy?: Maybe<Scalars['String']['output']>;
  /** URL to details about the privacy policy on the app owner page. */
  readonly dataPrivacyUrl?: Maybe<Scalars['String']['output']>;
  /** App's dashboard extensions. */
  readonly extensions: ReadonlyArray<AppExtension>;
  /** Homepage of the app. */
  readonly homepageUrl?: Maybe<Scalars['String']['output']>;
  /** The ID of the app. */
  readonly id: Scalars['ID']['output'];
  /**
   * Canonical app ID from the manifest
   *
   * Added in Saleor 3.19.
   */
  readonly identifier?: Maybe<Scalars['String']['output']>;
  /** Determine if app will be set active or not. */
  readonly isActive?: Maybe<Scalars['Boolean']['output']>;
  /** URL to manifest used during app's installation. */
  readonly manifestUrl?: Maybe<Scalars['String']['output']>;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Name of the app. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** List of the app's permissions. */
  readonly permissions?: Maybe<ReadonlyArray<Permission>>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Support page for the app. */
  readonly supportUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Last 4 characters of the tokens.
   *
   * Requires one of the following permissions: MANAGE_APPS, OWNER.
   */
  readonly tokens?: Maybe<ReadonlyArray<AppToken>>;
  /** Type of the app. */
  readonly type?: Maybe<AppTypeEnum>;
  /** Version number of the app. */
  readonly version?: Maybe<Scalars['String']['output']>;
  /**
   * List of webhooks assigned to this app.
   *
   * Requires one of the following permissions: MANAGE_APPS, OWNER.
   */
  readonly webhooks?: Maybe<ReadonlyArray<Webhook>>;
};


/** Represents app data. */
export type AppMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents app data. */
export type AppMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents app data. */
export type AppPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents app data. */
export type AppPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/**
 * Activate the app.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 *
 * Triggers the following webhook events:
 * - APP_STATUS_CHANGED (async): An app was activated.
 */
export type AppActivate = {
  readonly app?: Maybe<App>;
  /** @deprecated Use `errors` field instead. */
  readonly appErrors: ReadonlyArray<AppError>;
  readonly errors: ReadonlyArray<AppError>;
};

/** Represents the app's brand data. */
export type AppBrand = {
  /** App's logos details. */
  readonly logo: AppBrandLogo;
};

/** Represents the app's brand logo data. */
export type AppBrandLogo = {
  /** URL to the default logo image. */
  readonly default: Scalars['String']['output'];
};


/** Represents the app's brand logo data. */
export type AppBrandLogoDefaultArgs = {
  format?: InputMaybe<IconThumbnailFormatEnum>;
  size?: InputMaybe<Scalars['Int']['input']>;
};

export type AppCountableConnection = {
  readonly edges: ReadonlyArray<AppCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type AppCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: App;
};

/**
 * Creates a new app. Requires the following permissions: AUTHENTICATED_STAFF_USER and MANAGE_APPS.
 *
 * Triggers the following webhook events:
 * - APP_INSTALLED (async): An app was installed.
 */
export type AppCreate = {
  readonly app?: Maybe<App>;
  /** @deprecated Use `errors` field instead. */
  readonly appErrors: ReadonlyArray<AppError>;
  /** The newly created authentication token. */
  readonly authToken?: Maybe<Scalars['String']['output']>;
  readonly errors: ReadonlyArray<AppError>;
};

/**
 * Deactivate the app.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 *
 * Triggers the following webhook events:
 * - APP_STATUS_CHANGED (async): An app was deactivated.
 */
export type AppDeactivate = {
  readonly app?: Maybe<App>;
  /** @deprecated Use `errors` field instead. */
  readonly appErrors: ReadonlyArray<AppError>;
  readonly errors: ReadonlyArray<AppError>;
};

/**
 * Deletes an app.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 *
 * Triggers the following webhook events:
 * - APP_DELETED (async): An app was deleted.
 */
export type AppDelete = {
  readonly app?: Maybe<App>;
  /** @deprecated Use `errors` field instead. */
  readonly appErrors: ReadonlyArray<AppError>;
  readonly errors: ReadonlyArray<AppError>;
};

/**
 * Deletes failed installation.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 */
export type AppDeleteFailedInstallation = {
  /** @deprecated Use `errors` field instead. */
  readonly appErrors: ReadonlyArray<AppError>;
  readonly appInstallation?: Maybe<AppInstallation>;
  readonly errors: ReadonlyArray<AppError>;
};

/** Event sent when app is deleted. */
export type AppDeleted = Event & {
  /** The application the event relates to. */
  readonly app?: Maybe<App>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type AppError = {
  /** The error code. */
  readonly code: AppErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of permissions which causes the error. */
  readonly permissions?: Maybe<ReadonlyArray<PermissionEnum>>;
};

export type AppErrorCode =
  | 'FORBIDDEN'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_CUSTOM_HEADERS'
  | 'INVALID_MANIFEST_FORMAT'
  | 'INVALID_PERMISSION'
  | 'INVALID_STATUS'
  | 'INVALID_URL_FORMAT'
  | 'MANIFEST_URL_CANT_CONNECT'
  | 'NOT_FOUND'
  | 'OUT_OF_SCOPE_APP'
  | 'OUT_OF_SCOPE_PERMISSION'
  | 'REQUIRED'
  | 'UNIQUE'
  | 'UNSUPPORTED_SALEOR_VERSION';

/** Represents app data. */
export type AppExtension = Node & {
  /** JWT token used to authenticate by third-party app extension. */
  readonly accessToken?: Maybe<Scalars['String']['output']>;
  /** The app assigned to app extension. */
  readonly app: App;
  /** The ID of the app extension. */
  readonly id: Scalars['ID']['output'];
  /** Label of the extension to show in the dashboard. */
  readonly label: Scalars['String']['output'];
  /** Place where given extension will be mounted. */
  readonly mount: AppExtensionMountEnum;
  /**
   * App extension options.
   *
   * Added in Saleor 3.22.
   */
  readonly options?: Maybe<AppExtensionPossibleOptions>;
  /** List of the app extension's permissions. */
  readonly permissions: ReadonlyArray<Permission>;
  /** Type of way how app extension will be opened. */
  readonly target: AppExtensionTargetEnum;
  /** URL of a view where extension's iframe is placed. */
  readonly url: Scalars['String']['output'];
};

export type AppExtensionCountableConnection = {
  readonly edges: ReadonlyArray<AppExtensionCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type AppExtensionCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: AppExtension;
};

export type AppExtensionFilterInput = {
  readonly mount?: InputMaybe<ReadonlyArray<AppExtensionMountEnum>>;
  readonly target?: InputMaybe<AppExtensionTargetEnum>;
};

/** All places where app extension can be mounted. */
export type AppExtensionMountEnum =
  | 'CATEGORY_DETAILS_MORE_ACTIONS'
  | 'CATEGORY_OVERVIEW_CREATE'
  | 'CATEGORY_OVERVIEW_MORE_ACTIONS'
  | 'COLLECTION_DETAILS_MORE_ACTIONS'
  | 'COLLECTION_DETAILS_WIDGETS'
  | 'COLLECTION_OVERVIEW_CREATE'
  | 'COLLECTION_OVERVIEW_MORE_ACTIONS'
  | 'CUSTOMER_DETAILS_MORE_ACTIONS'
  | 'CUSTOMER_DETAILS_WIDGETS'
  | 'CUSTOMER_OVERVIEW_CREATE'
  | 'CUSTOMER_OVERVIEW_MORE_ACTIONS'
  | 'DISCOUNT_DETAILS_MORE_ACTIONS'
  | 'DISCOUNT_OVERVIEW_CREATE'
  | 'DISCOUNT_OVERVIEW_MORE_ACTIONS'
  | 'DRAFT_ORDER_DETAILS_MORE_ACTIONS'
  | 'DRAFT_ORDER_DETAILS_WIDGETS'
  | 'DRAFT_ORDER_OVERVIEW_CREATE'
  | 'DRAFT_ORDER_OVERVIEW_MORE_ACTIONS'
  | 'GIFT_CARD_DETAILS_MORE_ACTIONS'
  | 'GIFT_CARD_DETAILS_WIDGETS'
  | 'GIFT_CARD_OVERVIEW_CREATE'
  | 'GIFT_CARD_OVERVIEW_MORE_ACTIONS'
  | 'MENU_DETAILS_MORE_ACTIONS'
  | 'MENU_OVERVIEW_CREATE'
  | 'MENU_OVERVIEW_MORE_ACTIONS'
  | 'NAVIGATION_CATALOG'
  | 'NAVIGATION_CUSTOMERS'
  | 'NAVIGATION_DISCOUNTS'
  | 'NAVIGATION_ORDERS'
  | 'NAVIGATION_PAGES'
  | 'NAVIGATION_TRANSLATIONS'
  | 'ORDER_DETAILS_MORE_ACTIONS'
  | 'ORDER_DETAILS_WIDGETS'
  | 'ORDER_OVERVIEW_CREATE'
  | 'ORDER_OVERVIEW_MORE_ACTIONS'
  | 'PAGE_DETAILS_MORE_ACTIONS'
  | 'PAGE_OVERVIEW_CREATE'
  | 'PAGE_OVERVIEW_MORE_ACTIONS'
  | 'PAGE_TYPE_DETAILS_MORE_ACTIONS'
  | 'PAGE_TYPE_OVERVIEW_CREATE'
  | 'PAGE_TYPE_OVERVIEW_MORE_ACTIONS'
  | 'PRODUCT_DETAILS_MORE_ACTIONS'
  | 'PRODUCT_DETAILS_WIDGETS'
  | 'PRODUCT_OVERVIEW_CREATE'
  | 'PRODUCT_OVERVIEW_MORE_ACTIONS'
  | 'VOUCHER_DETAILS_MORE_ACTIONS'
  | 'VOUCHER_DETAILS_WIDGETS'
  | 'VOUCHER_OVERVIEW_CREATE'
  | 'VOUCHER_OVERVIEW_MORE_ACTIONS';

/** Represents the options for an app extension. */
export type AppExtensionOptionsNewTab = {
  /** Options controlling behavior of the NEW_TAB extension target */
  readonly newTabTarget?: Maybe<NewTabTargetOptions>;
};

/** Represents the options for an app extension. */
export type AppExtensionOptionsWidget = {
  /** Options for displaying a Widget */
  readonly widgetTarget?: Maybe<WidgetTargetOptions>;
};

export type AppExtensionPossibleOptions = AppExtensionOptionsNewTab | AppExtensionOptionsWidget;

/**
 * All available ways of opening an app extension.
 *
 *     POPUP - app's extension will be mounted as a popup window
 *     APP_PAGE - redirect to app's page
 */
export type AppExtensionTargetEnum =
  | 'APP_PAGE'
  | 'NEW_TAB'
  | 'POPUP'
  | 'WIDGET';

/**
 * Fetch and validate manifest.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 */
export type AppFetchManifest = {
  /** @deprecated Use `errors` field instead. */
  readonly appErrors: ReadonlyArray<AppError>;
  readonly errors: ReadonlyArray<AppError>;
  /** The validated manifest. */
  readonly manifest?: Maybe<Manifest>;
};

export type AppFilterInput = {
  readonly isActive?: InputMaybe<Scalars['Boolean']['input']>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly type?: InputMaybe<AppTypeEnum>;
};

export type AppInput = {
  /**
   * Canonical app ID. If not provided, the identifier will be generated based on app.id.
   *
   * Added in Saleor 3.19.
   */
  readonly identifier?: InputMaybe<Scalars['String']['input']>;
  /** Name of the app. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** List of permission code names to assign to this app. */
  readonly permissions?: InputMaybe<ReadonlyArray<PermissionEnum>>;
};

/** Install new app by using app manifest. Requires the following permissions: AUTHENTICATED_STAFF_USER and MANAGE_APPS. */
export type AppInstall = {
  /** @deprecated Use `errors` field instead. */
  readonly appErrors: ReadonlyArray<AppError>;
  readonly appInstallation?: Maybe<AppInstallation>;
  readonly errors: ReadonlyArray<AppError>;
};

export type AppInstallInput = {
  /** Determine if app will be set active or not. */
  readonly activateAfterInstallation?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the app to install. */
  readonly appName?: InputMaybe<Scalars['String']['input']>;
  /** URL to app's manifest in JSON format. */
  readonly manifestUrl?: InputMaybe<Scalars['String']['input']>;
  /** List of permission code names to assign to this app. */
  readonly permissions?: InputMaybe<ReadonlyArray<PermissionEnum>>;
};

/** Represents ongoing installation of app. */
export type AppInstallation = Job & Node & {
  /** The name of the app installation. */
  readonly appName: Scalars['String']['output'];
  /** App's brand data. */
  readonly brand?: Maybe<AppBrand>;
  /** Created date time of job in ISO 8601 format. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The ID of the app installation. */
  readonly id: Scalars['ID']['output'];
  /** The URL address of manifest for the app installation. */
  readonly manifestUrl: Scalars['String']['output'];
  /** Job message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Job status. */
  readonly status: JobStatusEnum;
  /** Date time of job last update in ISO 8601 format. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** Event sent when new app is installed. */
export type AppInstalled = Event & {
  /** The application the event relates to. */
  readonly app?: Maybe<App>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Represents the app's manifest brand data. */
export type AppManifestBrand = {
  /** App's logos details. */
  readonly logo: AppManifestBrandLogo;
};

/** Represents the app's manifest brand data. */
export type AppManifestBrandLogo = {
  /** Data URL with a base64 encoded logo image. */
  readonly default: Scalars['String']['output'];
};


/** Represents the app's manifest brand data. */
export type AppManifestBrandLogoDefaultArgs = {
  format?: InputMaybe<IconThumbnailFormatEnum>;
  size?: InputMaybe<Scalars['Int']['input']>;
};

export type AppManifestExtension = {
  /** Label of the extension to show in the dashboard. */
  readonly label: Scalars['String']['output'];
  /** Place where given extension will be mounted. */
  readonly mount: AppExtensionMountEnum;
  /** List of the app extension's permissions. */
  readonly permissions: ReadonlyArray<Permission>;
  /** Type of way how app extension will be opened. */
  readonly target: AppExtensionTargetEnum;
  /** URL of a view where extension's iframe is placed. */
  readonly url: Scalars['String']['output'];
};

export type AppManifestRequiredSaleorVersion = {
  /** Required Saleor version as semver range. */
  readonly constraint: Scalars['String']['output'];
  /** Informs if the Saleor version matches the required one. */
  readonly satisfied: Scalars['Boolean']['output'];
};

export type AppManifestWebhook = {
  /** The asynchronous events that webhook wants to subscribe. */
  readonly asyncEvents?: Maybe<ReadonlyArray<WebhookEventTypeAsyncEnum>>;
  /** The name of the webhook. */
  readonly name: Scalars['String']['output'];
  /** Subscription query of a webhook */
  readonly query: Scalars['String']['output'];
  /** The synchronous events that webhook wants to subscribe. */
  readonly syncEvents?: Maybe<ReadonlyArray<WebhookEventTypeSyncEnum>>;
  /** The url to receive the payload. */
  readonly targetUrl: Scalars['String']['output'];
};

/**
 * Re-enable sync webhooks for provided app. Can be used to manually re-enable sync webhooks for the app before the cooldown period ends.
 *
 * Added in Saleor 3.21.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 */
export type AppReenableSyncWebhooks = {
  /** App for which sync webhooks were re-enabled. */
  readonly app?: Maybe<App>;
  /** @deprecated Use `errors` field instead. */
  readonly appErrors: ReadonlyArray<AppError>;
  readonly errors: ReadonlyArray<AppError>;
};

/**
 * Retry failed installation of new app.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 *
 * Triggers the following webhook events:
 * - APP_INSTALLED (async): An app was installed.
 */
export type AppRetryInstall = {
  /** @deprecated Use `errors` field instead. */
  readonly appErrors: ReadonlyArray<AppError>;
  readonly appInstallation?: Maybe<AppInstallation>;
  readonly errors: ReadonlyArray<AppError>;
};

export type AppSortField =
  /** Sort apps by creation date. */
  | 'CREATION_DATE'
  /** Sort apps by name. */
  | 'NAME';

export type AppSortingInput = {
  /** Specifies the direction in which to sort apps. */
  readonly direction: OrderDirection;
  /** Sort apps by the selected field. */
  readonly field: AppSortField;
};

/** Event sent when app status has changed. */
export type AppStatusChanged = Event & {
  /** The application the event relates to. */
  readonly app?: Maybe<App>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Represents token data. */
export type AppToken = Node & {
  /** Last 4 characters of the token. */
  readonly authToken?: Maybe<Scalars['String']['output']>;
  /** The ID of the app token. */
  readonly id: Scalars['ID']['output'];
  /** Name of the authenticated token. */
  readonly name?: Maybe<Scalars['String']['output']>;
};

/**
 * Creates a new token.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 */
export type AppTokenCreate = {
  /** @deprecated Use `errors` field instead. */
  readonly appErrors: ReadonlyArray<AppError>;
  readonly appToken?: Maybe<AppToken>;
  /** The newly created authentication token. */
  readonly authToken?: Maybe<Scalars['String']['output']>;
  readonly errors: ReadonlyArray<AppError>;
};

/**
 * Deletes an authentication token assigned to app.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 */
export type AppTokenDelete = {
  /** @deprecated Use `errors` field instead. */
  readonly appErrors: ReadonlyArray<AppError>;
  readonly appToken?: Maybe<AppToken>;
  readonly errors: ReadonlyArray<AppError>;
};

export type AppTokenInput = {
  /** ID of app. */
  readonly app: Scalars['ID']['input'];
  /** Name of the token. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
};

/** Verify provided app token. */
export type AppTokenVerify = {
  /** @deprecated Use `errors` field instead. */
  readonly appErrors: ReadonlyArray<AppError>;
  readonly errors: ReadonlyArray<AppError>;
  /** Determine if token is valid or not. */
  readonly valid: Scalars['Boolean']['output'];
};

/** Enum determining type of your App. */
export type AppTypeEnum =
  /** Local Saleor App. The app is fully manageable from dashboard. You can change assigned permissions, add webhooks, or authentication token */
  | 'LOCAL'
  /** Third party external App. Installation is fully automated. Saleor uses a defined App manifest to gather all required information. */
  | 'THIRDPARTY';

/**
 * Updates an existing app.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 *
 * Triggers the following webhook events:
 * - APP_UPDATED (async): An app was updated.
 */
export type AppUpdate = {
  readonly app?: Maybe<App>;
  /** @deprecated Use `errors` field instead. */
  readonly appErrors: ReadonlyArray<AppError>;
  readonly errors: ReadonlyArray<AppError>;
};

/** Event sent when app is updated. */
export type AppUpdated = Event & {
  /** The application the event relates to. */
  readonly app?: Maybe<App>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type AreaUnitsEnum =
  | 'SQ_CM'
  | 'SQ_DM'
  | 'SQ_FT'
  | 'SQ_INCH'
  | 'SQ_KM'
  | 'SQ_M'
  | 'SQ_MM'
  | 'SQ_YD';

/**
 * Assigns storefront's navigation menus.
 *
 * Requires one of the following permissions: MANAGE_MENUS, MANAGE_SETTINGS.
 */
export type AssignNavigation = {
  readonly errors: ReadonlyArray<MenuError>;
  /** Assigned navigation menu. */
  readonly menu?: Maybe<Menu>;
  /** @deprecated Use `errors` field instead. */
  readonly menuErrors: ReadonlyArray<MenuError>;
};

/**
 * Represents an attribute assigned to an object.
 *
 * Added in Saleor 3.22.
 */
export type AssignedAttribute = {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
};

export type AssignedAttributeReferenceInput = {
  /** Returns objects with a reference pointing to a category identified by the given slug. */
  readonly categorySlugs?: InputMaybe<ContainsFilterInput>;
  /** Returns objects with a reference pointing to a collection identified by the given slug. */
  readonly collectionSlugs?: InputMaybe<ContainsFilterInput>;
  /** Returns objects with a reference pointing to a page identified by the given slug. */
  readonly pageSlugs?: InputMaybe<ContainsFilterInput>;
  /** Returns objects with a reference pointing to a product identified by the given slug. */
  readonly productSlugs?: InputMaybe<ContainsFilterInput>;
  /** Returns objects with a reference pointing to a product variant identified by the given sku. */
  readonly productVariantSkus?: InputMaybe<ContainsFilterInput>;
  /** Returns objects with a reference pointing to an object identified by the given ID. */
  readonly referencedIds?: InputMaybe<ContainsFilterInput>;
};

export type AssignedAttributeValueInput = {
  /** Filter by boolean value for attributes of boolean type. */
  readonly boolean?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by date value for attributes of date type. */
  readonly date?: InputMaybe<DateRangeInput>;
  /** Filter by date time value for attributes of date time type. */
  readonly dateTime?: InputMaybe<DateTimeRangeInput>;
  /** Filter by name assigned to AttributeValue. */
  readonly name?: InputMaybe<StringFilterInput>;
  /** Filter by numeric value for attributes of numeric type. */
  readonly numeric?: InputMaybe<DecimalFilterInput>;
  /** Filter by reference attribute value. */
  readonly reference?: InputMaybe<AssignedAttributeReferenceInput>;
  /** Filter by slug assigned to AttributeValue. */
  readonly slug?: InputMaybe<StringFilterInput>;
};

export type AssignedAttributeWhereInput = {
  /** Filter by attribute slug. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
  /** Filter by value of the attribute. Only one value input field is allowed. If provided more than one, the error will be raised. */
  readonly value?: InputMaybe<AssignedAttributeValueInput>;
};

/**
 * Represents a boolean attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedBooleanAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** The assigned boolean value. */
  readonly value?: Maybe<Scalars['Boolean']['output']>;
};

/**
 * Represents a single choice value of the attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedChoiceAttributeValue = {
  /** Name of a value displayed in the interface. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Internal representation of a value (unique per attribute). */
  readonly slug?: Maybe<Scalars['String']['output']>;
  /** Translation of the name. */
  readonly translation?: Maybe<Scalars['String']['output']>;
};


/**
 * Represents a single choice value of the attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedChoiceAttributeValueTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Represents a date attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedDateAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** The assigned date value. */
  readonly value?: Maybe<Scalars['Date']['output']>;
};

/**
 * Represents a date time attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedDateTimeAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** The assigned date time value. */
  readonly value?: Maybe<Scalars['DateTime']['output']>;
};

/**
 * Represents file attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedFileAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** The assigned file. */
  readonly value?: Maybe<File>;
};

/**
 * Represents multi category reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiCategoryReferenceAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** List of assigned category references. */
  readonly value: ReadonlyArray<Category>;
};


/**
 * Represents multi category reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiCategoryReferenceAttributeValueArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']['input']>;
};

/**
 * Represents a multi choice attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiChoiceAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** List of assigned choice values. */
  readonly value: ReadonlyArray<AssignedChoiceAttributeValue>;
};


/**
 * Represents a multi choice attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiChoiceAttributeValueArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']['input']>;
};

/**
 * Represents multi collection reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiCollectionReferenceAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** List of assigned collection references. */
  readonly value: ReadonlyArray<Collection>;
};


/**
 * Represents multi collection reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiCollectionReferenceAttributeValueArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']['input']>;
};

/**
 * Represents multi page reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiPageReferenceAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** List of assigned page references. */
  readonly value: ReadonlyArray<Page>;
};


/**
 * Represents multi page reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiPageReferenceAttributeValueArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']['input']>;
};

/**
 * Represents multi product reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiProductReferenceAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** List of assigned product references. */
  readonly value: ReadonlyArray<Product>;
};


/**
 * Represents multi product reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiProductReferenceAttributeValueArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']['input']>;
};

/**
 * Represents multi product variant reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiProductVariantReferenceAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** List of assigned product variant references. */
  readonly value: ReadonlyArray<ProductVariant>;
};


/**
 * Represents multi product variant reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedMultiProductVariantReferenceAttributeValueArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']['input']>;
};

/**
 * Represents a numeric value of an attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedNumericAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** The assigned numeric value. */
  readonly value?: Maybe<Scalars['Float']['output']>;
};

/**
 * Represents plain text attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedPlainTextAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** Translation of the plain text content in the specified language. */
  readonly translation?: Maybe<Scalars['String']['output']>;
  /** The assigned plain text content. */
  readonly value?: Maybe<Scalars['String']['output']>;
};


/**
 * Represents plain text attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedPlainTextAttributeTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Represents single category reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSingleCategoryReferenceAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** The assigned category reference. */
  readonly value?: Maybe<Category>;
};

/**
 * Represents a single choice attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSingleChoiceAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** The assigned choice value. */
  readonly value?: Maybe<AssignedChoiceAttributeValue>;
};

/**
 * Represents single collection reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSingleCollectionReferenceAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** The assigned collection reference. */
  readonly value?: Maybe<Collection>;
};

/**
 * Represents single page reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSinglePageReferenceAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** The assigned page reference. */
  readonly value?: Maybe<Page>;
};

/**
 * Represents single product reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSingleProductReferenceAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** The assigned product reference. */
  readonly value?: Maybe<Product>;
};

/**
 * Represents single product variant reference attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSingleProductVariantReferenceAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** The assigned product variant reference. */
  readonly value?: Maybe<ProductVariant>;
};

/**
 * Represents a swatch attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSwatchAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** The assigned swatch value. */
  readonly value?: Maybe<AssignedSwatchAttributeValue>;
};

/**
 * Represents a single swatch value.
 *
 * Added in Saleor 3.22.
 */
export type AssignedSwatchAttributeValue = {
  /** File associated with the attribute. */
  readonly file?: Maybe<File>;
  /** Hex color code. */
  readonly hexColor?: Maybe<Scalars['String']['output']>;
  /** Name of the selected swatch value. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Slug of the selected swatch value. */
  readonly slug?: Maybe<Scalars['String']['output']>;
};

/**
 * Represents text attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedTextAttribute = AssignedAttribute & {
  /** Attribute assigned to an object. */
  readonly attribute: Attribute;
  /** Translation of the rich text content in the specified language. */
  readonly translation?: Maybe<Scalars['JSON']['output']>;
  /** The assigned rich text content. */
  readonly value?: Maybe<Scalars['JSON']['output']>;
};


/**
 * Represents text attribute.
 *
 * Added in Saleor 3.22.
 */
export type AssignedTextAttributeTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Represents assigned attribute to variant with variant selection attached. */
export type AssignedVariantAttribute = {
  /** Attribute assigned to variant. */
  readonly attribute: Attribute;
  /** Determines, whether assigned attribute is allowed for variant selection. Supported variant types for variant selection are: ['dropdown', 'boolean', 'swatch', 'numeric'] */
  readonly variantSelection: Scalars['Boolean']['output'];
};

/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type Attribute = Node & ObjectWithMetadata & {
  /**
   * Whether the attribute can be displayed in the admin product list. Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES, MANAGE_PRODUCTS, MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   * @deprecated Field no longer supported
   */
  readonly availableInGrid: Scalars['Boolean']['output'];
  /** A list of predefined attribute choices available for selection. Available only for attributes with predefined choices. */
  readonly choices?: Maybe<AttributeValueCountableConnection>;
  /** The entity type which can be used as a reference. */
  readonly entityType?: Maybe<AttributeEntityTypeEnum>;
  /** External ID of this attribute. */
  readonly externalReference?: Maybe<Scalars['String']['output']>;
  /** Whether the attribute can be filtered in dashboard. Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES, MANAGE_PRODUCTS, MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  readonly filterableInDashboard: Scalars['Boolean']['output'];
  /**
   * Whether the attribute can be filtered in storefront. Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES, MANAGE_PRODUCTS, MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   * @deprecated Field no longer supported
   */
  readonly filterableInStorefront: Scalars['Boolean']['output'];
  /** The ID of the attribute. */
  readonly id: Scalars['ID']['output'];
  /** The input type to use for entering attribute values in the dashboard. */
  readonly inputType?: Maybe<AttributeInputTypeEnum>;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Name of an attribute displayed in the interface. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** A list of product types that use this attribute as a product attribute. */
  readonly productTypes: ProductTypeCountableConnection;
  /** A list of product types that use this attribute as a product variant attribute. */
  readonly productVariantTypes: ProductTypeCountableConnection;
  /**
   * The reference types (product or page type) that are used to narrow down the choices of reference objects.
   *
   * Added in Saleor 3.22.
   */
  readonly referenceTypes?: Maybe<ReadonlyArray<ReferenceType>>;
  /** Internal representation of an attribute name. */
  readonly slug?: Maybe<Scalars['String']['output']>;
  /**
   * The position of the attribute in the storefront navigation (0 by default). Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES, MANAGE_PRODUCTS, MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   * @deprecated Field no longer supported
   */
  readonly storefrontSearchPosition: Scalars['Int']['output'];
  /** Returns translated attribute fields for the given language code. */
  readonly translation?: Maybe<AttributeTranslation>;
  /** The attribute type. */
  readonly type?: Maybe<AttributeTypeEnum>;
  /** The unit of attribute values. */
  readonly unit?: Maybe<MeasurementUnitsEnum>;
  /** Whether the attribute requires values to be passed or not. Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES, MANAGE_PRODUCTS, MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  readonly valueRequired: Scalars['Boolean']['output'];
  /** Whether the attribute should be visible or not in storefront. Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES, MANAGE_PRODUCTS, MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  readonly visibleInStorefront: Scalars['Boolean']['output'];
  /** Flag indicating that attribute has predefined choices. */
  readonly withChoices: Scalars['Boolean']['output'];
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeChoicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AttributeValueFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<AttributeChoicesSortingInput>;
  where?: InputMaybe<AttributeValueWhereInput>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributePrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributePrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeProductTypesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeProductVariantTypesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeReferenceTypesArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']['input']>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates attributes.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_CREATED (async): An attribute was created.
 */
export type AttributeBulkCreate = {
  /** Returns how many objects were created. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<AttributeBulkCreateError>;
  /** List of the created attributes. */
  readonly results: ReadonlyArray<AttributeBulkCreateResult>;
};

export type AttributeBulkCreateError = {
  /** The error code. */
  readonly code: AttributeBulkCreateErrorCode;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly path?: Maybe<Scalars['String']['output']>;
};

export type AttributeBulkCreateErrorCode =
  | 'ALREADY_EXISTS'
  | 'BLANK'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'MAX_LENGTH'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type AttributeBulkCreateResult = {
  /** Attribute data. */
  readonly attribute?: Maybe<Attribute>;
  /** List of errors occurred on create attempt. */
  readonly errors?: Maybe<ReadonlyArray<AttributeBulkCreateError>>;
};

/**
 * Deletes attributes.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_DELETED (async): An attribute was deleted.
 */
export type AttributeBulkDelete = {
  /** @deprecated Use `errors` field instead. */
  readonly attributeErrors: ReadonlyArray<AttributeError>;
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<AttributeError>;
};

/**
 * Creates/updates translations for attributes.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type AttributeBulkTranslate = {
  /** Returns how many translations were created/updated. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<AttributeBulkTranslateError>;
  /** List of the translations. */
  readonly results: ReadonlyArray<AttributeBulkTranslateResult>;
};

export type AttributeBulkTranslateError = {
  /** The error code. */
  readonly code: AttributeTranslateErrorCode;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly path?: Maybe<Scalars['String']['output']>;
};

export type AttributeBulkTranslateInput = {
  /** External reference of an attribute. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** Attribute ID. */
  readonly id?: InputMaybe<Scalars['ID']['input']>;
  /** Translation language code. */
  readonly languageCode: LanguageCodeEnum;
  /** Translation fields. */
  readonly translationFields: NameTranslationInput;
};

export type AttributeBulkTranslateResult = {
  /** List of errors occurred on translation attempt. */
  readonly errors?: Maybe<ReadonlyArray<AttributeBulkTranslateError>>;
  /** Attribute translation data. */
  readonly translation?: Maybe<AttributeTranslation>;
};

/**
 * Updates attributes.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_UPDATED (async): An attribute was updated. Optionally called when new attribute value was created or deleted.
 * - ATTRIBUTE_VALUE_CREATED (async): Called optionally when an attribute value was created.
 * - ATTRIBUTE_VALUE_DELETED (async): Called optionally when an attribute value was deleted.
 */
export type AttributeBulkUpdate = {
  /** Returns how many objects were updated. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<AttributeBulkUpdateError>;
  /** List of the updated attributes. */
  readonly results: ReadonlyArray<AttributeBulkUpdateResult>;
};

export type AttributeBulkUpdateError = {
  /** The error code. */
  readonly code: AttributeBulkUpdateErrorCode;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly path?: Maybe<Scalars['String']['output']>;
};

export type AttributeBulkUpdateErrorCode =
  | 'ALREADY_EXISTS'
  | 'BLANK'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'MAX_LENGTH'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type AttributeBulkUpdateInput = {
  /** External ID of this attribute. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** Fields to update. */
  readonly fields: AttributeUpdateInput;
  /** ID of an attribute to update. */
  readonly id?: InputMaybe<Scalars['ID']['input']>;
};

export type AttributeBulkUpdateResult = {
  /** Attribute data. */
  readonly attribute?: Maybe<Attribute>;
  /** List of errors occurred on update attempt. */
  readonly errors?: Maybe<ReadonlyArray<AttributeBulkUpdateError>>;
};

export type AttributeChoicesSortField =
  /** Sort attribute choice by name. */
  | 'NAME'
  /** Sort attribute choice by slug. */
  | 'SLUG';

export type AttributeChoicesSortingInput = {
  /** Specifies the direction in which to sort attribute choices. */
  readonly direction: OrderDirection;
  /** Sort attribute choices by the selected field. */
  readonly field: AttributeChoicesSortField;
};

export type AttributeCountableConnection = {
  readonly edges: ReadonlyArray<AttributeCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type AttributeCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Attribute;
};

/**
 * Creates an attribute.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_CREATED (async): An attribute was created.
 */
export type AttributeCreate = {
  /** The created attribute. */
  readonly attribute?: Maybe<Attribute>;
  /** @deprecated Use `errors` field instead. */
  readonly attributeErrors: ReadonlyArray<AttributeError>;
  readonly errors: ReadonlyArray<AttributeError>;
};

/**
 * Represents an input for create of attribute.
 *
 * NOTE: Deprecated fields `filterableInStorefront`, `storefrontSearchPosition` and `availableInGrid` are not supported in bulk mutations: `attributeBulkCreate`, `attributeBulkUpdate`.
 */
export type AttributeCreateInput = {
  /**
   * Whether the attribute can be displayed in the admin product list.
   * @deprecated Field no longer supported
   */
  readonly availableInGrid?: InputMaybe<Scalars['Boolean']['input']>;
  /** The entity type which can be used as a reference. */
  readonly entityType?: InputMaybe<AttributeEntityTypeEnum>;
  /** External ID of this attribute. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** Whether the attribute can be filtered in dashboard. */
  readonly filterableInDashboard?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether the attribute can be filtered in storefront.
   * @deprecated Field no longer supported
   */
  readonly filterableInStorefront?: InputMaybe<Scalars['Boolean']['input']>;
  /** The input type to use for entering attribute values in the dashboard. */
  readonly inputType?: InputMaybe<AttributeInputTypeEnum>;
  /** Whether the attribute is for variants only. */
  readonly isVariantOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of an attribute displayed in the interface. */
  readonly name: Scalars['String']['input'];
  /**
   * Specifies reference types to narrow down the choices of reference objects. Applicable only for `REFERENCE` and `SINGLE_REFERENCE` attributes with `PRODUCT`, `PRODUCT_VARIANT` and `PAGE` entity types. Accepts `ProductType` IDs for `PRODUCT` and `PRODUCT_VARIANT` entity types, and `PageType` IDs for `PAGE` entity type. If omitted, all objects of the selected entity type are available as attribute values.
   *
   * A maximum of 100 reference types can be specified.
   *
   * Added in Saleor 3.22.
   */
  readonly referenceTypes?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Internal representation of an attribute name. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
  /**
   * The position of the attribute in the storefront navigation (0 by default).
   * @deprecated Field no longer supported
   */
  readonly storefrontSearchPosition?: InputMaybe<Scalars['Int']['input']>;
  /** The attribute type. */
  readonly type: AttributeTypeEnum;
  /** The unit of attribute values. */
  readonly unit?: InputMaybe<MeasurementUnitsEnum>;
  /** Whether the attribute requires values to be passed or not. */
  readonly valueRequired?: InputMaybe<Scalars['Boolean']['input']>;
  /** List of attribute's values. */
  readonly values?: InputMaybe<ReadonlyArray<AttributeValueCreateInput>>;
  /** Whether the attribute should be visible or not in storefront. */
  readonly visibleInStorefront?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Event sent when new attribute is created. */
export type AttributeCreated = Event & {
  /** The attribute the event relates to. */
  readonly attribute?: Maybe<Attribute>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Deletes an attribute.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_DELETED (async): An attribute was deleted.
 */
export type AttributeDelete = {
  readonly attribute?: Maybe<Attribute>;
  /** @deprecated Use `errors` field instead. */
  readonly attributeErrors: ReadonlyArray<AttributeError>;
  readonly errors: ReadonlyArray<AttributeError>;
};

/** Event sent when attribute is deleted. */
export type AttributeDeleted = Event & {
  /** The attribute the event relates to. */
  readonly attribute?: Maybe<Attribute>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type AttributeEntityTypeEnum =
  | 'CATEGORY'
  | 'COLLECTION'
  | 'PAGE'
  | 'PRODUCT'
  | 'PRODUCT_VARIANT';

export type AttributeEntityTypeEnumFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<AttributeEntityTypeEnum>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<AttributeEntityTypeEnum>>;
};

export type AttributeError = {
  /** The error code. */
  readonly code: AttributeErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type AttributeErrorCode =
  | 'ALREADY_EXISTS'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type AttributeFilterInput = {
  readonly availableInGrid?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Specifies the channel by which the data should be filtered.
   * @deprecated Use root-level channel argument instead.
   */
  readonly channel?: InputMaybe<Scalars['String']['input']>;
  readonly filterableInDashboard?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filterableInStorefront?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly inCategory?: InputMaybe<Scalars['ID']['input']>;
  readonly inCollection?: InputMaybe<Scalars['ID']['input']>;
  readonly isVariantOnly?: InputMaybe<Scalars['Boolean']['input']>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly slugs?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly type?: InputMaybe<AttributeTypeEnum>;
  readonly valueRequired?: InputMaybe<Scalars['Boolean']['input']>;
  readonly visibleInStorefront?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AttributeInput = {
  /**
   * The boolean value of the attribute. Requires `slug` to be provided.
   * @deprecated Use `value` instead.
   */
  readonly boolean?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The date range that the returned values should be in. In case of date/time attributes, the UTC midnight of the given date is used. Requires `slug` to be provided.
   * @deprecated Use `value` instead.
   */
  readonly date?: InputMaybe<DateRangeInput>;
  /**
   * The date/time range that the returned values should be in. Requires `slug` to be provided.
   * @deprecated Use `value` instead.
   */
  readonly dateTime?: InputMaybe<DateTimeRangeInput>;
  /** Internal representation of an attribute name. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
  /** Filter by value of the attribute. Only one value input field is allowed. If provided more than one, the error will be raised. Cannot be combined with deprecated fields of `AttributeInput`. */
  readonly value?: InputMaybe<AssignedAttributeValueInput>;
  /**
   * Slugs identifying the attributeValues associated with the Attribute. When specified, it filters the results to include only records with one of the matching values. Requires `slug` to be provided.
   * @deprecated Use `value` instead.
   */
  readonly values?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /**
   * The range that the returned values should be in. Requires `slug` to be provided.
   * @deprecated Use `value` instead.
   */
  readonly valuesRange?: InputMaybe<IntRangeInput>;
};

export type AttributeInputTypeEnum =
  | 'BOOLEAN'
  | 'DATE'
  | 'DATE_TIME'
  | 'DROPDOWN'
  | 'FILE'
  | 'MULTISELECT'
  | 'NUMERIC'
  | 'PLAIN_TEXT'
  | 'REFERENCE'
  | 'RICH_TEXT'
  | 'SINGLE_REFERENCE'
  | 'SWATCH';

export type AttributeInputTypeEnumFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<AttributeInputTypeEnum>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<AttributeInputTypeEnum>>;
};

/**
 * Reorder the values of an attribute.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_VALUE_UPDATED (async): An attribute value was updated.
 * - ATTRIBUTE_UPDATED (async): An attribute was updated.
 */
export type AttributeReorderValues = {
  /** Attribute from which values are reordered. */
  readonly attribute?: Maybe<Attribute>;
  /** @deprecated Use `errors` field instead. */
  readonly attributeErrors: ReadonlyArray<AttributeError>;
  readonly errors: ReadonlyArray<AttributeError>;
};

export type AttributeSortField =
  /** Sort attributes based on whether they can be displayed or not in a product grid. */
  | 'AVAILABLE_IN_GRID'
  /** Sort attributes by the filterable in dashboard flag */
  | 'FILTERABLE_IN_DASHBOARD'
  /** Sort attributes by the filterable in storefront flag */
  | 'FILTERABLE_IN_STOREFRONT'
  /** Sort attributes by the variant only flag */
  | 'IS_VARIANT_ONLY'
  /** Sort attributes by name */
  | 'NAME'
  /** Sort attributes by slug */
  | 'SLUG'
  /** Sort attributes by their position in storefront */
  | 'STOREFRONT_SEARCH_POSITION'
  /** Sort attributes by the value required flag */
  | 'VALUE_REQUIRED'
  /** Sort attributes by visibility in the storefront */
  | 'VISIBLE_IN_STOREFRONT';

export type AttributeSortingInput = {
  /** Specifies the direction in which to sort attributes. */
  readonly direction: OrderDirection;
  /** Sort attributes by the selected field. */
  readonly field: AttributeSortField;
};

/** Represents attribute's original translatable fields and related translations. */
export type AttributeTranslatableContent = Node & {
  /**
   * Custom attribute of a product.
   * @deprecated Get model fields from the root level queries.
   */
  readonly attribute?: Maybe<Attribute>;
  /** The ID of the attribute to translate. */
  readonly attributeId: Scalars['ID']['output'];
  /** The ID of the attribute translatable content. */
  readonly id: Scalars['ID']['output'];
  /** Name of the attribute to translate. */
  readonly name: Scalars['String']['output'];
  /** Returns translated attribute fields for the given language code. */
  readonly translation?: Maybe<AttributeTranslation>;
};


/** Represents attribute's original translatable fields and related translations. */
export type AttributeTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for an attribute.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type AttributeTranslate = {
  readonly attribute?: Maybe<Attribute>;
  readonly errors: ReadonlyArray<TranslationError>;
  /** @deprecated Use `errors` field instead. */
  readonly translationErrors: ReadonlyArray<TranslationError>;
};

export type AttributeTranslateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

/** Represents attribute translations. */
export type AttributeTranslation = Node & {
  /** The ID of the attribute translation. */
  readonly id: Scalars['ID']['output'];
  /** Translation language. */
  readonly language: LanguageDisplay;
  /** Translated attribute name. */
  readonly name: Scalars['String']['output'];
  /** Represents the attribute fields to translate. */
  readonly translatableContent?: Maybe<AttributeTranslatableContent>;
};

export type AttributeTypeEnum =
  | 'PAGE_TYPE'
  | 'PRODUCT_TYPE';

export type AttributeTypeEnumFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<AttributeTypeEnum>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<AttributeTypeEnum>>;
};

/**
 * Updates attribute.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_UPDATED (async): An attribute was updated.
 */
export type AttributeUpdate = {
  /** The updated attribute. */
  readonly attribute?: Maybe<Attribute>;
  /** @deprecated Use `errors` field instead. */
  readonly attributeErrors: ReadonlyArray<AttributeError>;
  readonly errors: ReadonlyArray<AttributeError>;
};

/**
 * Represents an input for update of attribute.
 *
 * NOTE: Deprecated fields `filterableInStorefront`, `storefrontSearchPosition` and `availableInGrid` are not supported in bulk mutations: `attributeBulkCreate`, `attributeBulkUpdate`.
 */
export type AttributeUpdateInput = {
  /** New values to be created for this attribute. */
  readonly addValues?: InputMaybe<ReadonlyArray<AttributeValueUpdateInput>>;
  /**
   * Whether the attribute can be displayed in the admin product list.
   * @deprecated Field no longer supported
   */
  readonly availableInGrid?: InputMaybe<Scalars['Boolean']['input']>;
  /** External ID of this product. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** Whether the attribute can be filtered in dashboard. */
  readonly filterableInDashboard?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether the attribute can be filtered in storefront.
   * @deprecated Field no longer supported
   */
  readonly filterableInStorefront?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the attribute is for variants only. */
  readonly isVariantOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of an attribute displayed in the interface. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Specifies reference types to narrow down the choices of reference objects. Applicable only for `REFERENCE` and `SINGLE_REFERENCE` attributes with `PRODUCT`, `PRODUCT_VARIANT` and `PAGE` entity types. Accepts `ProductType` IDs for `PRODUCT` and `PRODUCT_VARIANT` entity types, and `PageType` IDs for `PAGE` entity type. If omitted, all objects of the selected entity type are available as attribute values.
   *
   * A maximum of 100 reference types can be specified.
   *
   * Added in Saleor 3.22.
   */
  readonly referenceTypes?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** IDs of values to be removed from this attribute. */
  readonly removeValues?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Internal representation of an attribute name. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
  /**
   * The position of the attribute in the storefront navigation (0 by default).
   * @deprecated Field no longer supported
   */
  readonly storefrontSearchPosition?: InputMaybe<Scalars['Int']['input']>;
  /** The unit of attribute values. */
  readonly unit?: InputMaybe<MeasurementUnitsEnum>;
  /** Whether the attribute requires values to be passed or not. */
  readonly valueRequired?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the attribute should be visible or not in storefront. */
  readonly visibleInStorefront?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Event sent when attribute is updated. */
export type AttributeUpdated = Event & {
  /** The attribute the event relates to. */
  readonly attribute?: Maybe<Attribute>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Represents a value of an attribute. */
export type AttributeValue = Node & {
  /** Represents the boolean value of the attribute value. */
  readonly boolean?: Maybe<Scalars['Boolean']['output']>;
  /** Represents the date value of the attribute value. */
  readonly date?: Maybe<Scalars['Date']['output']>;
  /** Represents the date/time value of the attribute value. */
  readonly dateTime?: Maybe<Scalars['DateTime']['output']>;
  /** External ID of this attribute value. */
  readonly externalReference?: Maybe<Scalars['String']['output']>;
  /** Represents file URL and content type (if attribute value is a file). */
  readonly file?: Maybe<File>;
  /** The ID of the attribute value. */
  readonly id: Scalars['ID']['output'];
  /** The input type to use for entering attribute values in the dashboard. */
  readonly inputType?: Maybe<AttributeInputTypeEnum>;
  /** Name of a value displayed in the interface. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Represents the text of the attribute value, plain text without formatting. */
  readonly plainText?: Maybe<Scalars['String']['output']>;
  /** The ID of the referenced object. */
  readonly reference?: Maybe<Scalars['ID']['output']>;
  /**
   * Represents the text of the attribute value, includes formatting.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly richText?: Maybe<Scalars['JSONString']['output']>;
  /** Internal representation of a value (unique per attribute). */
  readonly slug?: Maybe<Scalars['String']['output']>;
  /** Returns translated attribute value fields for the given language code. */
  readonly translation?: Maybe<AttributeValueTranslation>;
  /** Represent value of the attribute value (e.g. color values for swatch attributes). */
  readonly value?: Maybe<Scalars['String']['output']>;
};


/** Represents a value of an attribute. */
export type AttributeValueTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Deletes values of attributes.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_VALUE_DELETED (async): An attribute value was deleted.
 * - ATTRIBUTE_UPDATED (async): An attribute was updated.
 */
export type AttributeValueBulkDelete = {
  /** @deprecated Use `errors` field instead. */
  readonly attributeErrors: ReadonlyArray<AttributeError>;
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<AttributeError>;
};

/**
 * Creates/updates translations for attribute values.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type AttributeValueBulkTranslate = {
  /** Returns how many translations were created/updated. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<AttributeValueBulkTranslateError>;
  /** List of the translations. */
  readonly results: ReadonlyArray<AttributeValueBulkTranslateResult>;
};

export type AttributeValueBulkTranslateError = {
  /** The error code. */
  readonly code: AttributeValueTranslateErrorCode;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly path?: Maybe<Scalars['String']['output']>;
};

export type AttributeValueBulkTranslateInput = {
  /** External reference of an attribute value. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** Attribute value ID. */
  readonly id?: InputMaybe<Scalars['ID']['input']>;
  /** Translation language code. */
  readonly languageCode: LanguageCodeEnum;
  /** Translation fields. */
  readonly translationFields: AttributeValueTranslationInput;
};

export type AttributeValueBulkTranslateResult = {
  /** List of errors occurred on translation attempt. */
  readonly errors?: Maybe<ReadonlyArray<AttributeValueBulkTranslateError>>;
  /** Attribute value translation data. */
  readonly translation?: Maybe<AttributeValueTranslation>;
};

export type AttributeValueCountableConnection = {
  readonly edges: ReadonlyArray<AttributeValueCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type AttributeValueCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: AttributeValue;
};

/**
 * Creates a value for an attribute.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_VALUE_CREATED (async): An attribute value was created.
 * - ATTRIBUTE_UPDATED (async): An attribute was updated.
 */
export type AttributeValueCreate = {
  /** The updated attribute. */
  readonly attribute?: Maybe<Attribute>;
  /** @deprecated Use `errors` field instead. */
  readonly attributeErrors: ReadonlyArray<AttributeError>;
  readonly attributeValue?: Maybe<AttributeValue>;
  readonly errors: ReadonlyArray<AttributeError>;
};

export type AttributeValueCreateInput = {
  /** File content type. */
  readonly contentType?: InputMaybe<Scalars['String']['input']>;
  /** External ID of this attribute value. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** URL of the file attribute. Every time, a new value is created. */
  readonly fileUrl?: InputMaybe<Scalars['String']['input']>;
  /** Name of a value displayed in the interface. */
  readonly name: Scalars['String']['input'];
  /**
   * Represents the text of the attribute value, plain text without formatting.
   * @deprecated The plain text attribute hasn't got predefined value, so can be specified only from instance that supports the given attribute.
   */
  readonly plainText?: InputMaybe<Scalars['String']['input']>;
  /**
   * Represents the text of the attribute value, includes formatting.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated The rich text attribute hasn't got predefined value, so can be specified only from instance that supports the given attribute.
   */
  readonly richText?: InputMaybe<Scalars['JSONString']['input']>;
  /** Represent value of the attribute value (e.g. color values for swatch attributes). */
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when new attribute value is created. */
export type AttributeValueCreated = Event & {
  /** The attribute value the event relates to. */
  readonly attributeValue?: Maybe<AttributeValue>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Deletes a value of an attribute.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_VALUE_DELETED (async): An attribute value was deleted.
 * - ATTRIBUTE_UPDATED (async): An attribute was updated.
 */
export type AttributeValueDelete = {
  /** The updated attribute. */
  readonly attribute?: Maybe<Attribute>;
  /** @deprecated Use `errors` field instead. */
  readonly attributeErrors: ReadonlyArray<AttributeError>;
  readonly attributeValue?: Maybe<AttributeValue>;
  readonly errors: ReadonlyArray<AttributeError>;
};

/** Event sent when attribute value is deleted. */
export type AttributeValueDeleted = Event & {
  /** The attribute value the event relates to. */
  readonly attributeValue?: Maybe<AttributeValue>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type AttributeValueFilterInput = {
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly slugs?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

export type AttributeValueInput = {
  /** Represents the boolean value of the attribute value. */
  readonly boolean?: InputMaybe<Scalars['Boolean']['input']>;
  /** File content type. */
  readonly contentType?: InputMaybe<Scalars['String']['input']>;
  /** Represents the date value of the attribute value. */
  readonly date?: InputMaybe<Scalars['Date']['input']>;
  /** Represents the date/time value of the attribute value. */
  readonly dateTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** Attribute value ID or external reference. */
  readonly dropdown?: InputMaybe<AttributeValueSelectableTypeInput>;
  /** External ID of this attribute. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** URL of the file attribute. Every time, a new value is created. */
  readonly file?: InputMaybe<Scalars['String']['input']>;
  /** ID of the selected attribute. */
  readonly id?: InputMaybe<Scalars['ID']['input']>;
  /** List of attribute value IDs or external references. */
  readonly multiselect?: InputMaybe<ReadonlyArray<AttributeValueSelectableTypeInput>>;
  /** Numeric value of an attribute. */
  readonly numeric?: InputMaybe<Scalars['String']['input']>;
  /** Plain text content. */
  readonly plainText?: InputMaybe<Scalars['String']['input']>;
  /**
   * ID of the referenced entity for single reference attribute.
   *
   * Added in Saleor 3.22.
   */
  readonly reference?: InputMaybe<Scalars['ID']['input']>;
  /** List of entity IDs that will be used as references. */
  readonly references?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Text content in JSON format. */
  readonly richText?: InputMaybe<Scalars['JSONString']['input']>;
  /** Attribute value ID or external reference. */
  readonly swatch?: InputMaybe<AttributeValueSelectableTypeInput>;
  /**
   * The value or slug of an attribute to resolve. If the passed value is non-existent, it will be created.
   * @deprecated Field no longer supported
   */
  readonly values?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/**
 * Represents attribute value.
 * 1. If ID is provided, then attribute value will be resolved by ID.
 * 2. If externalReference is provided, then attribute value will be resolved by external reference.
 * 3. If value is provided, then attribute value will be resolved by value. If this attribute value doesn't exist, then it will be created.
 * 4. If externalReference and value is provided then new attribute value will be created.
 */
export type AttributeValueSelectableTypeInput = {
  /** External reference of an attribute value. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** ID of an attribute value. */
  readonly id?: InputMaybe<Scalars['ID']['input']>;
  /** The value or slug of an attribute to resolve. If the passed value is non-existent, it will be created. */
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

/** Represents attribute value's original translatable fields and related translations. */
export type AttributeValueTranslatableContent = Node & {
  /** Associated attribute that can be translated. */
  readonly attribute?: Maybe<AttributeTranslatableContent>;
  /**
   * Represents a value of an attribute.
   * @deprecated Get model fields from the root level queries.
   */
  readonly attributeValue?: Maybe<AttributeValue>;
  /** The ID of the attribute value to translate. */
  readonly attributeValueId: Scalars['ID']['output'];
  /** The ID of the attribute value translatable content. */
  readonly id: Scalars['ID']['output'];
  /** Name of the attribute value to translate. */
  readonly name: Scalars['String']['output'];
  /** Attribute plain text value. */
  readonly plainText?: Maybe<Scalars['String']['output']>;
  /**
   * Attribute value.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly richText?: Maybe<Scalars['JSONString']['output']>;
  /** Returns translated attribute value fields for the given language code. */
  readonly translation?: Maybe<AttributeValueTranslation>;
};


/** Represents attribute value's original translatable fields and related translations. */
export type AttributeValueTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for an attribute value.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type AttributeValueTranslate = {
  readonly attributeValue?: Maybe<AttributeValue>;
  readonly errors: ReadonlyArray<TranslationError>;
  /** @deprecated Use `errors` field instead. */
  readonly translationErrors: ReadonlyArray<TranslationError>;
};

export type AttributeValueTranslateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

/** Represents attribute value translations. */
export type AttributeValueTranslation = Node & {
  /** The ID of the attribute value translation. */
  readonly id: Scalars['ID']['output'];
  /** Translation language. */
  readonly language: LanguageDisplay;
  /** Translated attribute value name. */
  readonly name: Scalars['String']['output'];
  /** Translated plain text attribute value . */
  readonly plainText?: Maybe<Scalars['String']['output']>;
  /**
   * Translated rich-text attribute value.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly richText?: Maybe<Scalars['JSONString']['output']>;
  /** Represents the attribute value fields to translate. */
  readonly translatableContent?: Maybe<AttributeValueTranslatableContent>;
};

export type AttributeValueTranslationInput = {
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Translated text. */
  readonly plainText?: InputMaybe<Scalars['String']['input']>;
  /**
   * Translated text.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly richText?: InputMaybe<Scalars['JSONString']['input']>;
};

/**
 * Updates value of an attribute.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 *
 * Triggers the following webhook events:
 * - ATTRIBUTE_VALUE_UPDATED (async): An attribute value was updated.
 * - ATTRIBUTE_UPDATED (async): An attribute was updated.
 */
export type AttributeValueUpdate = {
  /** The updated attribute. */
  readonly attribute?: Maybe<Attribute>;
  /** @deprecated Use `errors` field instead. */
  readonly attributeErrors: ReadonlyArray<AttributeError>;
  readonly attributeValue?: Maybe<AttributeValue>;
  readonly errors: ReadonlyArray<AttributeError>;
};

export type AttributeValueUpdateInput = {
  /** File content type. */
  readonly contentType?: InputMaybe<Scalars['String']['input']>;
  /** External ID of this attribute value. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** URL of the file attribute. Every time, a new value is created. */
  readonly fileUrl?: InputMaybe<Scalars['String']['input']>;
  /** Name of a value displayed in the interface. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Represents the text of the attribute value, plain text without formatting.
   * @deprecated The plain text attribute hasn't got predefined value, so can be specified only from instance that supports the given attribute.
   */
  readonly plainText?: InputMaybe<Scalars['String']['input']>;
  /**
   * Represents the text of the attribute value, includes formatting.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated The rich text attribute hasn't got predefined value, so can be specified only from instance that supports the given attribute.
   */
  readonly richText?: InputMaybe<Scalars['JSONString']['input']>;
  /** Represent value of the attribute value (e.g. color values for swatch attributes). */
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when attribute value is updated. */
export type AttributeValueUpdated = Event & {
  /** The attribute value the event relates to. */
  readonly attributeValue?: Maybe<AttributeValue>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Where filtering options for attribute values. */
export type AttributeValueWhereInput = {
  /** List of conditions that must be met. */
  readonly AND?: InputMaybe<ReadonlyArray<AttributeValueWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  readonly OR?: InputMaybe<ReadonlyArray<AttributeValueWhereInput>>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly name?: InputMaybe<StringFilterInput>;
  readonly slug?: InputMaybe<StringFilterInput>;
};

/** Where filtering options. */
export type AttributeWhereInput = {
  /** List of conditions that must be met. */
  readonly AND?: InputMaybe<ReadonlyArray<AttributeWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  readonly OR?: InputMaybe<ReadonlyArray<AttributeWhereInput>>;
  readonly entityType?: InputMaybe<AttributeEntityTypeEnumFilterInput>;
  readonly filterableInDashboard?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly inCategory?: InputMaybe<Scalars['ID']['input']>;
  readonly inCollection?: InputMaybe<Scalars['ID']['input']>;
  readonly inputType?: InputMaybe<AttributeInputTypeEnumFilterInput>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly name?: InputMaybe<StringFilterInput>;
  readonly slug?: InputMaybe<StringFilterInput>;
  readonly type?: InputMaybe<AttributeTypeEnumFilterInput>;
  readonly unit?: InputMaybe<MeasurementUnitsEnumFilterInput>;
  readonly valueRequired?: InputMaybe<Scalars['Boolean']['input']>;
  readonly visibleInStorefront?: InputMaybe<Scalars['Boolean']['input']>;
  readonly withChoices?: InputMaybe<Scalars['Boolean']['input']>;
};

export type BulkAttributeValueInput = {
  /** The boolean value of an attribute to resolve. If the passed value is non-existent, it will be created. */
  readonly boolean?: InputMaybe<Scalars['Boolean']['input']>;
  /** File content type. */
  readonly contentType?: InputMaybe<Scalars['String']['input']>;
  /** Represents the date value of the attribute value. */
  readonly date?: InputMaybe<Scalars['Date']['input']>;
  /** Represents the date/time value of the attribute value. */
  readonly dateTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** Attribute value ID. */
  readonly dropdown?: InputMaybe<AttributeValueSelectableTypeInput>;
  /** External ID of this attribute. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** URL of the file attribute. Every time, a new value is created. */
  readonly file?: InputMaybe<Scalars['String']['input']>;
  /** ID of the selected attribute. */
  readonly id?: InputMaybe<Scalars['ID']['input']>;
  /** List of attribute value IDs. */
  readonly multiselect?: InputMaybe<ReadonlyArray<AttributeValueSelectableTypeInput>>;
  /** Numeric value of an attribute. */
  readonly numeric?: InputMaybe<Scalars['String']['input']>;
  /** Plain text content. */
  readonly plainText?: InputMaybe<Scalars['String']['input']>;
  /**
   * ID of the referenced entity for single reference attribute.
   *
   * Added in Saleor 3.22.
   */
  readonly reference?: InputMaybe<Scalars['ID']['input']>;
  /** List of entity IDs that will be used as references. */
  readonly references?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Text content in JSON format. */
  readonly richText?: InputMaybe<Scalars['JSONString']['input']>;
  /** Attribute value ID. */
  readonly swatch?: InputMaybe<AttributeValueSelectableTypeInput>;
  /**
   * The value or slug of an attribute to resolve. If the passed value is non-existent, it will be created.
   * @deprecated Field no longer supported
   */
  readonly values?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

export type BulkProductError = {
  /** List of attributes IDs which causes the error. */
  readonly attributes?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** List of channel IDs which causes the error. */
  readonly channels?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error code. */
  readonly code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** Index of an input list item that caused the error. */
  readonly index?: Maybe<Scalars['Int']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of attribute values IDs which causes the error. */
  readonly values?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** List of warehouse IDs which causes the error. */
  readonly warehouses?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

export type BulkStockError = {
  /** List of attributes IDs which causes the error. */
  readonly attributes?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error code. */
  readonly code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** Index of an input list item that caused the error. */
  readonly index?: Maybe<Scalars['Int']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of attribute values IDs which causes the error. */
  readonly values?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

/** Synchronous webhook for calculating checkout/order taxes. */
export type CalculateTaxes = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  readonly taxBase: TaxableObject;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type CardInput = {
  /** Payment method nonce, a token returned by the appropriate provider's SDK. */
  readonly code: Scalars['String']['input'];
  /** Card security code. */
  readonly cvc?: InputMaybe<Scalars['String']['input']>;
  /** Information about currency and amount. */
  readonly money: MoneyInput;
};

/**
 * Represents a card payment method used for a transaction.
 *
 * Added in Saleor 3.22.
 */
export type CardPaymentMethodDetails = PaymentMethodDetails & {
  /** Card brand. */
  readonly brand?: Maybe<Scalars['String']['output']>;
  /** Two-digit number representing the cards expiration month. */
  readonly expMonth?: Maybe<Scalars['Int']['output']>;
  /** Four-digit number representing the cards expiration year. */
  readonly expYear?: Maybe<Scalars['Int']['output']>;
  /** First 4 digits of the card number. */
  readonly firstDigits?: Maybe<Scalars['String']['output']>;
  /** Last 4 digits of the card number. */
  readonly lastDigits?: Maybe<Scalars['String']['output']>;
  /** Name of the payment method. */
  readonly name: Scalars['String']['output'];
};

export type CardPaymentMethodDetailsInput = {
  /** Brand of the payment method used for the transaction. Max length is 40 characters. */
  readonly brand?: InputMaybe<Scalars['String']['input']>;
  /** Expiration month of the card used for the transaction. Value must be between 1 and 12. */
  readonly expMonth?: InputMaybe<Scalars['Int']['input']>;
  /** Expiration year of the card used for the transaction. Value must be between 2000 and 9999. */
  readonly expYear?: InputMaybe<Scalars['Int']['input']>;
  /** First digits of the card used for the transaction. Max length is 4 characters. */
  readonly firstDigits?: InputMaybe<Scalars['String']['input']>;
  /** Last digits of the card used for the transaction. Max length is 4 characters. */
  readonly lastDigits?: InputMaybe<Scalars['String']['input']>;
  /** Name of the payment method used for the transaction. Max length is 256 characters. */
  readonly name: Scalars['String']['input'];
};

export type CatalogueInput = {
  /** Categories related to the discount. */
  readonly categories?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Collections related to the discount. */
  readonly collections?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Products related to the discount. */
  readonly products?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Product variant related to the discount. */
  readonly variants?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

export type CataloguePredicateInput = {
  /** List of conditions that must be met. */
  readonly AND?: InputMaybe<ReadonlyArray<CataloguePredicateInput>>;
  /** A list of conditions of which at least one must be met. */
  readonly OR?: InputMaybe<ReadonlyArray<CataloguePredicateInput>>;
  /** Defines the category conditions to be met. */
  readonly categoryPredicate?: InputMaybe<CategoryWhereInput>;
  /** Defines the collection conditions to be met. */
  readonly collectionPredicate?: InputMaybe<CollectionWhereInput>;
  /** Defines the product conditions to be met. */
  readonly productPredicate?: InputMaybe<ProductWhereInput>;
  /** Defines the product variant conditions to be met. */
  readonly variantPredicate?: InputMaybe<ProductVariantWhereInput>;
};

/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type Category = Node & ObjectWithMetadata & {
  /** List of ancestors of the category. */
  readonly ancestors?: Maybe<CategoryCountableConnection>;
  /** Background image of the category. */
  readonly backgroundImage?: Maybe<Image>;
  /** List of children of the category. */
  readonly children?: Maybe<CategoryCountableConnection>;
  /**
   * Description of the category.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /**
   * Description of the category.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  readonly descriptionJson?: Maybe<Scalars['JSONString']['output']>;
  /** The ID of the category. */
  readonly id: Scalars['ID']['output'];
  /** Level of the category. */
  readonly level: Scalars['Int']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Name of category */
  readonly name: Scalars['String']['output'];
  /** Parent category. */
  readonly parent?: Maybe<Category>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** List of products in the category. Requires the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  readonly products?: Maybe<ProductCountableConnection>;
  /** SEO description of category. */
  readonly seoDescription?: Maybe<Scalars['String']['output']>;
  /** SEO title of category. */
  readonly seoTitle?: Maybe<Scalars['String']['output']>;
  /** Slug of the category. */
  readonly slug: Scalars['String']['output'];
  /** Returns translated category fields for the given language code. */
  readonly translation?: Maybe<CategoryTranslation>;
  /** The date and time when the category was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryAncestorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryBackgroundImageArgs = {
  format?: InputMaybe<ThumbnailFormatEnum>;
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryChildrenArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ProductFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<ProductOrder>;
  where?: InputMaybe<ProductWhereInput>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Deletes categories.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CategoryBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

export type CategoryCountableConnection = {
  readonly edges: ReadonlyArray<CategoryCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type CategoryCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Category;
};

/**
 * Creates a new category.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CategoryCreate = {
  readonly category?: Maybe<Category>;
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

/** Event sent when new category is created. */
export type CategoryCreated = Event & {
  /** The category the event relates to. */
  readonly category?: Maybe<Category>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Deletes a category.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CategoryDelete = {
  readonly category?: Maybe<Category>;
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

/** Event sent when category is deleted. */
export type CategoryDeleted = Event & {
  /** The category the event relates to. */
  readonly category?: Maybe<Category>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type CategoryFilterInput = {
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly slugs?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** Filter by when was the most recent update. */
  readonly updatedAt?: InputMaybe<DateTimeRangeInput>;
};

export type CategoryInput = {
  /** Background image file. */
  readonly backgroundImage?: InputMaybe<Scalars['Upload']['input']>;
  /** Alt text for a product media. */
  readonly backgroundImageAlt?: InputMaybe<Scalars['String']['input']>;
  /**
   * Category description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: InputMaybe<Scalars['JSONString']['input']>;
  /**
   * Fields required to update the category metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Category name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the category private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Search engine optimization fields. */
  readonly seo?: InputMaybe<SeoInput>;
  /** Category slug. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
};

export type CategorySortField =
  /** Sort categories by name. */
  | 'NAME'
  /** Sort categories by product count. */
  | 'PRODUCT_COUNT'
  /** Sort categories by subcategory count. */
  | 'SUBCATEGORY_COUNT';

export type CategorySortingInput = {
  /**
   * Specifies the channel in which to sort the data.
   * @deprecated Use root-level channel argument instead.
   */
  readonly channel?: InputMaybe<Scalars['String']['input']>;
  /** Specifies the direction in which to sort categories. */
  readonly direction: OrderDirection;
  /** Sort categories by the selected field. */
  readonly field: CategorySortField;
};

/** Represents category original translatable fields and related translations. */
export type CategoryTranslatableContent = Node & {
  /**
   * Represents a single category of products.
   * @deprecated Get model fields from the root level queries.
   */
  readonly category?: Maybe<Category>;
  /** The ID of the category to translate. */
  readonly categoryId: Scalars['ID']['output'];
  /**
   * Category description to translate.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /**
   * Description of the category.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  readonly descriptionJson?: Maybe<Scalars['JSONString']['output']>;
  /** The ID of the category translatable content. */
  readonly id: Scalars['ID']['output'];
  /** Name of the category translatable content. */
  readonly name: Scalars['String']['output'];
  /** SEO description to translate. */
  readonly seoDescription?: Maybe<Scalars['String']['output']>;
  /** SEO title to translate. */
  readonly seoTitle?: Maybe<Scalars['String']['output']>;
  /**
   * Slug to translate.
   *
   * Added in Saleor 3.21.
   */
  readonly slug?: Maybe<Scalars['String']['output']>;
  /** Returns translated category fields for the given language code. */
  readonly translation?: Maybe<CategoryTranslation>;
};


/** Represents category original translatable fields and related translations. */
export type CategoryTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a category.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type CategoryTranslate = {
  readonly category?: Maybe<Category>;
  readonly errors: ReadonlyArray<TranslationError>;
  /** @deprecated Use `errors` field instead. */
  readonly translationErrors: ReadonlyArray<TranslationError>;
};

/** Represents category translations. */
export type CategoryTranslation = Node & {
  /**
   * Translated description of the category.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /**
   * Translated description of the category.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  readonly descriptionJson?: Maybe<Scalars['JSONString']['output']>;
  /** The ID of the category translation. */
  readonly id: Scalars['ID']['output'];
  /** Translation language. */
  readonly language: LanguageDisplay;
  /** Translated category name. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Translated SEO description. */
  readonly seoDescription?: Maybe<Scalars['String']['output']>;
  /** Translated SEO title. */
  readonly seoTitle?: Maybe<Scalars['String']['output']>;
  /**
   * Translated category slug.
   *
   * Added in Saleor 3.21.
   */
  readonly slug?: Maybe<Scalars['String']['output']>;
  /** Represents the category fields to translate. */
  readonly translatableContent?: Maybe<CategoryTranslatableContent>;
};

/**
 * Updates a category.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CategoryUpdate = {
  readonly category?: Maybe<Category>;
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

/** Event sent when category is updated. */
export type CategoryUpdated = Event & {
  /** The category the event relates to. */
  readonly category?: Maybe<Category>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type CategoryWhereInput = {
  /** List of conditions that must be met. */
  readonly AND?: InputMaybe<ReadonlyArray<CategoryWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  readonly OR?: InputMaybe<ReadonlyArray<CategoryWhereInput>>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
};

/** Represents channel. */
export type Channel = Node & ObjectWithMetadata & {
  /** Shipping methods that are available for the channel. */
  readonly availableShippingMethodsPerCountry?: Maybe<ReadonlyArray<ShippingMethodsPerCountry>>;
  /**
   * Channel-specific checkout settings.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS, MANAGE_CHECKOUTS.
   */
  readonly checkoutSettings: CheckoutSettings;
  /** List of shippable countries for the channel. */
  readonly countries?: Maybe<ReadonlyArray<CountryDisplay>>;
  /**
   * A currency that is assigned to the channel.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  readonly currencyCode: Scalars['String']['output'];
  /**
   * Default country for the channel. Default country can be used in checkout to determine the stock quantities or calculate taxes when the country was not explicitly provided.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  readonly defaultCountry: CountryDisplay;
  /**
   * Whether a channel has associated orders.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS.
   */
  readonly hasOrders: Scalars['Boolean']['output'];
  /** The ID of the channel. */
  readonly id: Scalars['ID']['output'];
  /**
   * Whether the channel is active.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  readonly isActive: Scalars['Boolean']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /**
   * Name of the channel.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  readonly name: Scalars['String']['output'];
  /**
   * Channel-specific order settings.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS, MANAGE_ORDERS.
   */
  readonly orderSettings: OrderSettings;
  /**
   * Channel-specific payment settings.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS, HANDLE_PAYMENTS.
   */
  readonly paymentSettings: PaymentSettings;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Slug of the channel. */
  readonly slug: Scalars['String']['output'];
  /**
   * Define the stock setting for this channel.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  readonly stockSettings: StockSettings;
  /**
   * Channel specific tax configuration.
   *
   * Added in Saleor 3.20.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly taxConfiguration: TaxConfiguration;
  /**
   * List of warehouses assigned to this channel.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  readonly warehouses: ReadonlyArray<Warehouse>;
};


/** Represents channel. */
export type ChannelAvailableShippingMethodsPerCountryArgs = {
  countries?: InputMaybe<ReadonlyArray<CountryCode>>;
};


/** Represents channel. */
export type ChannelMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents channel. */
export type ChannelMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents channel. */
export type ChannelPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents channel. */
export type ChannelPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/**
 * Activate a channel.
 *
 * Requires one of the following permissions: MANAGE_CHANNELS.
 *
 * Triggers the following webhook events:
 * - CHANNEL_STATUS_CHANGED (async): A channel was activated.
 */
export type ChannelActivate = {
  /** Activated channel. */
  readonly channel?: Maybe<Channel>;
  /** @deprecated Use `errors` field instead. */
  readonly channelErrors: ReadonlyArray<ChannelError>;
  readonly errors: ReadonlyArray<ChannelError>;
};

/**
 * Creates a new channel.
 *
 * Requires one of the following permissions: MANAGE_CHANNELS.
 *
 * Triggers the following webhook events:
 * - CHANNEL_CREATED (async): A channel was created.
 */
export type ChannelCreate = {
  readonly channel?: Maybe<Channel>;
  /** @deprecated Use `errors` field instead. */
  readonly channelErrors: ReadonlyArray<ChannelError>;
  readonly errors: ReadonlyArray<ChannelError>;
};

export type ChannelCreateInput = {
  /** List of shipping zones to assign to the channel. */
  readonly addShippingZones?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of warehouses to assign to the channel. */
  readonly addWarehouses?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The channel checkout settings */
  readonly checkoutSettings?: InputMaybe<CheckoutSettingsInput>;
  /** Currency of the channel. */
  readonly currencyCode: Scalars['String']['input'];
  /** Default country for the channel. Default country can be used in checkout to determine the stock quantities or calculate taxes when the country was not explicitly provided. */
  readonly defaultCountry: CountryCode;
  /** Determine if channel will be set active or not. */
  readonly isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Channel public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Name of the channel. */
  readonly name: Scalars['String']['input'];
  /** The channel order settings */
  readonly orderSettings?: InputMaybe<OrderSettingsInput>;
  /** The channel payment settings */
  readonly paymentSettings?: InputMaybe<PaymentSettingsInput>;
  /**
   * Channel private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Slug of the channel. */
  readonly slug: Scalars['String']['input'];
  /** The channel stock settings. */
  readonly stockSettings?: InputMaybe<StockSettingsInput>;
};

/** Event sent when new channel is created. */
export type ChannelCreated = Event & {
  /** The channel the event relates to. */
  readonly channel?: Maybe<Channel>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Deactivate a channel.
 *
 * Requires one of the following permissions: MANAGE_CHANNELS.
 *
 * Triggers the following webhook events:
 * - CHANNEL_STATUS_CHANGED (async): A channel was deactivated.
 */
export type ChannelDeactivate = {
  /** Deactivated channel. */
  readonly channel?: Maybe<Channel>;
  /** @deprecated Use `errors` field instead. */
  readonly channelErrors: ReadonlyArray<ChannelError>;
  readonly errors: ReadonlyArray<ChannelError>;
};

/**
 * Deletes a channel. Orders associated with the deleted channel will be moved to the target channel. Checkouts, product availability, and pricing will be removed.
 *
 * Requires one of the following permissions: MANAGE_CHANNELS.
 *
 * Triggers the following webhook events:
 * - CHANNEL_DELETED (async): A channel was deleted.
 */
export type ChannelDelete = {
  readonly channel?: Maybe<Channel>;
  /** @deprecated Use `errors` field instead. */
  readonly channelErrors: ReadonlyArray<ChannelError>;
  readonly errors: ReadonlyArray<ChannelError>;
};

export type ChannelDeleteInput = {
  /** ID of a channel to migrate orders from the origin channel. Target channel has to have the same currency as the origin. */
  readonly channelId: Scalars['ID']['input'];
};

/** Event sent when channel is deleted. */
export type ChannelDeleted = Event & {
  /** The channel the event relates to. */
  readonly channel?: Maybe<Channel>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type ChannelError = {
  /** The error code. */
  readonly code: ChannelErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of shipping zone IDs which causes the error. */
  readonly shippingZones?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** List of warehouses IDs which causes the error. */
  readonly warehouses?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

export type ChannelErrorCode =
  | 'ALREADY_EXISTS'
  | 'CHANNELS_CURRENCY_MUST_BE_THE_SAME'
  | 'CHANNEL_WITH_ORDERS'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type ChannelListingUpdateInput = {
  /** ID of a channel listing. */
  readonly channelListing: Scalars['ID']['input'];
  /** Cost price of the variant in channel. */
  readonly costPrice?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** The threshold for preorder variant in channel. */
  readonly preorderThreshold?: InputMaybe<Scalars['Int']['input']>;
  /** Price of the particular variant in channel. */
  readonly price?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** Price of the variant before discount. */
  readonly priorPrice?: InputMaybe<Scalars['PositiveDecimal']['input']>;
};

/** Event sent when channel metadata is updated. */
export type ChannelMetadataUpdated = Event & {
  /** The channel the event relates to. */
  readonly channel?: Maybe<Channel>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Reorder the warehouses of a channel.
 *
 * Requires one of the following permissions: MANAGE_CHANNELS.
 */
export type ChannelReorderWarehouses = {
  /** Channel within the warehouses are reordered. */
  readonly channel?: Maybe<Channel>;
  readonly errors: ReadonlyArray<ChannelError>;
};

/** Event sent when channel status has changed. */
export type ChannelStatusChanged = Event & {
  /** The channel the event relates to. */
  readonly channel?: Maybe<Channel>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Update a channel.
 *
 * Requires one of the following permissions: MANAGE_CHANNELS.
 * Requires one of the following permissions when updating only `orderSettings` field: `MANAGE_CHANNELS`, `MANAGE_ORDERS`.
 * Requires one of the following permissions when updating only `checkoutSettings` field: `MANAGE_CHANNELS`, `MANAGE_CHECKOUTS`.
 * Requires one of the following permissions when updating only `paymentSettings` field: `MANAGE_CHANNELS`, `HANDLE_PAYMENTS`.
 *
 * Triggers the following webhook events:
 * - CHANNEL_UPDATED (async): A channel was updated.
 * - CHANNEL_METADATA_UPDATED (async): Optionally triggered when public or private metadata is updated.
 */
export type ChannelUpdate = {
  readonly channel?: Maybe<Channel>;
  /** @deprecated Use `errors` field instead. */
  readonly channelErrors: ReadonlyArray<ChannelError>;
  readonly errors: ReadonlyArray<ChannelError>;
};

export type ChannelUpdateInput = {
  /** List of shipping zones to assign to the channel. */
  readonly addShippingZones?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of warehouses to assign to the channel. */
  readonly addWarehouses?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The channel checkout settings */
  readonly checkoutSettings?: InputMaybe<CheckoutSettingsInput>;
  /** Default country for the channel. Default country can be used in checkout to determine the stock quantities or calculate taxes when the country was not explicitly provided. */
  readonly defaultCountry?: InputMaybe<CountryCode>;
  /** Determine if channel will be set active or not. */
  readonly isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Channel public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Name of the channel. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** The channel order settings */
  readonly orderSettings?: InputMaybe<OrderSettingsInput>;
  /** The channel payment settings */
  readonly paymentSettings?: InputMaybe<PaymentSettingsInput>;
  /**
   * Channel private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** List of shipping zones to unassign from the channel. */
  readonly removeShippingZones?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of warehouses to unassign from the channel. */
  readonly removeWarehouses?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Slug of the channel. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
  /** The channel stock settings. */
  readonly stockSettings?: InputMaybe<StockSettingsInput>;
};

/** Event sent when channel is updated. */
export type ChannelUpdated = Event & {
  /** The channel the event relates to. */
  readonly channel?: Maybe<Channel>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Checkout object. */
export type Checkout = Node & ObjectWithMetadata & {
  /**
   * The authorize status of the checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  readonly authorizeStatus: CheckoutAuthorizeStatusEnum;
  /** Collection points that can be used for this order. */
  readonly availableCollectionPoints: ReadonlyArray<Warehouse>;
  /**
   * List of available payment gateways.
   *
   * Triggers the following webhook events:
   * - PAYMENT_LIST_GATEWAYS (sync): Fetch payment gateways available for checkout.
   */
  readonly availablePaymentGateways: ReadonlyArray<PaymentGateway>;
  /**
   * Shipping methods that can be used with this checkout.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
   * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
   * @deprecated Use `shippingMethods` instead.
   */
  readonly availableShippingMethods: ReadonlyArray<ShippingMethod>;
  /** The billing address of the checkout. */
  readonly billingAddress?: Maybe<Address>;
  /** The channel for which checkout was created. */
  readonly channel: Channel;
  /**
   * The charge status of the checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  readonly chargeStatus: CheckoutChargeStatusEnum;
  /** The date and time when the checkout was created. */
  readonly created: Scalars['DateTime']['output'];
  /**
   * The customer note for the checkout.
   *
   * Added in Saleor 3.21.
   */
  readonly customerNote: Scalars['String']['output'];
  /**
   * The delivery method selected for this checkout.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
   * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
   */
  readonly deliveryMethod?: Maybe<DeliveryMethod>;
  /** The total discount applied to the checkout. Note: Only discount created via voucher are included in this field. */
  readonly discount?: Maybe<Money>;
  /** The name of voucher assigned to the checkout. */
  readonly discountName?: Maybe<Scalars['String']['output']>;
  /** Determines whether displayed prices should include taxes. */
  readonly displayGrossPrices: Scalars['Boolean']['output'];
  /** Email of a customer. */
  readonly email?: Maybe<Scalars['String']['output']>;
  /** List of gift cards associated with this checkout. */
  readonly giftCards: ReadonlyArray<GiftCard>;
  /** The ID of the checkout. */
  readonly id: Scalars['ID']['output'];
  /** Returns True, if checkout requires shipping. */
  readonly isShippingRequired: Scalars['Boolean']['output'];
  /** Checkout language code. */
  readonly languageCode: LanguageCodeEnum;
  /** @deprecated Use `updatedAt` instead. */
  readonly lastChange: Scalars['DateTime']['output'];
  /** A list of checkout lines, each containing information about an item in the checkout. */
  readonly lines: ReadonlyArray<CheckoutLine>;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /**
   * The note for the checkout.
   * @deprecated Use `customerNote` instead.
   */
  readonly note: Scalars['String']['output'];
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** List of problems with the checkout. */
  readonly problems?: Maybe<ReadonlyArray<CheckoutProblem>>;
  /** The number of items purchased. */
  readonly quantity: Scalars['Int']['output'];
  /** The shipping address of the checkout. */
  readonly shippingAddress?: Maybe<Address>;
  /**
   * The shipping method related with checkout.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
   * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
   * @deprecated Use `deliveryMethod` instead.
   */
  readonly shippingMethod?: Maybe<ShippingMethod>;
  /**
   * Shipping methods that can be used with this checkout.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
   * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
   */
  readonly shippingMethods: ReadonlyArray<ShippingMethod>;
  /**
   * The price of the shipping, with all the taxes included. Set to 0 when no delivery method is selected.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  readonly shippingPrice: TaxedMoney;
  /** Date when oldest stock reservation for this checkout expires or null if no stock is reserved. */
  readonly stockReservationExpires?: Maybe<Scalars['DateTime']['output']>;
  /** List of user's stored payment methods that can be used in this checkout session. It uses the channel that the checkout was created in. When `amount` is not provided, `checkout.total` will be used as a default value. */
  readonly storedPaymentMethods?: Maybe<ReadonlyArray<StoredPaymentMethod>>;
  /**
   * The price of the checkout before shipping, with taxes included.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  readonly subtotalPrice: TaxedMoney;
  /** Returns True if checkout has to be exempt from taxes. */
  readonly taxExemption: Scalars['Boolean']['output'];
  /** The checkout's token. */
  readonly token: Scalars['UUID']['output'];
  /**
   * The difference between the paid and the checkout total amount.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  readonly totalBalance: Money;
  /**
   * The sum of the checkout line prices, with all the taxes,shipping costs, and discounts included.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  readonly totalPrice: TaxedMoney;
  /** List of transactions for the checkout. Requires one of the following permissions: MANAGE_CHECKOUTS, HANDLE_PAYMENTS. */
  readonly transactions?: Maybe<ReadonlyArray<TransactionItem>>;
  /** Translation of the discountName field in the language set in Checkout.languageCode field.Note: this field is set automatically when Checkout.languageCode is defined; otherwise it's null */
  readonly translatedDiscountName?: Maybe<Scalars['String']['output']>;
  /** Time of last modification of the given checkout. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The user assigned to the checkout. Requires one of the following permissions: MANAGE_USERS, HANDLE_PAYMENTS, OWNER. */
  readonly user?: Maybe<User>;
  /**
   * The voucher assigned to the checkout.
   *
   * Added in Saleor 3.18.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  readonly voucher?: Maybe<Voucher>;
  /** The code of voucher assigned to the checkout. */
  readonly voucherCode?: Maybe<Scalars['String']['output']>;
};


/** Checkout object. */
export type CheckoutMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Checkout object. */
export type CheckoutMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Checkout object. */
export type CheckoutPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Checkout object. */
export type CheckoutPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Checkout object. */
export type CheckoutStoredPaymentMethodsArgs = {
  amount?: InputMaybe<Scalars['PositiveDecimal']['input']>;
};

/**
 * Adds a gift card or a voucher to a checkout.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutAddPromoCode = {
  /** The checkout with the added gift card or voucher. */
  readonly checkout?: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

export type CheckoutAddressValidationRules = {
  /** Determines if an error should be raised when the provided address doesn't match the expected format. Example: using letters for postal code when the numbers are expected. */
  readonly checkFieldsFormat?: InputMaybe<Scalars['Boolean']['input']>;
  /** Determines if an error should be raised when the provided address doesn't have all the required fields. The list of required fields is dynamic and depends on the country code (use the `addressValidationRules` query to fetch them). Note: country code is mandatory for all addresses regardless of the rules provided in this input. */
  readonly checkRequiredFields?: InputMaybe<Scalars['Boolean']['input']>;
  /** Determines if Saleor should apply normalization on address fields. Example: converting city field to uppercase letters. */
  readonly enableFieldsNormalization?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * Determine a current authorize status for checkout.
 *
 *     We treat the checkout as fully authorized when the sum of authorized and charged
 *     funds cover the checkout.total.
 *     We treat the checkout as partially authorized when the sum of authorized and charged
 *     funds covers only part of the checkout.total
 *     We treat the checkout as not authorized when the sum of authorized and charged funds
 *     is 0.
 *
 *     NONE - the funds are not authorized
 *     PARTIAL - the cover funds don't cover fully the checkout's total
 *     FULL - the cover funds covers the checkout's total
 */
export type CheckoutAuthorizeStatusEnum =
  | 'FULL'
  | 'NONE'
  | 'PARTIAL';

/**
 * Updates billing address in the existing checkout.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutBillingAddressUpdate = {
  /** An updated checkout. */
  readonly checkout?: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

/**
 * Determine the current charge status for the checkout.
 *
 *     The checkout is considered overcharged when the sum of the transactionItem's charge
 *     amounts exceeds the value of `checkout.total`.
 *     If the sum of the transactionItem's charge amounts equals
 *     `checkout.total`, we consider the checkout to be fully charged.
 *     If the sum of the transactionItem's charge amounts covers a part of the
 *     `checkout.total`, we treat the checkout as partially charged.
 *
 *
 *     NONE - the funds are not charged.
 *     PARTIAL - the funds that are charged don't cover the checkout's total
 *     FULL - the funds that are charged fully cover the checkout's total
 *     OVERCHARGED - the charged funds are bigger than checkout's total
 */
export type CheckoutChargeStatusEnum =
  | 'FULL'
  | 'NONE'
  | 'OVERCHARGED'
  | 'PARTIAL';

/**
 * Completes the checkout. As a result a new order is created. The mutation allows to create the unpaid order when setting `orderSettings.allowUnpaidOrders` for given `Channel` is set to `true`. When `orderSettings.allowUnpaidOrders` is set to `false`, checkout can be completed only when attached `Payment`/`TransactionItem`s fully cover the checkout's total. When processing the checkout with `Payment`, in case of required additional confirmation step like 3D secure, the `confirmationNeeded` flag will be set to True and no order will be created until payment is confirmed with second call of this mutation.
 *
 * Triggers the following webhook events:
 * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
 * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
 * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
 * - ORDER_CREATED (async): Triggered when order is created.
 * - NOTIFY_USER (async): A notification for order placement.
 * - NOTIFY_USER (async): A staff notification for order placement.
 * - ORDER_UPDATED (async): Triggered when order received the update after placement.
 * - ORDER_PAID (async): Triggered when newly created order is paid.
 * - ORDER_FULLY_PAID (async): Triggered when newly created order is fully paid.
 * - ORDER_CONFIRMED (async): Optionally triggered when newly created order are automatically marked as confirmed.
 */
export type CheckoutComplete = {
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  /** Confirmation data used to process additional authorization steps. */
  readonly confirmationData?: Maybe<Scalars['JSONString']['output']>;
  /** Set to true if payment needs to be confirmed before checkout is complete. */
  readonly confirmationNeeded: Scalars['Boolean']['output'];
  readonly errors: ReadonlyArray<CheckoutError>;
  /** Placed order. */
  readonly order?: Maybe<Order>;
};

export type CheckoutCountableConnection = {
  readonly edges: ReadonlyArray<CheckoutCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type CheckoutCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Checkout;
};

/**
 * Create a new checkout.
 *
 * `skipValidation` field requires HANDLE_CHECKOUTS and AUTHENTICATED_APP permissions.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_CREATED (async): A checkout was created.
 */
export type CheckoutCreate = {
  readonly checkout?: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  /**
   * Whether the checkout was created or the current active one was returned. Refer to checkoutLinesAdd and checkoutLinesUpdate to merge a cart with an active checkout.
   * @deprecated Always returns `true`.
   */
  readonly created?: Maybe<Scalars['Boolean']['output']>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

/** Creates a new checkout from existing order. */
export type CheckoutCreateFromOrder = {
  /** Created checkout. */
  readonly checkout?: Maybe<Checkout>;
  readonly errors: ReadonlyArray<CheckoutCreateFromOrderError>;
  /** Variants that were not attached to the checkout. */
  readonly unavailableVariants?: Maybe<ReadonlyArray<CheckoutCreateFromOrderUnavailableVariant>>;
};

export type CheckoutCreateFromOrderError = {
  /** The error code. */
  readonly code: CheckoutCreateFromOrderErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type CheckoutCreateFromOrderErrorCode =
  | 'CHANNEL_INACTIVE'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'ORDER_NOT_FOUND'
  | 'TAX_ERROR';

export type CheckoutCreateFromOrderUnavailableVariant = {
  /** The error code. */
  readonly code: CheckoutCreateFromOrderUnavailableVariantErrorCode;
  /** Order line ID that is unavailable. */
  readonly lineId: Scalars['ID']['output'];
  /** The error message. */
  readonly message: Scalars['String']['output'];
  /** Variant ID that is unavailable. */
  readonly variantId: Scalars['ID']['output'];
};

export type CheckoutCreateFromOrderUnavailableVariantErrorCode =
  | 'INSUFFICIENT_STOCK'
  | 'NOT_FOUND'
  | 'PRODUCT_NOT_PUBLISHED'
  | 'PRODUCT_UNAVAILABLE_FOR_PURCHASE'
  | 'QUANTITY_GREATER_THAN_LIMIT'
  | 'UNAVAILABLE_VARIANT_IN_CHANNEL';

export type CheckoutCreateInput = {
  /** Billing address of the customer. `skipValidation` requires HANDLE_CHECKOUTS and AUTHENTICATED_APP permissions. */
  readonly billingAddress?: InputMaybe<AddressInput>;
  /** Slug of a channel in which to create a checkout. */
  readonly channel?: InputMaybe<Scalars['String']['input']>;
  /** The customer's email address. */
  readonly email?: InputMaybe<Scalars['String']['input']>;
  /** Checkout language code. */
  readonly languageCode?: InputMaybe<LanguageCodeEnum>;
  /** A list of checkout lines, each containing information about an item in the checkout. */
  readonly lines: ReadonlyArray<CheckoutLineInput>;
  /**
   * Checkout public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   *
   * Added in Saleor 3.21.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /**
   * Checkout private metadata. Requires one of the following permissions: MANAGE_CHECKOUTS, HANDLE_CHECKOUTS
   *
   * Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   *
   * Added in Saleor 3.21.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /**
   * Indicates whether the billing address should be saved to the users address book upon checkout completion. Can only be set when a billing address is provided. If not specified along with the address, the default behavior is to save the address.
   *
   * Added in Saleor 3.21.
   */
  readonly saveBillingAddress?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Indicates whether the shipping address should be saved to the users address book upon checkout completion.Can only be set when a shipping address is provided. If not specified along with the address, the default behavior is to save the address.
   *
   * Added in Saleor 3.21.
   */
  readonly saveShippingAddress?: InputMaybe<Scalars['Boolean']['input']>;
  /** The mailing address to where the checkout will be shipped. Note: the address will be ignored if the checkout doesn't contain shippable items. `skipValidation` requires HANDLE_CHECKOUTS and AUTHENTICATED_APP permissions. */
  readonly shippingAddress?: InputMaybe<AddressInput>;
  /** The checkout validation rules that can be changed. */
  readonly validationRules?: InputMaybe<CheckoutValidationRules>;
};

/** Event sent when new checkout is created. */
export type CheckoutCreated = Event & {
  /** The checkout the event relates to. */
  readonly checkout?: Maybe<Checkout>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Sets the customer as the owner of the checkout.
 *
 * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutCustomerAttach = {
  /** An updated checkout. */
  readonly checkout?: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

/**
 * Removes the user assigned as the owner of the checkout.
 *
 * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutCustomerDetach = {
  /** An updated checkout. */
  readonly checkout?: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

/**
 * Updates customer note in the existing checkout object.
 *
 * Added in Saleor 3.21.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutCustomerNoteUpdate = {
  /** An updated checkout. */
  readonly checkout?: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

/**
 * Updates the delivery method (shipping method or pick up point) of the checkout. Updates the checkout shipping_address for click and collect delivery for a warehouse address.
 *
 * Triggers the following webhook events:
 * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Triggered when updating the checkout delivery method with the external one.
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutDeliveryMethodUpdate = {
  /** An updated checkout. */
  readonly checkout?: Maybe<Checkout>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

/**
 * Updates email address in the existing checkout object.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutEmailUpdate = {
  /** An updated checkout. */
  readonly checkout?: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

export type CheckoutError = {
  /** A type of address that causes the error. */
  readonly addressType?: Maybe<AddressTypeEnum>;
  /** The error code. */
  readonly code: CheckoutErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** List of line Ids which cause the error. */
  readonly lines?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of variant IDs which causes the error. */
  readonly variants?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

export type CheckoutErrorCode =
  | 'BILLING_ADDRESS_NOT_SET'
  | 'CHANNEL_INACTIVE'
  | 'CHECKOUT_NOT_FULLY_PAID'
  | 'DELIVERY_METHOD_NOT_APPLICABLE'
  | 'EMAIL_NOT_SET'
  | 'GIFT_CARD_NOT_APPLICABLE'
  | 'GRAPHQL_ERROR'
  | 'INACTIVE_PAYMENT'
  | 'INSUFFICIENT_STOCK'
  | 'INVALID'
  | 'INVALID_SHIPPING_METHOD'
  | 'MISSING_ADDRESS_DATA'
  | 'MISSING_CHANNEL_SLUG'
  | 'NON_EDITABLE_GIFT_LINE'
  | 'NON_REMOVABLE_GIFT_LINE'
  | 'NOT_FOUND'
  | 'NO_LINES'
  | 'PAYMENT_ERROR'
  | 'PRODUCT_NOT_PUBLISHED'
  | 'PRODUCT_UNAVAILABLE_FOR_PURCHASE'
  | 'QUANTITY_GREATER_THAN_LIMIT'
  | 'REQUIRED'
  | 'SHIPPING_ADDRESS_NOT_SET'
  | 'SHIPPING_CHANGE_FORBIDDEN'
  | 'SHIPPING_METHOD_NOT_APPLICABLE'
  | 'SHIPPING_METHOD_NOT_SET'
  | 'SHIPPING_NOT_REQUIRED'
  | 'TAX_ERROR'
  | 'UNAVAILABLE_VARIANT_IN_CHANNEL'
  | 'UNIQUE'
  | 'VOUCHER_NOT_APPLICABLE'
  | 'ZERO_QUANTITY';

export type CheckoutFilterInput = {
  readonly authorizeStatus?: InputMaybe<ReadonlyArray<CheckoutAuthorizeStatusEnum>>;
  readonly channels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly chargeStatus?: InputMaybe<ReadonlyArray<CheckoutChargeStatusEnum>>;
  readonly created?: InputMaybe<DateRangeInput>;
  readonly customer?: InputMaybe<Scalars['String']['input']>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly updatedAt?: InputMaybe<DateRangeInput>;
};

/** Filter shipping methods for checkout. */
export type CheckoutFilterShippingMethods = Event & {
  /** The checkout the event relates to. */
  readonly checkout?: Maybe<Checkout>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Shipping methods that can be used with this checkout. */
  readonly shippingMethods?: Maybe<ReadonlyArray<ShippingMethod>>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Event sent when a checkout was fully authorized. A checkout is considered fully authorized when its `authorizeStatus` is `FULL`.
 *
 * It is triggered only for checkouts whose payments are processed through the Transaction API.
 */
export type CheckoutFullyAuthorized = Event & {
  /** The checkout the event relates to. */
  readonly checkout?: Maybe<Checkout>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Event sent when a checkout was fully paid. A checkout is considered fully paid when its `chargeStatus` is `FULL` or `OVERCHARGED`. This event is not sent if payments are only authorized but not fully charged.
 *
 * It is triggered only for checkouts whose payments are processed through the Transaction API.
 */
export type CheckoutFullyPaid = Event & {
  /** The checkout the event relates to. */
  readonly checkout?: Maybe<Checkout>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Updates language code in the existing checkout.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutLanguageCodeUpdate = {
  /** An updated checkout. */
  readonly checkout?: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

/** Represents an item in the checkout. */
export type CheckoutLine = Node & ObjectWithMetadata & {
  /** The ID of the checkout line. */
  readonly id: Scalars['ID']['output'];
  /**
   * Determine if the line is a gift.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly isGift?: Maybe<Scalars['Boolean']['output']>;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /**
   * The sum of the checkout line price prior to promotion.
   *
   * Added in Saleor 3.21.
   */
  readonly priorTotalPrice?: Maybe<Money>;
  /**
   * The unit price of the checkout line prior to promotion.
   *
   * Added in Saleor 3.21.
   */
  readonly priorUnitPrice?: Maybe<Money>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** List of problems with the checkout line. */
  readonly problems?: Maybe<ReadonlyArray<CheckoutLineProblem>>;
  /** The quantity of product variant assigned to the checkout line. */
  readonly quantity: Scalars['Int']['output'];
  /** Indicates whether the item need to be delivered. */
  readonly requiresShipping: Scalars['Boolean']['output'];
  /**
   * The sum of the checkout line price, taxes and discounts.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  readonly totalPrice: TaxedMoney;
  /** The sum of the checkout line price, without discounts. */
  readonly undiscountedTotalPrice: Money;
  /** The unit price of the checkout line, without discounts. */
  readonly undiscountedUnitPrice: Money;
  /**
   * The unit price of the checkout line, with taxes and discounts.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   */
  readonly unitPrice: TaxedMoney;
  /** The product variant from which the checkout line was created. */
  readonly variant: ProductVariant;
};


/** Represents an item in the checkout. */
export type CheckoutLineMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents an item in the checkout. */
export type CheckoutLineMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents an item in the checkout. */
export type CheckoutLinePrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents an item in the checkout. */
export type CheckoutLinePrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

export type CheckoutLineCountableConnection = {
  readonly edges: ReadonlyArray<CheckoutLineCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type CheckoutLineCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: CheckoutLine;
};

/**
 * Deletes a CheckoutLine.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutLineDelete = {
  /** An updated checkout. */
  readonly checkout?: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

export type CheckoutLineInput = {
  /** Flag that allow force splitting the same variant into multiple lines by skipping the matching logic. */
  readonly forceNewLine?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Fields required to update the object's metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Custom price of the item. Can be set only by apps with `HANDLE_CHECKOUTS` permission. When the line with the same variant will be provided multiple times, the last price will be used. */
  readonly price?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** The number of items purchased. */
  readonly quantity: Scalars['Int']['input'];
  /** ID of the product variant. */
  readonly variantId: Scalars['ID']['input'];
};

/** Represents an problem in the checkout line. */
export type CheckoutLineProblem = CheckoutLineProblemInsufficientStock | CheckoutLineProblemVariantNotAvailable;

/** Indicates insufficient stock for a given checkout line.Placing the order will not be possible until solving this problem. */
export type CheckoutLineProblemInsufficientStock = {
  /** Available quantity of a variant. */
  readonly availableQuantity?: Maybe<Scalars['Int']['output']>;
  /** The line that has variant with insufficient stock. */
  readonly line: CheckoutLine;
  /** The variant with insufficient stock. */
  readonly variant: ProductVariant;
};

/** The variant assigned to the checkout line is not available.Placing the order will not be possible until solving this problem. */
export type CheckoutLineProblemVariantNotAvailable = {
  /** The line that has variant that is not available. */
  readonly line: CheckoutLine;
};

export type CheckoutLineUpdateInput = {
  /** ID of the line. */
  readonly lineId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Checkout line public metadata. Will add and update keys. To delete keys use deleteMetadata mutation.
   *
   * Added in Saleor 3.21. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Custom price of the item. Can be set only by apps with `HANDLE_CHECKOUTS` permission. When the line with the same variant will be provided multiple times, the last price will be used. */
  readonly price?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** The number of items purchased. Optional for apps, required for any other users. */
  readonly quantity?: InputMaybe<Scalars['Int']['input']>;
  /**
   * ID of the product variant.
   * @deprecated Use `lineId` instead.
   */
  readonly variantId?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * Adds a checkout line to the existing checkout.If line was already in checkout, its quantity will be increased.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutLinesAdd = {
  /** An updated checkout. */
  readonly checkout?: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

/**
 * Deletes checkout lines.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutLinesDelete = {
  /** An updated checkout. */
  readonly checkout?: Maybe<Checkout>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

/**
 * Updates checkout line in the existing checkout.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutLinesUpdate = {
  /** An updated checkout. */
  readonly checkout?: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

/** Event sent when checkout metadata is updated. */
export type CheckoutMetadataUpdated = Event & {
  /** The checkout the event relates to. */
  readonly checkout?: Maybe<Checkout>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Creates a new payment for given checkout. */
export type CheckoutPaymentCreate = {
  /** Related checkout object. */
  readonly checkout?: Maybe<Checkout>;
  readonly errors: ReadonlyArray<PaymentError>;
  /** A newly created payment. */
  readonly payment?: Maybe<Payment>;
  /** @deprecated Use `errors` field instead. */
  readonly paymentErrors: ReadonlyArray<PaymentError>;
};

/** Represents an problem in the checkout. */
export type CheckoutProblem = CheckoutLineProblemInsufficientStock | CheckoutLineProblemVariantNotAvailable;

/**
 * Remove a gift card or a voucher from a checkout.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutRemovePromoCode = {
  /** The checkout with the removed gift card or voucher. */
  readonly checkout?: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

/** Represents the channel-specific checkout settings. */
export type CheckoutSettings = {
  /**
   * Default `false`. Determines if the paid checkouts should be automatically completed. This setting applies only to checkouts where payment was processed through transactions.When enabled, the checkout will be automatically completed once the checkout `charge_status` reaches `FULL`. This occurs when the total sum of charged and authorized transaction amounts equals or exceeds the checkout's total amount.
   *
   * Added in Saleor 3.20.
   */
  readonly automaticallyCompleteFullyPaidCheckouts: Scalars['Boolean']['output'];
  /** Default `true`. Determines if the checkout mutations should use legacy error flow. In legacy flow, all mutations can raise an exception unrelated to the requested action - (e.g. out-of-stock exception when updating checkoutShippingAddress.) If `false`, the errors will be aggregated in `checkout.problems` field. Some of the `problems` can block the finalizing checkout process. The legacy flow will be removed in Saleor 4.0. The flow with `checkout.problems` will be the default one. */
  readonly useLegacyErrorFlow: Scalars['Boolean']['output'];
};

export type CheckoutSettingsInput = {
  /**
   * Default `false`. Determines if the paid checkouts should be automatically completed. This setting applies only to checkouts where payment was processed through transactions.When enabled, the checkout will be automatically completed once the checkout `charge_status` reaches `FULL`. This occurs when the total sum of charged and authorized transaction amounts equals or exceeds the checkout's total amount.
   *
   * Added in Saleor 3.20.
   */
  readonly automaticallyCompleteFullyPaidCheckouts?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Default `true`. Determines if the checkout mutations should use legacy error flow. In legacy flow, all mutations can raise an exception unrelated to the requested action - (e.g. out-of-stock exception when updating checkoutShippingAddress.) If `false`, the errors will be aggregated in `checkout.problems` field. Some of the `problems` can block the finalizing checkout process. The legacy flow will be removed in Saleor 4.0. The flow with `checkout.problems` will be the default one.
   * @deprecated Field no longer supported
   */
  readonly useLegacyErrorFlow?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * Updates shipping address in the existing checkout.
 *
 * Triggers the following webhook events:
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutShippingAddressUpdate = {
  /** An updated checkout. */
  readonly checkout?: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

/**
 * Updates the shipping method of the checkout.
 *
 * Triggers the following webhook events:
 * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Triggered when updating the checkout shipping method with the external one.
 * - CHECKOUT_UPDATED (async): A checkout was updated.
 */
export type CheckoutShippingMethodUpdate = {
  /** An updated checkout. */
  readonly checkout?: Maybe<Checkout>;
  /** @deprecated Use `errors` field instead. */
  readonly checkoutErrors: ReadonlyArray<CheckoutError>;
  readonly errors: ReadonlyArray<CheckoutError>;
};

export type CheckoutSortField =
  /** Sort checkouts by creation date. */
  | 'CREATION_DATE'
  /** Sort checkouts by customer. */
  | 'CUSTOMER'
  /** Sort checkouts by payment. */
  | 'PAYMENT';

export type CheckoutSortingInput = {
  /** Specifies the direction in which to sort checkouts. */
  readonly direction: OrderDirection;
  /** Sort checkouts by the selected field. */
  readonly field: CheckoutSortField;
};

/** Event sent when checkout is updated. */
export type CheckoutUpdated = Event & {
  /** The checkout the event relates to. */
  readonly checkout?: Maybe<Checkout>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type CheckoutValidationRules = {
  /** The validation rules that can be applied to provided billing address data. */
  readonly billingAddress?: InputMaybe<CheckoutAddressValidationRules>;
  /** The validation rules that can be applied to provided shipping address data. */
  readonly shippingAddress?: InputMaybe<CheckoutAddressValidationRules>;
};

export type ChoiceValue = {
  /** The raw name of the choice. */
  readonly raw?: Maybe<Scalars['String']['output']>;
  /** The verbose name of the choice. */
  readonly verbose?: Maybe<Scalars['String']['output']>;
};

/** Enum determining the state of a circuit breaker. */
export type CircuitBreakerStateEnum =
  /** The breaker is conducting (requests are passing through). */
  | 'CLOSED'
  /** The breaker is in a trial period (to close or open). Note that unlike classic breaker patterns, this is not a state where we are throttling the number of requests, it's a state similar to CLOSED but with different thresholds. */
  | 'HALF_OPEN'
  /** The breaker is tripped (no requests are passing). Breaker will enter half-open state after cooldown period. */
  | 'OPEN';

/** Represents a collection of products. */
export type Collection = Node & ObjectWithMetadata & {
  /** Background image of the collection. */
  readonly backgroundImage?: Maybe<Image>;
  /** Channel given to retrieve this collection. Also used by federation gateway to resolve this object in a federated query. */
  readonly channel?: Maybe<Scalars['String']['output']>;
  /**
   * List of channels in which the collection is available.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly channelListings?: Maybe<ReadonlyArray<CollectionChannelListing>>;
  /**
   * Description of the collection.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /**
   * Description of the collection.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  readonly descriptionJson?: Maybe<Scalars['JSONString']['output']>;
  /** The ID of the collection. */
  readonly id: Scalars['ID']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Name of the collection. */
  readonly name: Scalars['String']['output'];
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** List of products in this collection. */
  readonly products?: Maybe<ProductCountableConnection>;
  /** SEO description of the collection. */
  readonly seoDescription?: Maybe<Scalars['String']['output']>;
  /** SEO title of the collection. */
  readonly seoTitle?: Maybe<Scalars['String']['output']>;
  /** Slug of the collection. */
  readonly slug: Scalars['String']['output'];
  /** Returns translated collection fields for the given language code. */
  readonly translation?: Maybe<CollectionTranslation>;
};


/** Represents a collection of products. */
export type CollectionBackgroundImageArgs = {
  format?: InputMaybe<ThumbnailFormatEnum>;
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a collection of products. */
export type CollectionMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a collection of products. */
export type CollectionMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a collection of products. */
export type CollectionPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a collection of products. */
export type CollectionPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a collection of products. */
export type CollectionProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ProductFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<ProductOrder>;
  where?: InputMaybe<ProductWhereInput>;
};


/** Represents a collection of products. */
export type CollectionTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Adds products to a collection.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionAddProducts = {
  /** Collection to which products will be added. */
  readonly collection?: Maybe<Collection>;
  /** @deprecated Use `errors` field instead. */
  readonly collectionErrors: ReadonlyArray<CollectionError>;
  readonly errors: ReadonlyArray<CollectionError>;
};

/**
 * Deletes collections.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionBulkDelete = {
  /** @deprecated Use `errors` field instead. */
  readonly collectionErrors: ReadonlyArray<CollectionError>;
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<CollectionError>;
};

/** Represents collection channel listing. */
export type CollectionChannelListing = Node & {
  /** The channel to which the collection belongs. */
  readonly channel: Channel;
  /** The ID of the collection channel listing. */
  readonly id: Scalars['ID']['output'];
  /** Indicates if the collection is published in the channel. */
  readonly isPublished: Scalars['Boolean']['output'];
  /** @deprecated Use the `publishedAt` field to fetch the publication date. */
  readonly publicationDate?: Maybe<Scalars['Date']['output']>;
  /** The collection publication date. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type CollectionChannelListingError = {
  /** List of attributes IDs which causes the error. */
  readonly attributes?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** List of channels IDs which causes the error. */
  readonly channels?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error code. */
  readonly code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of attribute values IDs which causes the error. */
  readonly values?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

/**
 * Manage collection's availability in channels.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionChannelListingUpdate = {
  /** An updated collection instance. */
  readonly collection?: Maybe<Collection>;
  /** @deprecated Use `errors` field instead. */
  readonly collectionChannelListingErrors: ReadonlyArray<CollectionChannelListingError>;
  readonly errors: ReadonlyArray<CollectionChannelListingError>;
};

export type CollectionChannelListingUpdateInput = {
  /** List of channels to which the collection should be assigned. */
  readonly addChannels?: InputMaybe<ReadonlyArray<PublishableChannelListingInput>>;
  /** List of channels from which the collection should be unassigned. */
  readonly removeChannels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/** Represents a connection to a list of collections. */
export type CollectionCountableConnection = {
  readonly edges: ReadonlyArray<CollectionCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type CollectionCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Collection;
};

/**
 * Creates a new collection.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionCreate = {
  readonly collection?: Maybe<Collection>;
  /** @deprecated Use `errors` field instead. */
  readonly collectionErrors: ReadonlyArray<CollectionError>;
  readonly errors: ReadonlyArray<CollectionError>;
};

export type CollectionCreateInput = {
  /** Background image file. */
  readonly backgroundImage?: InputMaybe<Scalars['Upload']['input']>;
  /** Alt text for an image. */
  readonly backgroundImageAlt?: InputMaybe<Scalars['String']['input']>;
  /**
   * Description of the collection.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: InputMaybe<Scalars['JSONString']['input']>;
  /** Informs whether a collection is published. */
  readonly isPublished?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Fields required to update the collection metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Name of the collection. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the collection private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** List of products to be added to the collection. */
  readonly products?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /**
   * Publication date. ISO 8601 standard.
   * @deprecated Field no longer supported
   */
  readonly publicationDate?: InputMaybe<Scalars['Date']['input']>;
  /** Search engine optimization fields. */
  readonly seo?: InputMaybe<SeoInput>;
  /** Slug of the collection. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when new collection is created. */
export type CollectionCreated = Event & {
  /** The collection the event relates to. */
  readonly collection?: Maybe<Collection>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when new collection is created. */
export type CollectionCreatedCollectionArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Deletes a collection.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionDelete = {
  readonly collection?: Maybe<Collection>;
  /** @deprecated Use `errors` field instead. */
  readonly collectionErrors: ReadonlyArray<CollectionError>;
  readonly errors: ReadonlyArray<CollectionError>;
};

/** Event sent when collection is deleted. */
export type CollectionDeleted = Event & {
  /** The collection the event relates to. */
  readonly collection?: Maybe<Collection>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when collection is deleted. */
export type CollectionDeletedCollectionArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

export type CollectionError = {
  /** The error code. */
  readonly code: CollectionErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of products IDs which causes the error. */
  readonly products?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

export type CollectionErrorCode =
  | 'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type CollectionFilterInput = {
  /**
   * Specifies the channel by which the data should be filtered.
   * @deprecated Use root-level channel argument instead.
   */
  readonly channel?: InputMaybe<Scalars['String']['input']>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly published?: InputMaybe<CollectionPublished>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly slugs?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

export type CollectionInput = {
  /** Background image file. */
  readonly backgroundImage?: InputMaybe<Scalars['Upload']['input']>;
  /** Alt text for an image. */
  readonly backgroundImageAlt?: InputMaybe<Scalars['String']['input']>;
  /**
   * Description of the collection.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: InputMaybe<Scalars['JSONString']['input']>;
  /** Informs whether a collection is published. */
  readonly isPublished?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Fields required to update the collection metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Name of the collection. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the collection private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /**
   * Publication date. ISO 8601 standard.
   * @deprecated Field no longer supported
   */
  readonly publicationDate?: InputMaybe<Scalars['Date']['input']>;
  /** Search engine optimization fields. */
  readonly seo?: InputMaybe<SeoInput>;
  /** Slug of the collection. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when collection metadata is updated. */
export type CollectionMetadataUpdated = Event & {
  /** The collection the event relates to. */
  readonly collection?: Maybe<Collection>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when collection metadata is updated. */
export type CollectionMetadataUpdatedCollectionArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

export type CollectionPublished =
  | 'HIDDEN'
  | 'PUBLISHED';

/**
 * Remove products from a collection.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionRemoveProducts = {
  /** Collection from which products will be removed. */
  readonly collection?: Maybe<Collection>;
  /** @deprecated Use `errors` field instead. */
  readonly collectionErrors: ReadonlyArray<CollectionError>;
  readonly errors: ReadonlyArray<CollectionError>;
};

/**
 * Reorder the products of a collection.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionReorderProducts = {
  /** Collection from which products are reordered. */
  readonly collection?: Maybe<Collection>;
  /** @deprecated Use `errors` field instead. */
  readonly collectionErrors: ReadonlyArray<CollectionError>;
  readonly errors: ReadonlyArray<CollectionError>;
};

export type CollectionSortField =
  /**
   * Sort collections by availability.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'AVAILABILITY'
  /** Sort collections by name. */
  | 'NAME'
  /** Sort collections by product count. */
  | 'PRODUCT_COUNT'
  /**
   * Sort collections by publication date.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'PUBLICATION_DATE'
  /**
   * Sort collections by published at.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'PUBLISHED_AT';

export type CollectionSortingInput = {
  /**
   * Specifies the channel in which to sort the data.
   * @deprecated Use root-level channel argument instead.
   */
  readonly channel?: InputMaybe<Scalars['String']['input']>;
  /** Specifies the direction in which to sort collections. */
  readonly direction: OrderDirection;
  /** Sort collections by the selected field. */
  readonly field: CollectionSortField;
};

/** Represents collection's original translatable fields and related translations. */
export type CollectionTranslatableContent = Node & {
  /**
   * Represents a collection of products.
   * @deprecated Get model fields from the root level queries.
   */
  readonly collection?: Maybe<Collection>;
  /** The ID of the collection to translate. */
  readonly collectionId: Scalars['ID']['output'];
  /**
   * Collection's description to translate.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /**
   * Description of the collection.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  readonly descriptionJson?: Maybe<Scalars['JSONString']['output']>;
  /** The ID of the collection translatable content. */
  readonly id: Scalars['ID']['output'];
  /** Collection's name to translate. */
  readonly name: Scalars['String']['output'];
  /** SEO description to translate. */
  readonly seoDescription?: Maybe<Scalars['String']['output']>;
  /** SEO title to translate. */
  readonly seoTitle?: Maybe<Scalars['String']['output']>;
  /**
   * Slug to translate
   *
   * Added in Saleor 3.21.
   */
  readonly slug?: Maybe<Scalars['String']['output']>;
  /** Returns translated collection fields for the given language code. */
  readonly translation?: Maybe<CollectionTranslation>;
};


/** Represents collection's original translatable fields and related translations. */
export type CollectionTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a collection.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type CollectionTranslate = {
  readonly collection?: Maybe<Collection>;
  readonly errors: ReadonlyArray<TranslationError>;
  /** @deprecated Use `errors` field instead. */
  readonly translationErrors: ReadonlyArray<TranslationError>;
};

/** Represents collection translations. */
export type CollectionTranslation = Node & {
  /**
   * Translated description of the collection.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /**
   * Translated description of the collection.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  readonly descriptionJson?: Maybe<Scalars['JSONString']['output']>;
  /** The ID of the collection translation. */
  readonly id: Scalars['ID']['output'];
  /** Translation language. */
  readonly language: LanguageDisplay;
  /** Translated collection name. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Translated SEO description. */
  readonly seoDescription?: Maybe<Scalars['String']['output']>;
  /** Translated SEO title. */
  readonly seoTitle?: Maybe<Scalars['String']['output']>;
  /**
   * Translated collection slug.
   *
   * Added in Saleor 3.21.
   */
  readonly slug?: Maybe<Scalars['String']['output']>;
  /** Represents the collection fields to translate. */
  readonly translatableContent?: Maybe<CollectionTranslatableContent>;
};

/**
 * Updates a collection.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type CollectionUpdate = {
  readonly collection?: Maybe<Collection>;
  /** @deprecated Use `errors` field instead. */
  readonly collectionErrors: ReadonlyArray<CollectionError>;
  readonly errors: ReadonlyArray<CollectionError>;
};

/** Event sent when collection is updated. */
export type CollectionUpdated = Event & {
  /** The collection the event relates to. */
  readonly collection?: Maybe<Collection>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when collection is updated. */
export type CollectionUpdatedCollectionArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

export type CollectionWhereInput = {
  /** List of conditions that must be met. */
  readonly AND?: InputMaybe<ReadonlyArray<CollectionWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  readonly OR?: InputMaybe<ReadonlyArray<CollectionWhereInput>>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
};

/** Stores information about a single configuration field. */
export type ConfigurationItem = {
  /** Help text for the field. */
  readonly helpText?: Maybe<Scalars['String']['output']>;
  /** Label for the field. */
  readonly label?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  readonly name: Scalars['String']['output'];
  /** Type of the field. */
  readonly type?: Maybe<ConfigurationTypeFieldEnum>;
  /** Current value of the field. */
  readonly value?: Maybe<Scalars['String']['output']>;
};

export type ConfigurationItemInput = {
  /** Name of the field to update. */
  readonly name: Scalars['String']['input'];
  /** Value of the given field to update. */
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

export type ConfigurationTypeFieldEnum =
  | 'BOOLEAN'
  | 'MULTILINE'
  | 'OUTPUT'
  | 'PASSWORD'
  | 'SECRET'
  | 'SECRETMULTILINE'
  | 'STRING';

/**
 * Confirm user account with token sent by email during registration.
 *
 * Triggers the following webhook events:
 * - ACCOUNT_CONFIRMED (async): Account was confirmed.
 */
export type ConfirmAccount = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  /** An activated user account. */
  readonly user?: Maybe<User>;
};

/**
 * Confirm the email change of the logged-in user.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_UPDATED (async): A customer account was updated.
 * - NOTIFY_USER (async): A notification that account email change was confirmed.
 * - ACCOUNT_EMAIL_CHANGED (async): An account email was changed.
 */
export type ConfirmEmailChange = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  /** A user instance with a new email. */
  readonly user?: Maybe<User>;
};

/** Define the filtering options for fields that can contain multiple values. */
export type ContainsFilterInput = {
  /** The field contains all of the specified values. */
  readonly containsAll?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** The field contains at least one of the specified values. */
  readonly containsAny?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/**
 * Represents country codes defined by the ISO 3166-1 alpha-2 standard.
 *
 * The `EU` value is DEPRECATED and will be removed in Saleor 3.21.
 */
export type CountryCode =
  | 'AD'
  | 'AE'
  | 'AF'
  | 'AG'
  | 'AI'
  | 'AL'
  | 'AM'
  | 'AO'
  | 'AQ'
  | 'AR'
  | 'AS'
  | 'AT'
  | 'AU'
  | 'AW'
  | 'AX'
  | 'AZ'
  | 'BA'
  | 'BB'
  | 'BD'
  | 'BE'
  | 'BF'
  | 'BG'
  | 'BH'
  | 'BI'
  | 'BJ'
  | 'BL'
  | 'BM'
  | 'BN'
  | 'BO'
  | 'BQ'
  | 'BR'
  | 'BS'
  | 'BT'
  | 'BV'
  | 'BW'
  | 'BY'
  | 'BZ'
  | 'CA'
  | 'CC'
  | 'CD'
  | 'CF'
  | 'CG'
  | 'CH'
  | 'CI'
  | 'CK'
  | 'CL'
  | 'CM'
  | 'CN'
  | 'CO'
  | 'CR'
  | 'CU'
  | 'CV'
  | 'CW'
  | 'CX'
  | 'CY'
  | 'CZ'
  | 'DE'
  | 'DJ'
  | 'DK'
  | 'DM'
  | 'DO'
  | 'DZ'
  | 'EC'
  | 'EE'
  | 'EG'
  | 'EH'
  | 'ER'
  | 'ES'
  | 'ET'
  | 'EU'
  | 'FI'
  | 'FJ'
  | 'FK'
  | 'FM'
  | 'FO'
  | 'FR'
  | 'GA'
  | 'GB'
  | 'GD'
  | 'GE'
  | 'GF'
  | 'GG'
  | 'GH'
  | 'GI'
  | 'GL'
  | 'GM'
  | 'GN'
  | 'GP'
  | 'GQ'
  | 'GR'
  | 'GS'
  | 'GT'
  | 'GU'
  | 'GW'
  | 'GY'
  | 'HK'
  | 'HM'
  | 'HN'
  | 'HR'
  | 'HT'
  | 'HU'
  | 'ID'
  | 'IE'
  | 'IL'
  | 'IM'
  | 'IN'
  | 'IO'
  | 'IQ'
  | 'IR'
  | 'IS'
  | 'IT'
  | 'JE'
  | 'JM'
  | 'JO'
  | 'JP'
  | 'KE'
  | 'KG'
  | 'KH'
  | 'KI'
  | 'KM'
  | 'KN'
  | 'KP'
  | 'KR'
  | 'KW'
  | 'KY'
  | 'KZ'
  | 'LA'
  | 'LB'
  | 'LC'
  | 'LI'
  | 'LK'
  | 'LR'
  | 'LS'
  | 'LT'
  | 'LU'
  | 'LV'
  | 'LY'
  | 'MA'
  | 'MC'
  | 'MD'
  | 'ME'
  | 'MF'
  | 'MG'
  | 'MH'
  | 'MK'
  | 'ML'
  | 'MM'
  | 'MN'
  | 'MO'
  | 'MP'
  | 'MQ'
  | 'MR'
  | 'MS'
  | 'MT'
  | 'MU'
  | 'MV'
  | 'MW'
  | 'MX'
  | 'MY'
  | 'MZ'
  | 'NA'
  | 'NC'
  | 'NE'
  | 'NF'
  | 'NG'
  | 'NI'
  | 'NL'
  | 'NO'
  | 'NP'
  | 'NR'
  | 'NU'
  | 'NZ'
  | 'OM'
  | 'PA'
  | 'PE'
  | 'PF'
  | 'PG'
  | 'PH'
  | 'PK'
  | 'PL'
  | 'PM'
  | 'PN'
  | 'PR'
  | 'PS'
  | 'PT'
  | 'PW'
  | 'PY'
  | 'QA'
  | 'RE'
  | 'RO'
  | 'RS'
  | 'RU'
  | 'RW'
  | 'SA'
  | 'SB'
  | 'SC'
  | 'SD'
  | 'SE'
  | 'SG'
  | 'SH'
  | 'SI'
  | 'SJ'
  | 'SK'
  | 'SL'
  | 'SM'
  | 'SN'
  | 'SO'
  | 'SR'
  | 'SS'
  | 'ST'
  | 'SV'
  | 'SX'
  | 'SY'
  | 'SZ'
  | 'TC'
  | 'TD'
  | 'TF'
  | 'TG'
  | 'TH'
  | 'TJ'
  | 'TK'
  | 'TL'
  | 'TM'
  | 'TN'
  | 'TO'
  | 'TR'
  | 'TT'
  | 'TV'
  | 'TW'
  | 'TZ'
  | 'UA'
  | 'UG'
  | 'UM'
  | 'US'
  | 'UY'
  | 'UZ'
  | 'VA'
  | 'VC'
  | 'VE'
  | 'VG'
  | 'VI'
  | 'VN'
  | 'VU'
  | 'WF'
  | 'WS'
  | 'XK'
  | 'YE'
  | 'YT'
  | 'ZA'
  | 'ZM'
  | 'ZW';

/** Filter by country code. */
export type CountryCodeEnumFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<CountryCode>;
  /** The value not included in. */
  readonly notOneOf?: InputMaybe<ReadonlyArray<CountryCode>>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<CountryCode>>;
};

export type CountryDisplay = {
  /** Country code. */
  readonly code: Scalars['String']['output'];
  /** Country name. */
  readonly country: Scalars['String']['output'];
  /**
   * Country tax.
   * @deprecated Always returns `null`. Use `TaxClassCountryRate` type to manage tax rates per country.
   */
  readonly vat?: Maybe<Vat>;
};

export type CountryFilterInput = {
  /** Boolean for filtering countries by having shipping zone assigned.If 'true', return countries with shipping zone assigned.If 'false', return countries without any shipping zone assigned.If the argument is not provided (null), return all countries. */
  readonly attachedToShippingZones?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CountryRateInput = {
  /** Country in which this rate applies. */
  readonly countryCode: CountryCode;
  /** Tax rate value provided as percentage. Example: provide `23` to represent `23%` tax rate. */
  readonly rate: Scalars['Float']['input'];
};

export type CountryRateUpdateInput = {
  /** Country in which this rate applies. */
  readonly countryCode: CountryCode;
  /** Tax rate value provided as percentage. Example: provide `23` to represent `23%` tax rate. Provide `null` to remove the particular rate. */
  readonly rate?: InputMaybe<Scalars['Float']['input']>;
};

/** Create JWT token. */
export type CreateToken = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  /** CSRF token required to re-generate access token. */
  readonly csrfToken?: Maybe<Scalars['String']['output']>;
  readonly errors: ReadonlyArray<AccountError>;
  /** JWT refresh token, required to re-generate access token. */
  readonly refreshToken?: Maybe<Scalars['String']['output']>;
  /** JWT token, required to authenticate. */
  readonly token?: Maybe<Scalars['String']['output']>;
  /** A user instance. */
  readonly user?: Maybe<User>;
};

export type CreditCard = {
  /** Card brand. */
  readonly brand: Scalars['String']['output'];
  /** Two-digit number representing the cards expiration month. */
  readonly expMonth?: Maybe<Scalars['Int']['output']>;
  /** Four-digit number representing the cards expiration year. */
  readonly expYear?: Maybe<Scalars['Int']['output']>;
  /** First 4 digits of the card number. */
  readonly firstDigits?: Maybe<Scalars['String']['output']>;
  /** Last 4 digits of the card number. */
  readonly lastDigits: Scalars['String']['output'];
};

/**
 * Deletes customers.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_DELETED (async): A customer account was deleted.
 */
export type CustomerBulkDelete = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<AccountError>;
};

export type CustomerBulkResult = {
  /** Customer data. */
  readonly customer?: Maybe<User>;
  /** List of errors that occurred during the update attempt. */
  readonly errors?: Maybe<ReadonlyArray<CustomerBulkUpdateError>>;
};

/**
 * Updates customers.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_UPDATED (async): A customer account was updated.
 * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
 */
export type CustomerBulkUpdate = {
  /** Returns how many objects were created. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<CustomerBulkUpdateError>;
  /** List of the updated customers. */
  readonly results: ReadonlyArray<CustomerBulkResult>;
};

export type CustomerBulkUpdateError = {
  /** The error code. */
  readonly code: CustomerBulkUpdateErrorCode;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly path?: Maybe<Scalars['String']['output']>;
};

export type CustomerBulkUpdateErrorCode =
  | 'BLANK'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'MAX_LENGTH'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type CustomerBulkUpdateInput = {
  /** External ID of a customer to update. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** ID of a customer to update. */
  readonly id?: InputMaybe<Scalars['ID']['input']>;
  /** Fields required to update a customer. */
  readonly input: CustomerInput;
};

/**
 * Creates a new customer.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_CREATED (async): A new customer account was created.
 * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
 * - NOTIFY_USER (async): A notification for setting the password.
 * - ACCOUNT_SET_PASSWORD_REQUESTED (async): Setting a new password for the account is requested.
 */
export type CustomerCreate = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  readonly user?: Maybe<User>;
};

/** Event sent when new customer user is created. */
export type CustomerCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The user the event relates to. */
  readonly user?: Maybe<User>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Deletes a customer.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_DELETED (async): A customer account was deleted.
 */
export type CustomerDelete = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  readonly user?: Maybe<User>;
};

/** History log of the customer. */
export type CustomerEvent = Node & {
  /** App that performed the action. */
  readonly app?: Maybe<App>;
  /** Number of objects concerned by the event. */
  readonly count?: Maybe<Scalars['Int']['output']>;
  /** Date when event happened at in ISO 8601 format. */
  readonly date?: Maybe<Scalars['DateTime']['output']>;
  /** The ID of the customer event. */
  readonly id: Scalars['ID']['output'];
  /** Content of the event. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** The concerned order. */
  readonly order?: Maybe<Order>;
  /** The concerned order line. */
  readonly orderLine?: Maybe<OrderLine>;
  /** Customer event type. */
  readonly type?: Maybe<CustomerEventsEnum>;
  /** User who performed the action. */
  readonly user?: Maybe<User>;
};

export type CustomerEventsEnum =
  | 'ACCOUNT_ACTIVATED'
  | 'ACCOUNT_CREATED'
  | 'ACCOUNT_DEACTIVATED'
  | 'CUSTOMER_DELETED'
  | 'DIGITAL_LINK_DOWNLOADED'
  | 'EMAIL_ASSIGNED'
  | 'EMAIL_CHANGED'
  | 'EMAIL_CHANGED_REQUEST'
  | 'NAME_ASSIGNED'
  | 'NOTE_ADDED'
  | 'NOTE_ADDED_TO_ORDER'
  | 'PASSWORD_CHANGED'
  | 'PASSWORD_RESET'
  | 'PASSWORD_RESET_LINK_SENT'
  | 'PLACED_ORDER';

export type CustomerFilterInput = {
  readonly dateJoined?: InputMaybe<DateRangeInput>;
  /** Filter by ids. */
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly numberOfOrders?: InputMaybe<IntRangeInput>;
  readonly placedOrders?: InputMaybe<DateRangeInput>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly updatedAt?: InputMaybe<DateTimeRangeInput>;
};

export type CustomerInput = {
  /** Billing address of the customer. */
  readonly defaultBillingAddress?: InputMaybe<AddressInput>;
  /** Shipping address of the customer. */
  readonly defaultShippingAddress?: InputMaybe<AddressInput>;
  /** The unique email address of the user. */
  readonly email?: InputMaybe<Scalars['String']['input']>;
  /** External ID of the customer. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** Given name. */
  readonly firstName?: InputMaybe<Scalars['String']['input']>;
  /** User account is active. */
  readonly isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** User account is confirmed. */
  readonly isConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  /** User language code. */
  readonly languageCode?: InputMaybe<LanguageCodeEnum>;
  /** Family name. */
  readonly lastName?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the user metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** A note about the user. */
  readonly note?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the user private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
};

/** Event sent when customer user metadata is updated. */
export type CustomerMetadataUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The user the event relates to. */
  readonly user?: Maybe<User>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Updates an existing customer.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 *
 * Triggers the following webhook events:
 * - CUSTOMER_UPDATED (async): A new customer account was updated.
 * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
 */
export type CustomerUpdate = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  readonly user?: Maybe<User>;
};

/** Event sent when customer user is updated. */
export type CustomerUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The user the event relates to. */
  readonly user?: Maybe<User>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type CustomerWhereInput = {
  /** List of conditions that must be met. */
  readonly AND?: InputMaybe<ReadonlyArray<CustomerWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  readonly OR?: InputMaybe<ReadonlyArray<CustomerWhereInput>>;
  /** Filter by addresses data associated with user. */
  readonly addresses?: InputMaybe<AddressFilterInput>;
  /** Filter by date joined. */
  readonly dateJoined?: InputMaybe<DateTimeRangeInput>;
  /** Filter by email address. */
  readonly email?: InputMaybe<StringFilterInput>;
  /** Filter by first name. */
  readonly firstName?: InputMaybe<StringFilterInput>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Filter by whether the user is active. */
  readonly isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by last name. */
  readonly lastName?: InputMaybe<StringFilterInput>;
  /** Filter by metadata fields. */
  readonly metadata?: InputMaybe<MetadataFilterInput>;
  /** Filter by number of orders placed by the user. */
  readonly numberOfOrders?: InputMaybe<IntFilterInput>;
  /** Filter by date when orders were placed. */
  readonly placedOrdersAt?: InputMaybe<DateTimeRangeInput>;
  /** Filter by last updated date. */
  readonly updatedAt?: InputMaybe<DateTimeRangeInput>;
};

export type DateRangeInput = {
  /** Start date. */
  readonly gte?: InputMaybe<Scalars['Date']['input']>;
  /** End date. */
  readonly lte?: InputMaybe<Scalars['Date']['input']>;
};

/** Define the filtering options for date time fields. */
export type DateTimeFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<Scalars['DateTime']['input']>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;
  /** The value in range. */
  readonly range?: InputMaybe<DateTimeRangeInput>;
};

export type DateTimeRangeInput = {
  /** Start date. */
  readonly gte?: InputMaybe<Scalars['DateTime']['input']>;
  /** End date. */
  readonly lte?: InputMaybe<Scalars['DateTime']['input']>;
};

/**
 * Deactivate all JWT tokens of the currently authenticated user.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 */
export type DeactivateAllUserTokens = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
};

/** Define the filtering options for decimal fields. */
export type DecimalFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<Scalars['Decimal']['input']>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<Scalars['Decimal']['input']>>;
  /** The value in range. */
  readonly range?: InputMaybe<DecimalRangeInput>;
};

export type DecimalRangeInput = {
  /** Decimal value greater than or equal to. */
  readonly gte?: InputMaybe<Scalars['Decimal']['input']>;
  /** Decimal value less than or equal to. */
  readonly lte?: InputMaybe<Scalars['Decimal']['input']>;
};

/** Delete metadata of an object. To use it, you need to have access to the modified object. */
export type DeleteMetadata = {
  readonly errors: ReadonlyArray<MetadataError>;
  readonly item?: Maybe<ObjectWithMetadata>;
  /** @deprecated Use `errors` field instead. */
  readonly metadataErrors: ReadonlyArray<MetadataError>;
};

/** Delete object's private metadata. To use it, you need to be an authenticated staff user or an app and have access to the modified object. */
export type DeletePrivateMetadata = {
  readonly errors: ReadonlyArray<MetadataError>;
  readonly item?: Maybe<ObjectWithMetadata>;
  /** @deprecated Use `errors` field instead. */
  readonly metadataErrors: ReadonlyArray<MetadataError>;
};

/** Represents a delivery method chosen for the checkout. `Warehouse` type is used when checkout is marked as "click and collect" and `ShippingMethod` otherwise. */
export type DeliveryMethod = ShippingMethod | Warehouse;

/** Represents digital content associated with a product variant. */
export type DigitalContent = Node & ObjectWithMetadata & {
  /** Indicator for automatic fulfillment of digital content. */
  readonly automaticFulfillment: Scalars['Boolean']['output'];
  /** File associated with digital content. */
  readonly contentFile: Scalars['String']['output'];
  /** The ID of the digital content. */
  readonly id: Scalars['ID']['output'];
  /** Maximum number of allowed downloads for the digital content. */
  readonly maxDownloads?: Maybe<Scalars['Int']['output']>;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Product variant assigned to digital content. */
  readonly productVariant: ProductVariant;
  /** Number of days the URL for the digital content remains valid. */
  readonly urlValidDays?: Maybe<Scalars['Int']['output']>;
  /** List of URLs for the digital variant. */
  readonly urls?: Maybe<ReadonlyArray<DigitalContentUrl>>;
  /** Default settings indicator for digital content. */
  readonly useDefaultSettings: Scalars['Boolean']['output'];
};


/** Represents digital content associated with a product variant. */
export type DigitalContentMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents digital content associated with a product variant. */
export type DigitalContentMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents digital content associated with a product variant. */
export type DigitalContentPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents digital content associated with a product variant. */
export type DigitalContentPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** A connection to a list of digital content items. */
export type DigitalContentCountableConnection = {
  readonly edges: ReadonlyArray<DigitalContentCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type DigitalContentCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: DigitalContent;
};

/**
 * Create new digital content. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type DigitalContentCreate = {
  readonly content?: Maybe<DigitalContent>;
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  readonly variant?: Maybe<ProductVariant>;
};

/**
 * Remove digital content assigned to given variant.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type DigitalContentDelete = {
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  readonly variant?: Maybe<ProductVariant>;
};

export type DigitalContentInput = {
  /** Overwrite default automatic_fulfillment setting for variant. */
  readonly automaticFulfillment?: InputMaybe<Scalars['Boolean']['input']>;
  /** Determines how many times a download link can be accessed by a customer. */
  readonly maxDownloads?: InputMaybe<Scalars['Int']['input']>;
  /**
   * Fields required to update the digital content metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /**
   * Fields required to update the digital content private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Determines for how many days a download link is active since it was generated. */
  readonly urlValidDays?: InputMaybe<Scalars['Int']['input']>;
  /** Use default digital content settings for this product. */
  readonly useDefaultSettings: Scalars['Boolean']['input'];
};

/**
 * Updates digital content.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type DigitalContentUpdate = {
  readonly content?: Maybe<DigitalContent>;
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  readonly variant?: Maybe<ProductVariant>;
};

export type DigitalContentUploadInput = {
  /** Overwrite default automatic_fulfillment setting for variant. */
  readonly automaticFulfillment?: InputMaybe<Scalars['Boolean']['input']>;
  /** Represents an file in a multipart request. */
  readonly contentFile: Scalars['Upload']['input'];
  /** Determines how many times a download link can be accessed by a customer. */
  readonly maxDownloads?: InputMaybe<Scalars['Int']['input']>;
  /**
   * Fields required to update the digital content metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /**
   * Fields required to update the digital content private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Determines for how many days a download link is active since it was generated. */
  readonly urlValidDays?: InputMaybe<Scalars['Int']['input']>;
  /** Use default digital content settings for this product. */
  readonly useDefaultSettings: Scalars['Boolean']['input'];
};

/** Represents a URL for digital content. */
export type DigitalContentUrl = Node & {
  /** Digital content associated with the URL. */
  readonly content: DigitalContent;
  /** Date and time when the digital content URL was created. */
  readonly created: Scalars['DateTime']['output'];
  /** Number of times digital content has been downloaded. */
  readonly downloadNum: Scalars['Int']['output'];
  /** The ID of the digital content URL. */
  readonly id: Scalars['ID']['output'];
  /** UUID of digital content. */
  readonly token: Scalars['UUID']['output'];
  /** URL for digital content. */
  readonly url?: Maybe<Scalars['String']['output']>;
};

/**
 * Generate new URL to digital content.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type DigitalContentUrlCreate = {
  readonly digitalContentUrl?: Maybe<DigitalContentUrl>;
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

export type DigitalContentUrlCreateInput = {
  /** Digital content ID which URL will belong to. */
  readonly content: Scalars['ID']['input'];
};

export type DiscountError = {
  /** List of channels IDs which causes the error. */
  readonly channels?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error code. */
  readonly code: DiscountErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of products IDs which causes the error. */
  readonly products?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /**
   * List of voucher codes which causes the error.
   *
   * Added in Saleor 3.18.
   */
  readonly voucherCodes?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
};

export type DiscountErrorCode =
  | 'ALREADY_EXISTS'
  | 'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE'
  | 'VOUCHER_ALREADY_USED';

export type DiscountStatusEnum =
  | 'ACTIVE'
  | 'EXPIRED'
  | 'SCHEDULED';

export type DiscountValueTypeEnum =
  | 'FIXED'
  | 'PERCENTAGE';

export type DiscountedObjectWhereInput = {
  /** List of conditions that must be met. */
  readonly AND?: InputMaybe<ReadonlyArray<DiscountedObjectWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  readonly OR?: InputMaybe<ReadonlyArray<DiscountedObjectWhereInput>>;
  /** Filter by the base subtotal price. */
  readonly baseSubtotalPrice?: InputMaybe<DecimalFilterInput>;
  /** Filter by the base total price. */
  readonly baseTotalPrice?: InputMaybe<DecimalFilterInput>;
};

export type DistanceUnitsEnum =
  | 'CM'
  | 'DM'
  | 'FT'
  | 'INCH'
  | 'KM'
  | 'M'
  | 'MM'
  | 'YD';

/** Represents API domain. */
export type Domain = {
  /** The host name of the domain. */
  readonly host: Scalars['String']['output'];
  /** Inform if SSL is enabled. */
  readonly sslEnabled: Scalars['Boolean']['output'];
  /** The absolute URL of the API. */
  readonly url: Scalars['String']['output'];
};

/**
 * Deletes draft orders.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type DraftOrderBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<OrderError>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

/**
 * Completes creating an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type DraftOrderComplete = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Completed order. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

/**
 * Creates a new draft order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type DraftOrderCreate = {
  readonly errors: ReadonlyArray<OrderError>;
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

export type DraftOrderCreateInput = {
  /** Billing address of the customer. */
  readonly billingAddress?: InputMaybe<AddressInput>;
  /** ID of the channel associated with the order. */
  readonly channelId?: InputMaybe<Scalars['ID']['input']>;
  /** A note from a customer. Visible by customers in the order summary. */
  readonly customerNote?: InputMaybe<Scalars['String']['input']>;
  /**
   * Discount amount for the order.
   * @deprecated Providing a value for the field has no effect. Use `orderDiscountAdd` mutation instead.
   */
  readonly discount?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** External ID of this order. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /**
   * Order language code.
   *
   * Added in Saleor 3.21.
   */
  readonly languageCode?: InputMaybe<LanguageCodeEnum>;
  /** Variant line input consisting of variant ID and quantity of products. */
  readonly lines?: InputMaybe<ReadonlyArray<OrderLineCreateInput>>;
  /**
   * Order public metadata.
   *
   * Added in Saleor 3.21. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /**
   * Order private metadata.
   *
   * Added in Saleor 3.21. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** URL of a view where users should be redirected to see the order details. URL in RFC 1808 format. */
  readonly redirectUrl?: InputMaybe<Scalars['String']['input']>;
  /**
   * Indicates whether the billing address should be saved to the users address book upon draft order completion. Can only be set when a billing address is provided. If not specified along with the address, the default behavior is to not save the address.
   *
   * Added in Saleor 3.21.
   */
  readonly saveBillingAddress?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Indicates whether the shipping address should be saved to the users address book upon draft order completion.Can only be set when a shipping address is provided. If not specified along with the address, the default behavior is to not save the address.
   *
   * Added in Saleor 3.21.
   */
  readonly saveShippingAddress?: InputMaybe<Scalars['Boolean']['input']>;
  /** Shipping address of the customer. */
  readonly shippingAddress?: InputMaybe<AddressInput>;
  /** ID of a selected shipping method. */
  readonly shippingMethod?: InputMaybe<Scalars['ID']['input']>;
  /** Customer associated with the draft order. */
  readonly user?: InputMaybe<Scalars['ID']['input']>;
  /** Email address of the customer. */
  readonly userEmail?: InputMaybe<Scalars['String']['input']>;
  /** ID of the voucher associated with the order. */
  readonly voucher?: InputMaybe<Scalars['ID']['input']>;
  /**
   * A code of the voucher associated with the order.
   *
   * Added in Saleor 3.18.
   */
  readonly voucherCode?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when new draft order is created. */
export type DraftOrderCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Deletes a draft order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type DraftOrderDelete = {
  readonly errors: ReadonlyArray<OrderError>;
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

/** Event sent when draft order is deleted. */
export type DraftOrderDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type DraftOrderInput = {
  /** Billing address of the customer. */
  readonly billingAddress?: InputMaybe<AddressInput>;
  /** ID of the channel associated with the order. */
  readonly channelId?: InputMaybe<Scalars['ID']['input']>;
  /** A note from a customer. Visible by customers in the order summary. */
  readonly customerNote?: InputMaybe<Scalars['String']['input']>;
  /**
   * Discount amount for the order.
   * @deprecated Providing a value for the field has no effect. Use `orderDiscountAdd` mutation instead.
   */
  readonly discount?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** External ID of this order. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /**
   * Order language code.
   *
   * Added in Saleor 3.21.
   */
  readonly languageCode?: InputMaybe<LanguageCodeEnum>;
  /**
   * Order public metadata.
   *
   * Added in Saleor 3.21. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /**
   * Order private metadata.
   *
   * Added in Saleor 3.21. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** URL of a view where users should be redirected to see the order details. URL in RFC 1808 format. */
  readonly redirectUrl?: InputMaybe<Scalars['String']['input']>;
  /**
   * Indicates whether the billing address should be saved to the users address book upon draft order completion. Can only be set when a billing address is provided. If not specified along with the address, the default behavior is to not save the address.
   *
   * Added in Saleor 3.21.
   */
  readonly saveBillingAddress?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Indicates whether the shipping address should be saved to the users address book upon draft order completion.Can only be set when a shipping address is provided. If not specified along with the address, the default behavior is to not save the address.
   *
   * Added in Saleor 3.21.
   */
  readonly saveShippingAddress?: InputMaybe<Scalars['Boolean']['input']>;
  /** Shipping address of the customer. */
  readonly shippingAddress?: InputMaybe<AddressInput>;
  /** ID of a selected shipping method. */
  readonly shippingMethod?: InputMaybe<Scalars['ID']['input']>;
  /** Customer associated with the draft order. */
  readonly user?: InputMaybe<Scalars['ID']['input']>;
  /** Email address of the customer. */
  readonly userEmail?: InputMaybe<Scalars['String']['input']>;
  /** ID of the voucher associated with the order. */
  readonly voucher?: InputMaybe<Scalars['ID']['input']>;
  /**
   * A code of the voucher associated with the order.
   *
   * Added in Saleor 3.18.
   */
  readonly voucherCode?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Deletes order lines.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type DraftOrderLinesBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<OrderError>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

/**
 * Updates a draft order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type DraftOrderUpdate = {
  readonly errors: ReadonlyArray<OrderError>;
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

/** Event sent when draft order is updated. */
export type DraftOrderUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type DraftOrderWhereInput = {
  /** List of conditions that must be met. */
  readonly AND?: InputMaybe<ReadonlyArray<DraftOrderWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  readonly OR?: InputMaybe<ReadonlyArray<DraftOrderWhereInput>>;
  /** Filter by authorize status. */
  readonly authorizeStatus?: InputMaybe<OrderAuthorizeStatusEnumFilterInput>;
  /** Filter by billing address of the order. */
  readonly billingAddress?: InputMaybe<AddressFilterInput>;
  /** Filter by channel. */
  readonly channelId?: InputMaybe<GlobalIdFilterInput>;
  /** Filter by charge status. */
  readonly chargeStatus?: InputMaybe<OrderChargeStatusEnumFilterInput>;
  /** Filter order by created at date. */
  readonly createdAt?: InputMaybe<DateTimeRangeInput>;
  /** Filter by order events. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  readonly events?: InputMaybe<ReadonlyArray<OrderEventFilterInput>>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Filter by whether the order uses the click and collect delivery method. */
  readonly isClickAndCollect?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by line items associated with the order. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  readonly lines?: InputMaybe<ReadonlyArray<LinesFilterInput>>;
  /** Filter by number of lines in the order. */
  readonly linesCount?: InputMaybe<IntFilterInput>;
  /** Filter by metadata fields. */
  readonly metadata?: InputMaybe<MetadataFilterInput>;
  /** Filter by order number. */
  readonly number?: InputMaybe<IntFilterInput>;
  /** Filter by the product type of related order lines. */
  readonly productTypeId?: InputMaybe<GlobalIdFilterInput>;
  /** Filter by shipping address of the order. */
  readonly shippingAddress?: InputMaybe<AddressFilterInput>;
  /** Filter by total gross amount of the order. */
  readonly totalGross?: InputMaybe<PriceFilterInput>;
  /** Filter by total net amount of the order. */
  readonly totalNet?: InputMaybe<PriceFilterInput>;
  /** Filter by transaction data associated with the order. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  readonly transactions?: InputMaybe<ReadonlyArray<TransactionFilterInput>>;
  /** Filter order by updated at date. */
  readonly updatedAt?: InputMaybe<DateTimeRangeInput>;
  /** Filter by user. */
  readonly user?: InputMaybe<GlobalIdFilterInput>;
  /** Filter by user email. */
  readonly userEmail?: InputMaybe<StringFilterInput>;
  /** Filter by voucher code used in the order. */
  readonly voucherCode?: InputMaybe<StringFilterInput>;
};

export type ErrorPolicyEnum =
  /** Save what is possible within a single row. If there are errors in an input data row, try to save it partially and skip the invalid part. */
  | 'IGNORE_FAILED'
  /** Reject all rows if there is at least one error in any of them. */
  | 'REJECT_EVERYTHING'
  /** Reject rows with errors. */
  | 'REJECT_FAILED_ROWS';

export type Event = {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Event delivery. */
export type EventDelivery = Node & {
  /** Event delivery attempts. */
  readonly attempts?: Maybe<EventDeliveryAttemptCountableConnection>;
  /** Creation time of an event delivery. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Webhook event type. */
  readonly eventType: WebhookEventTypeEnum;
  /** The ID of an event delivery. */
  readonly id: Scalars['ID']['output'];
  /** Event payload. */
  readonly payload?: Maybe<Scalars['String']['output']>;
  /** Event delivery status. */
  readonly status: EventDeliveryStatusEnum;
};


/** Event delivery. */
export type EventDeliveryAttemptsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<EventDeliveryAttemptSortingInput>;
};

/** Event delivery attempts. */
export type EventDeliveryAttempt = Node & {
  /** Event delivery creation date and time. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Delivery attempt duration. */
  readonly duration?: Maybe<Scalars['Float']['output']>;
  /** The ID of Event Delivery Attempt. */
  readonly id: Scalars['ID']['output'];
  /** Request headers for delivery attempt. */
  readonly requestHeaders?: Maybe<Scalars['String']['output']>;
  /** Delivery attempt response content. */
  readonly response?: Maybe<Scalars['String']['output']>;
  /** Response headers for delivery attempt. */
  readonly responseHeaders?: Maybe<Scalars['String']['output']>;
  /** Delivery attempt response status code. */
  readonly responseStatusCode?: Maybe<Scalars['Int']['output']>;
  /** Event delivery status. */
  readonly status: EventDeliveryStatusEnum;
  /** Task id for delivery attempt. */
  readonly taskId?: Maybe<Scalars['String']['output']>;
};

export type EventDeliveryAttemptCountableConnection = {
  readonly edges: ReadonlyArray<EventDeliveryAttemptCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type EventDeliveryAttemptCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: EventDeliveryAttempt;
};

export type EventDeliveryAttemptSortField =
  /** Sort event delivery attempts by created at. */
  | 'CREATED_AT';

export type EventDeliveryAttemptSortingInput = {
  /** Specifies the direction in which to sort attempts. */
  readonly direction: OrderDirection;
  /** Sort attempts by the selected field. */
  readonly field: EventDeliveryAttemptSortField;
};

export type EventDeliveryCountableConnection = {
  readonly edges: ReadonlyArray<EventDeliveryCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type EventDeliveryCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: EventDelivery;
};

export type EventDeliveryFilterInput = {
  readonly eventType?: InputMaybe<WebhookEventTypeEnum>;
  readonly status?: InputMaybe<EventDeliveryStatusEnum>;
};

/**
 * Retries event delivery.
 *
 * Requires one of the following permissions: MANAGE_APPS.
 */
export type EventDeliveryRetry = {
  /** Event delivery. */
  readonly delivery?: Maybe<EventDelivery>;
  readonly errors: ReadonlyArray<WebhookError>;
};

export type EventDeliverySortField =
  /** Sort event deliveries by created at. */
  | 'CREATED_AT';

export type EventDeliverySortingInput = {
  /** Specifies the direction in which to sort deliveries. */
  readonly direction: OrderDirection;
  /** Sort deliveries by the selected field. */
  readonly field: EventDeliverySortField;
};

export type EventDeliveryStatusEnum =
  | 'FAILED'
  | 'PENDING'
  | 'SUCCESS';

export type ExportError = {
  /** The error code. */
  readonly code: ExportErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type ExportErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

/** History log of export file. */
export type ExportEvent = Node & {
  /** App which performed the action. Requires one of the following permissions: OWNER, MANAGE_APPS. */
  readonly app?: Maybe<App>;
  /** Date when event happened at in ISO 8601 format. */
  readonly date: Scalars['DateTime']['output'];
  /** The ID of the object. */
  readonly id: Scalars['ID']['output'];
  /** Content of the event. */
  readonly message: Scalars['String']['output'];
  /** Export event type. */
  readonly type: ExportEventsEnum;
  /** User who performed the action. Requires one of the following permissions: OWNER, MANAGE_STAFF. */
  readonly user?: Maybe<User>;
};

export type ExportEventsEnum =
  | 'EXPORTED_FILE_SENT'
  | 'EXPORT_DELETED'
  | 'EXPORT_FAILED'
  | 'EXPORT_FAILED_INFO_SENT'
  | 'EXPORT_PENDING'
  | 'EXPORT_SUCCESS';

/** Represents a job data of exported file. */
export type ExportFile = Job & Node & {
  /** The app which requests file export. */
  readonly app?: Maybe<App>;
  /** Created date time of job in ISO 8601 format. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** List of events associated with the export. */
  readonly events?: Maybe<ReadonlyArray<ExportEvent>>;
  /** The ID of the export file. */
  readonly id: Scalars['ID']['output'];
  /** Job message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Job status. */
  readonly status: JobStatusEnum;
  /** Date time of job last update in ISO 8601 format. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The URL of field to download. */
  readonly url?: Maybe<Scalars['String']['output']>;
  /** The user who requests file export. */
  readonly user?: Maybe<User>;
};

export type ExportFileCountableConnection = {
  readonly edges: ReadonlyArray<ExportFileCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type ExportFileCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: ExportFile;
};

export type ExportFileFilterInput = {
  readonly app?: InputMaybe<Scalars['String']['input']>;
  readonly createdAt?: InputMaybe<DateTimeRangeInput>;
  readonly status?: InputMaybe<JobStatusEnum>;
  readonly updatedAt?: InputMaybe<DateTimeRangeInput>;
  readonly user?: InputMaybe<Scalars['String']['input']>;
};

export type ExportFileSortField =
  | 'CREATED_AT'
  | 'LAST_MODIFIED_AT'
  | 'STATUS'
  | 'UPDATED_AT';

export type ExportFileSortingInput = {
  /** Specifies the direction in which to sort export file. */
  readonly direction: OrderDirection;
  /** Sort export file by the selected field. */
  readonly field: ExportFileSortField;
};

/**
 * Export gift cards to csv file.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - NOTIFY_USER (async): A notification for the exported file.
 * - GIFT_CARD_EXPORT_COMPLETED (async): A notification for the exported file.
 */
export type ExportGiftCards = {
  readonly errors: ReadonlyArray<ExportError>;
  /** The newly created export file job which is responsible for export data. */
  readonly exportFile?: Maybe<ExportFile>;
};

export type ExportGiftCardsInput = {
  /** Type of exported file. */
  readonly fileType: FileTypesEnum;
  /** Filtering options for gift cards. */
  readonly filter?: InputMaybe<GiftCardFilterInput>;
  /** List of gift cards IDs to export. */
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Determine which gift cards should be exported. */
  readonly scope: ExportScope;
};

export type ExportInfoInput = {
  /** List of attribute ids witch should be exported. */
  readonly attributes?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of channels ids which should be exported. */
  readonly channels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of product fields witch should be exported. */
  readonly fields?: InputMaybe<ReadonlyArray<ProductFieldEnum>>;
  /** List of warehouse ids witch should be exported. */
  readonly warehouses?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/**
 * Export products to csv file.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 *
 * Triggers the following webhook events:
 * - NOTIFY_USER (async): A notification for the exported file.
 * - PRODUCT_EXPORT_COMPLETED (async): A notification for the exported file.
 */
export type ExportProducts = {
  readonly errors: ReadonlyArray<ExportError>;
  /** @deprecated Use `errors` field instead. */
  readonly exportErrors: ReadonlyArray<ExportError>;
  /** The newly created export file job which is responsible for export data. */
  readonly exportFile?: Maybe<ExportFile>;
};

export type ExportProductsInput = {
  /** Input with info about fields which should be exported. */
  readonly exportInfo?: InputMaybe<ExportInfoInput>;
  /** Type of exported file. */
  readonly fileType: FileTypesEnum;
  /** Filtering options for products. */
  readonly filter?: InputMaybe<ProductFilterInput>;
  /** List of products IDs to export. */
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Determine which products should be exported. */
  readonly scope: ExportScope;
};

export type ExportScope =
  /** Export all products. */
  | 'ALL'
  /** Export the filtered products. */
  | 'FILTER'
  /** Export products with given ids. */
  | 'IDS';

/**
 * Export voucher codes to csv/xlsx file.
 *
 * Added in Saleor 3.18.
 *
 * Note: this API is currently in Feature Preview and can be subject to changes at later point.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_CODE_EXPORT_COMPLETED (async): A notification for the exported file.
 */
export type ExportVoucherCodes = {
  readonly errors: ReadonlyArray<ExportError>;
  /** The newly created export file job which is responsible for export data. */
  readonly exportFile?: Maybe<ExportFile>;
};

export type ExportVoucherCodesInput = {
  /** Type of exported file. */
  readonly fileType: FileTypesEnum;
  /** List of voucher code IDs to export. */
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The ID of the voucher. If provided, exports all codes belonging to the voucher. */
  readonly voucherId?: InputMaybe<Scalars['ID']['input']>;
};

/** External authentication plugin. */
export type ExternalAuthentication = {
  /** ID of external authentication plugin. */
  readonly id: Scalars['String']['output'];
  /** Name of external authentication plugin. */
  readonly name?: Maybe<Scalars['String']['output']>;
};

/** Prepare external authentication URL for user by custom plugin. */
export type ExternalAuthenticationUrl = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  /** The data returned by authentication plugin. */
  readonly authenticationData?: Maybe<Scalars['JSONString']['output']>;
  readonly errors: ReadonlyArray<AccountError>;
};

/** Logout user by custom plugin. */
export type ExternalLogout = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  /** The data returned by authentication plugin. */
  readonly logoutData?: Maybe<Scalars['JSONString']['output']>;
};

export type ExternalNotificationError = {
  /** The error code. */
  readonly code: ExternalNotificationErrorCodes;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type ExternalNotificationErrorCodes =
  | 'CHANNEL_INACTIVE'
  | 'INVALID_MODEL_TYPE'
  | 'NOT_FOUND'
  | 'REQUIRED';

/** Trigger sending a notification with the notify plugin method. Serializes nodes provided as ids parameter and includes this data in the notification payload. */
export type ExternalNotificationTrigger = {
  readonly errors: ReadonlyArray<ExternalNotificationError>;
};

export type ExternalNotificationTriggerInput = {
  /** External event type. This field is passed to a plugin as an event type. */
  readonly externalEventType: Scalars['String']['input'];
  /** Additional payload that will be merged with the one based on the business object ID. */
  readonly extraPayload?: InputMaybe<Scalars['JSONString']['input']>;
  /** The list of customers or orders node IDs that will be serialized and included in the notification payload. */
  readonly ids: ReadonlyArray<Scalars['ID']['input']>;
};

/** Obtain external access tokens for user by custom plugin. */
export type ExternalObtainAccessTokens = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  /** CSRF token required to re-generate external access token. */
  readonly csrfToken?: Maybe<Scalars['String']['output']>;
  readonly errors: ReadonlyArray<AccountError>;
  /** The refresh token, required to re-generate external access token. */
  readonly refreshToken?: Maybe<Scalars['String']['output']>;
  /** The token, required to authenticate. */
  readonly token?: Maybe<Scalars['String']['output']>;
  /** A user instance. */
  readonly user?: Maybe<User>;
};

/** Refresh user's access by custom plugin. */
export type ExternalRefresh = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  /** CSRF token required to re-generate external access token. */
  readonly csrfToken?: Maybe<Scalars['String']['output']>;
  readonly errors: ReadonlyArray<AccountError>;
  /** The refresh token, required to re-generate external access token. */
  readonly refreshToken?: Maybe<Scalars['String']['output']>;
  /** The token, required to authenticate. */
  readonly token?: Maybe<Scalars['String']['output']>;
  /** A user instance. */
  readonly user?: Maybe<User>;
};

/** Verify external authentication data by plugin. */
export type ExternalVerify = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  /** Determine if authentication data is valid or not. */
  readonly isValid: Scalars['Boolean']['output'];
  /** User assigned to data. */
  readonly user?: Maybe<User>;
  /** External data. */
  readonly verifyData?: Maybe<Scalars['JSONString']['output']>;
};

export type File = {
  /** Content type of the file. */
  readonly contentType?: Maybe<Scalars['String']['output']>;
  /** The URL of the file. */
  readonly url: Scalars['String']['output'];
};

export type FileTypesEnum =
  | 'CSV'
  | 'XLSX';

/**
 * Upload a file. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
 *
 * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
 */
export type FileUpload = {
  readonly errors: ReadonlyArray<UploadError>;
  /** @deprecated Use `errors` field instead. */
  readonly uploadErrors: ReadonlyArray<UploadError>;
  readonly uploadedFile?: Maybe<File>;
};

/** Represents order fulfillment. */
export type Fulfillment = Node & ObjectWithMetadata & {
  /** Date and time when fulfillment was created. */
  readonly created: Scalars['DateTime']['output'];
  /** Sequence in which the fulfillments were created for an order. */
  readonly fulfillmentOrder: Scalars['Int']['output'];
  /** ID of the fulfillment. */
  readonly id: Scalars['ID']['output'];
  /** List of lines for the fulfillment. */
  readonly lines?: Maybe<ReadonlyArray<FulfillmentLine>>;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Amount of refunded shipping price. */
  readonly shippingRefundedAmount?: Maybe<Money>;
  /** Status of fulfillment. */
  readonly status: FulfillmentStatus;
  /** User-friendly fulfillment status. */
  readonly statusDisplay?: Maybe<Scalars['String']['output']>;
  /** Total refunded amount assigned to this fulfillment. */
  readonly totalRefundedAmount?: Maybe<Money>;
  /** Fulfillment tracking number. */
  readonly trackingNumber: Scalars['String']['output'];
  /** Warehouse from fulfillment was fulfilled. */
  readonly warehouse?: Maybe<Warehouse>;
};


/** Represents order fulfillment. */
export type FulfillmentMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents order fulfillment. */
export type FulfillmentMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents order fulfillment. */
export type FulfillmentPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents order fulfillment. */
export type FulfillmentPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/**
 * Approve existing fulfillment.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 *
 * Triggers the following webhook events:
 * - FULFILLMENT_APPROVED (async): Fulfillment is approved.
 */
export type FulfillmentApprove = {
  readonly errors: ReadonlyArray<OrderError>;
  /** An approved fulfillment. */
  readonly fulfillment?: Maybe<Fulfillment>;
  /** Order which fulfillment was approved. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

/** Event sent when fulfillment is approved. */
export type FulfillmentApproved = Event & {
  /** The fulfillment the event relates to. */
  readonly fulfillment?: Maybe<Fulfillment>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** If true, send a notification to the customer. */
  readonly notifyCustomer: Scalars['Boolean']['output'];
  /** The order the fulfillment belongs to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Cancels existing fulfillment and optionally restocks items.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type FulfillmentCancel = {
  readonly errors: ReadonlyArray<OrderError>;
  /** A canceled fulfillment. */
  readonly fulfillment?: Maybe<Fulfillment>;
  /** Order which fulfillment was cancelled. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

export type FulfillmentCancelInput = {
  /** ID of a warehouse where items will be restocked. Optional when fulfillment is in WAITING_FOR_APPROVAL state. */
  readonly warehouseId?: InputMaybe<Scalars['ID']['input']>;
};

/** Event sent when fulfillment is canceled. */
export type FulfillmentCanceled = Event & {
  /** The fulfillment the event relates to. */
  readonly fulfillment?: Maybe<Fulfillment>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the fulfillment belongs to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Event sent when new fulfillment is created. */
export type FulfillmentCreated = Event & {
  /** The fulfillment the event relates to. */
  readonly fulfillment?: Maybe<Fulfillment>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** If true, the app should send a notification to the customer. */
  readonly notifyCustomer: Scalars['Boolean']['output'];
  /** The order the fulfillment belongs to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Filter input for order fulfillments data. */
export type FulfillmentFilterInput = {
  /** Filter by metadata fields. */
  readonly metadata?: InputMaybe<MetadataFilterInput>;
  /** Filter by fulfillment status. */
  readonly status?: InputMaybe<FulfillmentStatusEnumFilterInput>;
  /** Filter by fulfillment warehouse. */
  readonly warehouse?: InputMaybe<FulfillmentWarehouseFilterInput>;
};

/** Represents line of the fulfillment. */
export type FulfillmentLine = Node & {
  /** ID of the fulfillment line. */
  readonly id: Scalars['ID']['output'];
  /** The order line to which the fulfillment line is related. */
  readonly orderLine?: Maybe<OrderLine>;
  /** The number of items included in the fulfillment line. */
  readonly quantity: Scalars['Int']['output'];
};

/** Event sent when fulfillment metadata is updated. */
export type FulfillmentMetadataUpdated = Event & {
  /** The fulfillment the event relates to. */
  readonly fulfillment?: Maybe<Fulfillment>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the fulfillment belongs to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Refund products.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type FulfillmentRefundProducts = {
  readonly errors: ReadonlyArray<OrderError>;
  /** A refunded fulfillment. */
  readonly fulfillment?: Maybe<Fulfillment>;
  /** Order which fulfillment was refunded. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

/**
 * Return products.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type FulfillmentReturnProducts = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Order which fulfillment was returned. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
  /** A replace fulfillment. */
  readonly replaceFulfillment?: Maybe<Fulfillment>;
  /** A draft order which was created for products with replace flag. */
  readonly replaceOrder?: Maybe<Order>;
  /** A return fulfillment. */
  readonly returnFulfillment?: Maybe<Fulfillment>;
};

export type FulfillmentStatus =
  | 'CANCELED'
  | 'FULFILLED'
  | 'REFUNDED'
  | 'REFUNDED_AND_RETURNED'
  | 'REPLACED'
  | 'RETURNED'
  | 'WAITING_FOR_APPROVAL';

/** Filter by fulfillment status. */
export type FulfillmentStatusEnumFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<FulfillmentStatus>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<FulfillmentStatus>>;
};

/** Event sent when the tracking number is updated. */
export type FulfillmentTrackingNumberUpdated = Event & {
  /** The fulfillment the event relates to. */
  readonly fulfillment?: Maybe<Fulfillment>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the fulfillment belongs to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Updates a fulfillment for an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 *
 * Triggers the following webhook events:
 * - FULFILLMENT_TRACKING_NUMBER_UPDATED (async): Fulfillment tracking number is updated.
 */
export type FulfillmentUpdateTracking = {
  readonly errors: ReadonlyArray<OrderError>;
  /** A fulfillment with updated tracking. */
  readonly fulfillment?: Maybe<Fulfillment>;
  /** Order for which fulfillment was updated. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

export type FulfillmentUpdateTrackingInput = {
  /** If true, send an email notification to the customer. */
  readonly notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  /** Fulfillment tracking number. */
  readonly trackingNumber?: InputMaybe<Scalars['String']['input']>;
};

/** Filter input for fulfillment warehouses. */
export type FulfillmentWarehouseFilterInput = {
  /** Filter fulfillments by warehouse external reference. */
  readonly externalReference?: InputMaybe<StringFilterInput>;
  /** Filter fulfillments by warehouse ID. */
  readonly id?: InputMaybe<GlobalIdFilterInput>;
  /** Filter fulfillments by warehouse slug. */
  readonly slug?: InputMaybe<StringFilterInput>;
};

/** Payment gateway client configuration key and value pair. */
export type GatewayConfigLine = {
  /** Gateway config key. */
  readonly field: Scalars['String']['output'];
  /** Gateway config value for key. */
  readonly value?: Maybe<Scalars['String']['output']>;
};

/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCard = Node & ObjectWithMetadata & {
  /**
   * App which created the gift card.
   *
   * Requires one of the following permissions: MANAGE_APPS, OWNER.
   */
  readonly app?: Maybe<App>;
  /** Slug of the channel where the gift card was bought. */
  readonly boughtInChannel?: Maybe<Scalars['String']['output']>;
  /**
   * Gift card code. It can be fetched both by a staff member with 'MANAGE_GIFT_CARD' when gift card hasn't been used yet or a user who bought or issued the gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD, OWNER.
   */
  readonly code: Scalars['String']['output'];
  /** Date and time when gift card was created. */
  readonly created: Scalars['DateTime']['output'];
  /** The user who bought or issued a gift card. */
  readonly createdBy?: Maybe<User>;
  /**
   * Email address of the user who bought or issued gift card.
   *
   * Requires one of the following permissions: MANAGE_USERS, OWNER.
   */
  readonly createdByEmail?: Maybe<Scalars['String']['output']>;
  readonly currentBalance: Money;
  /** Code in format which allows displaying in a user interface. */
  readonly displayCode: Scalars['String']['output'];
  /**
   * End date of gift card.
   * @deprecated Use `expiryDate` field instead.
   */
  readonly endDate?: Maybe<Scalars['DateTime']['output']>;
  /**
   * List of events associated with the gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  readonly events: ReadonlyArray<GiftCardEvent>;
  /** Expiry date of the gift card. */
  readonly expiryDate?: Maybe<Scalars['Date']['output']>;
  /** ID of the gift card. */
  readonly id: Scalars['ID']['output'];
  readonly initialBalance: Money;
  readonly isActive: Scalars['Boolean']['output'];
  /** Last 4 characters of gift card code. */
  readonly last4CodeChars: Scalars['String']['output'];
  /** Date and time when gift card was last used. */
  readonly lastUsedOn?: Maybe<Scalars['DateTime']['output']>;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Related gift card product. */
  readonly product?: Maybe<Product>;
  /**
   * Start date of gift card.
   * @deprecated Field no longer supported
   */
  readonly startDate?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The gift card tag.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  readonly tags: ReadonlyArray<GiftCardTag>;
  /**
   * The customer who used a gift card.
   * @deprecated Field no longer supported
   */
  readonly usedBy?: Maybe<User>;
  /**
   * Email address of the customer who used a gift card.
   * @deprecated Field no longer supported
   */
  readonly usedByEmail?: Maybe<Scalars['String']['output']>;
  /**
   * The customer who bought a gift card.
   * @deprecated Use `createdBy` field instead.
   */
  readonly user?: Maybe<User>;
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardEventsArgs = {
  filter?: InputMaybe<GiftCardEventFilterInput>;
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/**
 * Activate a gift card.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_STATUS_CHANGED (async): A gift card was activated.
 */
export type GiftCardActivate = {
  readonly errors: ReadonlyArray<GiftCardError>;
  /** Activated gift card. */
  readonly giftCard?: Maybe<GiftCard>;
  /** @deprecated Use `errors` field instead. */
  readonly giftCardErrors: ReadonlyArray<GiftCardError>;
};

/**
 * Adds note to the gift card.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_UPDATED (async): A gift card was updated.
 */
export type GiftCardAddNote = {
  readonly errors: ReadonlyArray<GiftCardError>;
  /** Gift card note created. */
  readonly event?: Maybe<GiftCardEvent>;
  /** Gift card with the note added. */
  readonly giftCard?: Maybe<GiftCard>;
};

export type GiftCardAddNoteInput = {
  /** Note message. */
  readonly message: Scalars['String']['input'];
};

/**
 * Activate gift cards.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_STATUS_CHANGED (async): A gift card was activated.
 */
export type GiftCardBulkActivate = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<GiftCardError>;
};

/**
 * Creates gift cards.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_CREATED (async): A gift card was created.
 * - NOTIFY_USER (async): A notification for created gift card.
 */
export type GiftCardBulkCreate = {
  /** Returns how many objects were created. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<GiftCardError>;
  /** List of created gift cards. */
  readonly giftCards: ReadonlyArray<GiftCard>;
};

export type GiftCardBulkCreateInput = {
  /** Balance of the gift card. */
  readonly balance: PriceInput;
  /** The number of cards to issue. */
  readonly count: Scalars['Int']['input'];
  /** The gift card expiry date. */
  readonly expiryDate?: InputMaybe<Scalars['Date']['input']>;
  /** Determine if gift card is active. */
  readonly isActive: Scalars['Boolean']['input'];
  /** The gift card tags. */
  readonly tags?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/**
 * Deactivate gift cards.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_STATUS_CHANGED (async): A gift card was deactivated.
 */
export type GiftCardBulkDeactivate = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<GiftCardError>;
};

/**
 * Deletes gift cards.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_DELETED (async): A gift card was deleted.
 */
export type GiftCardBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<GiftCardError>;
};

export type GiftCardCountableConnection = {
  readonly edges: ReadonlyArray<GiftCardCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type GiftCardCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: GiftCard;
};

/**
 * Creates a new gift card.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_CREATED (async): A gift card was created.
 * - NOTIFY_USER (async): A notification for created gift card.
 */
export type GiftCardCreate = {
  readonly errors: ReadonlyArray<GiftCardError>;
  readonly giftCard?: Maybe<GiftCard>;
  /** @deprecated Use `errors` field instead. */
  readonly giftCardErrors: ReadonlyArray<GiftCardError>;
};

export type GiftCardCreateInput = {
  /** The gift card tags to add. */
  readonly addTags?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** Balance of the gift card. */
  readonly balance: PriceInput;
  /** Slug of a channel from which the email should be sent. */
  readonly channel?: InputMaybe<Scalars['String']['input']>;
  /**
   * Code to use the gift card.
   * @deprecated The code is now auto generated.
   */
  readonly code?: InputMaybe<Scalars['String']['input']>;
  /**
   * End date of the gift card in ISO 8601 format.
   * @deprecated Use `expiryDate` from `expirySettings` instead.
   */
  readonly endDate?: InputMaybe<Scalars['Date']['input']>;
  /** The gift card expiry date. */
  readonly expiryDate?: InputMaybe<Scalars['Date']['input']>;
  /** Determine if gift card is active. */
  readonly isActive: Scalars['Boolean']['input'];
  /**
   * Gift Card public metadata.
   *
   * Added in Saleor 3.21. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** The gift card note from the staff member. */
  readonly note?: InputMaybe<Scalars['String']['input']>;
  /**
   * Gift Card private metadata.
   *
   * Added in Saleor 3.21. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /**
   * Start date of the gift card in ISO 8601 format.
   * @deprecated Field no longer supported
   */
  readonly startDate?: InputMaybe<Scalars['Date']['input']>;
  /** Email of the customer to whom gift card will be sent. */
  readonly userEmail?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when new gift card is created. */
export type GiftCardCreated = Event & {
  /** The gift card the event relates to. */
  readonly giftCard?: Maybe<GiftCard>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Deactivate a gift card.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_STATUS_CHANGED (async): A gift card was deactivated.
 */
export type GiftCardDeactivate = {
  readonly errors: ReadonlyArray<GiftCardError>;
  /** Deactivated gift card. */
  readonly giftCard?: Maybe<GiftCard>;
  /** @deprecated Use `errors` field instead. */
  readonly giftCardErrors: ReadonlyArray<GiftCardError>;
};

/**
 * Deletes gift card.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_DELETED (async): A gift card was deleted.
 */
export type GiftCardDelete = {
  readonly errors: ReadonlyArray<GiftCardError>;
  readonly giftCard?: Maybe<GiftCard>;
  /** @deprecated Use `errors` field instead. */
  readonly giftCardErrors: ReadonlyArray<GiftCardError>;
};

/** Event sent when gift card is deleted. */
export type GiftCardDeleted = Event & {
  /** The gift card the event relates to. */
  readonly giftCard?: Maybe<GiftCard>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type GiftCardError = {
  /** The error code. */
  readonly code: GiftCardErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of tag values that cause the error. */
  readonly tags?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
};

export type GiftCardErrorCode =
  | 'ALREADY_EXISTS'
  | 'DUPLICATED_INPUT_ITEM'
  | 'EXPIRED_GIFT_CARD'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

/** History log of the gift card. */
export type GiftCardEvent = Node & {
  /** App that performed the action. Requires one of the following permissions: MANAGE_APPS, OWNER. */
  readonly app?: Maybe<App>;
  /** The gift card balance. */
  readonly balance?: Maybe<GiftCardEventBalance>;
  /** Date when event happened at in ISO 8601 format. */
  readonly date?: Maybe<Scalars['DateTime']['output']>;
  /** Email of the customer. */
  readonly email?: Maybe<Scalars['String']['output']>;
  /** The gift card expiry date. */
  readonly expiryDate?: Maybe<Scalars['Date']['output']>;
  /** ID of the event associated with a gift card. */
  readonly id: Scalars['ID']['output'];
  /** Content of the event. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Previous gift card expiry date. */
  readonly oldExpiryDate?: Maybe<Scalars['Date']['output']>;
  /** The list of old gift card tags. */
  readonly oldTags?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
  /** The order ID where gift card was used or bought. */
  readonly orderId?: Maybe<Scalars['ID']['output']>;
  /** User-friendly number of an order where gift card was used or bought. */
  readonly orderNumber?: Maybe<Scalars['String']['output']>;
  /** The list of gift card tags. */
  readonly tags?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
  /** Gift card event type. */
  readonly type?: Maybe<GiftCardEventsEnum>;
  /** User who performed the action. Requires one of the following permissions: MANAGE_USERS, MANAGE_STAFF, OWNER. */
  readonly user?: Maybe<User>;
};

export type GiftCardEventBalance = {
  /** Current balance of the gift card. */
  readonly currentBalance: Money;
  /** Initial balance of the gift card. */
  readonly initialBalance?: Maybe<Money>;
  /** Previous current balance of the gift card. */
  readonly oldCurrentBalance?: Maybe<Money>;
  /** Previous initial balance of the gift card. */
  readonly oldInitialBalance?: Maybe<Money>;
};

export type GiftCardEventFilterInput = {
  readonly orders?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly type?: InputMaybe<GiftCardEventsEnum>;
};

export type GiftCardEventsEnum =
  | 'ACTIVATED'
  | 'BALANCE_RESET'
  | 'BOUGHT'
  | 'DEACTIVATED'
  | 'EXPIRY_DATE_UPDATED'
  | 'ISSUED'
  | 'NOTE_ADDED'
  | 'RESENT'
  | 'SENT_TO_CUSTOMER'
  | 'TAGS_UPDATED'
  | 'UPDATED'
  | 'USED_IN_ORDER';

/** Event sent when gift card export is completed. */
export type GiftCardExportCompleted = Event & {
  /** The export file for gift cards. */
  readonly export?: Maybe<ExportFile>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type GiftCardFilterInput = {
  readonly code?: InputMaybe<Scalars['String']['input']>;
  readonly createdByEmail?: InputMaybe<Scalars['String']['input']>;
  readonly currency?: InputMaybe<Scalars['String']['input']>;
  readonly currentBalance?: InputMaybe<PriceRangeInput>;
  readonly initialBalance?: InputMaybe<PriceRangeInput>;
  readonly isActive?: InputMaybe<Scalars['Boolean']['input']>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly products?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly tags?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly used?: InputMaybe<Scalars['Boolean']['input']>;
  readonly usedBy?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/** Event sent when gift card metadata is updated. */
export type GiftCardMetadataUpdated = Event & {
  /** The gift card the event relates to. */
  readonly giftCard?: Maybe<GiftCard>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Resend a gift card.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - NOTIFY_USER (async): A notification for gift card resend.
 */
export type GiftCardResend = {
  readonly errors: ReadonlyArray<GiftCardError>;
  /** Gift card which has been sent. */
  readonly giftCard?: Maybe<GiftCard>;
};

export type GiftCardResendInput = {
  /** Slug of a channel from which the email should be sent. */
  readonly channel: Scalars['String']['input'];
  /** Email to which gift card should be send. */
  readonly email?: InputMaybe<Scalars['String']['input']>;
  /** ID of a gift card to resend. */
  readonly id: Scalars['ID']['input'];
};

/** Event sent when gift card is e-mailed. */
export type GiftCardSent = Event & {
  /** Slug of a channel for which this gift card email was sent. */
  readonly channel?: Maybe<Scalars['String']['output']>;
  /** The gift card the event relates to. */
  readonly giftCard?: Maybe<GiftCard>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** E-mail address to which gift card was sent. */
  readonly sentToEmail?: Maybe<Scalars['String']['output']>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Gift card related settings from site settings. */
export type GiftCardSettings = {
  /** The gift card expiry period settings. */
  readonly expiryPeriod?: Maybe<TimePeriod>;
  /** The gift card expiry type settings. */
  readonly expiryType: GiftCardSettingsExpiryTypeEnum;
};

export type GiftCardSettingsError = {
  /** The error code. */
  readonly code: GiftCardSettingsErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type GiftCardSettingsErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'REQUIRED';

export type GiftCardSettingsExpiryTypeEnum =
  | 'EXPIRY_PERIOD'
  | 'NEVER_EXPIRE';

/**
 * Update gift card settings.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 */
export type GiftCardSettingsUpdate = {
  readonly errors: ReadonlyArray<GiftCardSettingsError>;
  /** Gift card settings. */
  readonly giftCardSettings?: Maybe<GiftCardSettings>;
};

export type GiftCardSettingsUpdateInput = {
  /** Defines gift card expiry period. */
  readonly expiryPeriod?: InputMaybe<TimePeriodInputType>;
  /** Defines gift card default expiry settings. */
  readonly expiryType?: InputMaybe<GiftCardSettingsExpiryTypeEnum>;
};

export type GiftCardSortField =
  /** Sort gift cards by created at. */
  | 'CREATED_AT'
  /** Sort gift cards by current balance. */
  | 'CURRENT_BALANCE'
  /** Sort gift cards by product. */
  | 'PRODUCT'
  /** Sort gift cards by used by. */
  | 'USED_BY';

export type GiftCardSortingInput = {
  /** Specifies the direction in which to sort gift cards. */
  readonly direction: OrderDirection;
  /** Sort gift cards by the selected field. */
  readonly field: GiftCardSortField;
};

/** Event sent when gift card status has changed. */
export type GiftCardStatusChanged = Event & {
  /** The gift card the event relates to. */
  readonly giftCard?: Maybe<GiftCard>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** The gift card tag. */
export type GiftCardTag = Node & {
  /** ID of the tag associated with a gift card. */
  readonly id: Scalars['ID']['output'];
  /** Name of the tag associated with a gift card. */
  readonly name: Scalars['String']['output'];
};

export type GiftCardTagCountableConnection = {
  readonly edges: ReadonlyArray<GiftCardTagCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type GiftCardTagCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: GiftCardTag;
};

export type GiftCardTagFilterInput = {
  readonly search?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Update a gift card.
 *
 * Requires one of the following permissions: MANAGE_GIFT_CARD.
 *
 * Triggers the following webhook events:
 * - GIFT_CARD_UPDATED (async): A gift card was updated.
 */
export type GiftCardUpdate = {
  readonly errors: ReadonlyArray<GiftCardError>;
  readonly giftCard?: Maybe<GiftCard>;
  /** @deprecated Use `errors` field instead. */
  readonly giftCardErrors: ReadonlyArray<GiftCardError>;
};

export type GiftCardUpdateInput = {
  /** The gift card tags to add. */
  readonly addTags?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** The gift card balance amount. */
  readonly balanceAmount?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /**
   * End date of the gift card in ISO 8601 format.
   * @deprecated Use `expiryDate` from `expirySettings` instead.
   */
  readonly endDate?: InputMaybe<Scalars['Date']['input']>;
  /** The gift card expiry date. */
  readonly expiryDate?: InputMaybe<Scalars['Date']['input']>;
  /**
   * Gift Card public metadata.
   *
   * Added in Saleor 3.21. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /**
   * Gift Card private metadata.
   *
   * Added in Saleor 3.21. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** The gift card tags to remove. */
  readonly removeTags?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /**
   * Start date of the gift card in ISO 8601 format.
   * @deprecated Field no longer supported
   */
  readonly startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** Event sent when gift card is updated. */
export type GiftCardUpdated = Event & {
  /** The gift card the event relates to. */
  readonly giftCard?: Maybe<GiftCard>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Define the filtering options for foreign key fields. */
export type GlobalIdFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<Scalars['ID']['input']>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/** Represents permission group data. */
export type Group = Node & {
  /** List of channels the group has access to. */
  readonly accessibleChannels?: Maybe<ReadonlyArray<Channel>>;
  /** The ID of the group. */
  readonly id: Scalars['ID']['output'];
  /** The name of the group. */
  readonly name: Scalars['String']['output'];
  /** List of group permissions */
  readonly permissions?: Maybe<ReadonlyArray<Permission>>;
  /** Determine if the group have restricted access to channels. */
  readonly restrictedAccessToChannels: Scalars['Boolean']['output'];
  /** True, if the currently authenticated user has rights to manage a group. */
  readonly userCanManage: Scalars['Boolean']['output'];
  /**
   * List of group users
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   */
  readonly users?: Maybe<ReadonlyArray<User>>;
};

export type GroupCountableConnection = {
  readonly edges: ReadonlyArray<GroupCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type GroupCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Group;
};

export type HttpMethod =
  | 'GET'
  | 'POST';

/** Thumbnail formats for icon images. */
export type IconThumbnailFormatEnum =
  | 'ORIGINAL'
  | 'WEBP';

/** Represents an image. */
export type Image = {
  /** Alt text for an image. */
  readonly alt?: Maybe<Scalars['String']['output']>;
  /** The URL of the image. */
  readonly url: Scalars['String']['output'];
};

/** Define the filtering options for integer fields. */
export type IntFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<Scalars['Int']['input']>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<Scalars['Int']['input']>>;
  /** The value in range. */
  readonly range?: InputMaybe<IntRangeInput>;
};

export type IntRangeInput = {
  /** Value greater than or equal to. */
  readonly gte?: InputMaybe<Scalars['Int']['input']>;
  /** Value less than or equal to. */
  readonly lte?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an Invoice. */
export type Invoice = Job & Node & ObjectWithMetadata & {
  /** Date and time at which invoice was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /**
   * URL to view an invoice.
   * @deprecated Use `url` field.
   */
  readonly externalUrl?: Maybe<Scalars['String']['output']>;
  /** The ID of the object. */
  readonly id: Scalars['ID']['output'];
  /** Message associated with an invoice. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Invoice number. */
  readonly number?: Maybe<Scalars['String']['output']>;
  /** Order related to the invoice. */
  readonly order?: Maybe<Order>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Job status. */
  readonly status: JobStatusEnum;
  /** Date and time at which invoice was updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** URL to view/download an invoice. */
  readonly url?: Maybe<Scalars['String']['output']>;
};


/** Represents an Invoice. */
export type InvoiceMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents an Invoice. */
export type InvoiceMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents an Invoice. */
export type InvoicePrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents an Invoice. */
export type InvoicePrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/**
 * Creates a ready to send invoice.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type InvoiceCreate = {
  readonly errors: ReadonlyArray<InvoiceError>;
  readonly invoice?: Maybe<Invoice>;
  /** @deprecated Use `errors` field instead. */
  readonly invoiceErrors: ReadonlyArray<InvoiceError>;
};

export type InvoiceCreateInput = {
  /**
   * Fields required to update the invoice metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Invoice number. */
  readonly number: Scalars['String']['input'];
  /**
   * Fields required to update the invoice private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** URL of an invoice to download. */
  readonly url: Scalars['String']['input'];
};

/**
 * Deletes an invoice.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type InvoiceDelete = {
  readonly errors: ReadonlyArray<InvoiceError>;
  readonly invoice?: Maybe<Invoice>;
  /** @deprecated Use `errors` field instead. */
  readonly invoiceErrors: ReadonlyArray<InvoiceError>;
};

/** Event sent when invoice is deleted. */
export type InvoiceDeleted = Event & {
  /** The invoice the event relates to. */
  readonly invoice?: Maybe<Invoice>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** Order related to the invoice. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type InvoiceError = {
  /** The error code. */
  readonly code: InvoiceErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type InvoiceErrorCode =
  | 'EMAIL_NOT_SET'
  | 'INVALID_STATUS'
  | 'NOT_FOUND'
  | 'NOT_READY'
  | 'NO_INVOICE_PLUGIN'
  | 'NUMBER_NOT_SET'
  | 'REQUIRED'
  | 'URL_NOT_SET';

/** Filter input for invoices. */
export type InvoiceFilterInput = {
  /** Filter invoices by creation date. */
  readonly createdAt?: InputMaybe<DateTimeRangeInput>;
};

/**
 * Request an invoice for the order using plugin.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 *
 * Triggers the following webhook events:
 * - INVOICE_REQUESTED (async): An invoice was requested.
 */
export type InvoiceRequest = {
  readonly errors: ReadonlyArray<InvoiceError>;
  readonly invoice?: Maybe<Invoice>;
  /** @deprecated Use `errors` field instead. */
  readonly invoiceErrors: ReadonlyArray<InvoiceError>;
  /** Order related to an invoice. */
  readonly order?: Maybe<Order>;
};

/**
 * Requests deletion of an invoice.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 *
 * Triggers the following webhook events:
 * - INVOICE_DELETED (async): An invoice was requested to delete.
 */
export type InvoiceRequestDelete = {
  readonly errors: ReadonlyArray<InvoiceError>;
  readonly invoice?: Maybe<Invoice>;
  /** @deprecated Use `errors` field instead. */
  readonly invoiceErrors: ReadonlyArray<InvoiceError>;
};

/** Event sent when invoice is requested. */
export type InvoiceRequested = Event & {
  /** The invoice the event relates to. */
  readonly invoice?: Maybe<Invoice>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** Order related to the invoice. */
  readonly order: Order;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Send an invoice notification to the customer.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 *
 * Triggers the following webhook events:
 * - INVOICE_SENT (async): A notification for invoice send
 * - NOTIFY_USER (async): A notification for invoice send
 */
export type InvoiceSendNotification = {
  readonly errors: ReadonlyArray<InvoiceError>;
  readonly invoice?: Maybe<Invoice>;
  /** @deprecated Use `errors` field instead. */
  readonly invoiceErrors: ReadonlyArray<InvoiceError>;
};

/** Event sent when invoice is sent. */
export type InvoiceSent = Event & {
  /** The invoice the event relates to. */
  readonly invoice?: Maybe<Invoice>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** Order related to the invoice. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Updates an invoice.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type InvoiceUpdate = {
  readonly errors: ReadonlyArray<InvoiceError>;
  readonly invoice?: Maybe<Invoice>;
  /** @deprecated Use `errors` field instead. */
  readonly invoiceErrors: ReadonlyArray<InvoiceError>;
};

export type IssuingPrincipal = App | User;

export type Job = {
  /** Created date time of job in ISO 8601 format. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Job message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Job status. */
  readonly status: JobStatusEnum;
  /** Date time of job last update in ISO 8601 format. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

export type JobStatusEnum =
  | 'DELETED'
  | 'FAILED'
  | 'PENDING'
  | 'SUCCESS';

export type LanguageCodeEnum =
  | 'AF'
  | 'AF_NA'
  | 'AF_ZA'
  | 'AGQ'
  | 'AGQ_CM'
  | 'AK'
  | 'AK_GH'
  | 'AM'
  | 'AM_ET'
  | 'AR'
  | 'AR_AE'
  | 'AR_BH'
  | 'AR_DJ'
  | 'AR_DZ'
  | 'AR_EG'
  | 'AR_EH'
  | 'AR_ER'
  | 'AR_IL'
  | 'AR_IQ'
  | 'AR_JO'
  | 'AR_KM'
  | 'AR_KW'
  | 'AR_LB'
  | 'AR_LY'
  | 'AR_MA'
  | 'AR_MR'
  | 'AR_OM'
  | 'AR_PS'
  | 'AR_QA'
  | 'AR_SA'
  | 'AR_SD'
  | 'AR_SO'
  | 'AR_SS'
  | 'AR_SY'
  | 'AR_TD'
  | 'AR_TN'
  | 'AR_YE'
  | 'AS'
  | 'ASA'
  | 'ASA_TZ'
  | 'AST'
  | 'AST_ES'
  | 'AS_IN'
  | 'AZ'
  | 'AZ_CYRL'
  | 'AZ_CYRL_AZ'
  | 'AZ_LATN'
  | 'AZ_LATN_AZ'
  | 'BAS'
  | 'BAS_CM'
  | 'BE'
  | 'BEM'
  | 'BEM_ZM'
  | 'BEZ'
  | 'BEZ_TZ'
  | 'BE_BY'
  | 'BG'
  | 'BG_BG'
  | 'BM'
  | 'BM_ML'
  | 'BN'
  | 'BN_BD'
  | 'BN_IN'
  | 'BO'
  | 'BO_CN'
  | 'BO_IN'
  | 'BR'
  | 'BRX'
  | 'BRX_IN'
  | 'BR_FR'
  | 'BS'
  | 'BS_CYRL'
  | 'BS_CYRL_BA'
  | 'BS_LATN'
  | 'BS_LATN_BA'
  | 'CA'
  | 'CA_AD'
  | 'CA_ES'
  | 'CA_ES_VALENCIA'
  | 'CA_FR'
  | 'CA_IT'
  | 'CCP'
  | 'CCP_BD'
  | 'CCP_IN'
  | 'CE'
  | 'CEB'
  | 'CEB_PH'
  | 'CE_RU'
  | 'CGG'
  | 'CGG_UG'
  | 'CHR'
  | 'CHR_US'
  | 'CKB'
  | 'CKB_IQ'
  | 'CKB_IR'
  | 'CS'
  | 'CS_CZ'
  | 'CU'
  | 'CU_RU'
  | 'CY'
  | 'CY_GB'
  | 'DA'
  | 'DAV'
  | 'DAV_KE'
  | 'DA_DK'
  | 'DA_GL'
  | 'DE'
  | 'DE_AT'
  | 'DE_BE'
  | 'DE_CH'
  | 'DE_DE'
  | 'DE_IT'
  | 'DE_LI'
  | 'DE_LU'
  | 'DJE'
  | 'DJE_NE'
  | 'DSB'
  | 'DSB_DE'
  | 'DUA'
  | 'DUA_CM'
  | 'DYO'
  | 'DYO_SN'
  | 'DZ'
  | 'DZ_BT'
  | 'EBU'
  | 'EBU_KE'
  | 'EE'
  | 'EE_GH'
  | 'EE_TG'
  | 'EL'
  | 'EL_CY'
  | 'EL_GR'
  | 'EN'
  | 'EN_AE'
  | 'EN_AG'
  | 'EN_AI'
  | 'EN_AS'
  | 'EN_AT'
  | 'EN_AU'
  | 'EN_BB'
  | 'EN_BE'
  | 'EN_BI'
  | 'EN_BM'
  | 'EN_BS'
  | 'EN_BW'
  | 'EN_BZ'
  | 'EN_CA'
  | 'EN_CC'
  | 'EN_CH'
  | 'EN_CK'
  | 'EN_CM'
  | 'EN_CX'
  | 'EN_CY'
  | 'EN_DE'
  | 'EN_DG'
  | 'EN_DK'
  | 'EN_DM'
  | 'EN_ER'
  | 'EN_FI'
  | 'EN_FJ'
  | 'EN_FK'
  | 'EN_FM'
  | 'EN_GB'
  | 'EN_GD'
  | 'EN_GG'
  | 'EN_GH'
  | 'EN_GI'
  | 'EN_GM'
  | 'EN_GU'
  | 'EN_GY'
  | 'EN_HK'
  | 'EN_IE'
  | 'EN_IL'
  | 'EN_IM'
  | 'EN_IN'
  | 'EN_IO'
  | 'EN_JE'
  | 'EN_JM'
  | 'EN_KE'
  | 'EN_KI'
  | 'EN_KN'
  | 'EN_KY'
  | 'EN_LC'
  | 'EN_LR'
  | 'EN_LS'
  | 'EN_MG'
  | 'EN_MH'
  | 'EN_MO'
  | 'EN_MP'
  | 'EN_MS'
  | 'EN_MT'
  | 'EN_MU'
  | 'EN_MW'
  | 'EN_MY'
  | 'EN_NA'
  | 'EN_NF'
  | 'EN_NG'
  | 'EN_NL'
  | 'EN_NR'
  | 'EN_NU'
  | 'EN_NZ'
  | 'EN_PG'
  | 'EN_PH'
  | 'EN_PK'
  | 'EN_PN'
  | 'EN_PR'
  | 'EN_PW'
  | 'EN_RW'
  | 'EN_SB'
  | 'EN_SC'
  | 'EN_SD'
  | 'EN_SE'
  | 'EN_SG'
  | 'EN_SH'
  | 'EN_SI'
  | 'EN_SL'
  | 'EN_SS'
  | 'EN_SX'
  | 'EN_SZ'
  | 'EN_TC'
  | 'EN_TK'
  | 'EN_TO'
  | 'EN_TT'
  | 'EN_TV'
  | 'EN_TZ'
  | 'EN_UG'
  | 'EN_UM'
  | 'EN_US'
  | 'EN_VC'
  | 'EN_VG'
  | 'EN_VI'
  | 'EN_VU'
  | 'EN_WS'
  | 'EN_ZA'
  | 'EN_ZM'
  | 'EN_ZW'
  | 'EO'
  | 'ES'
  | 'ES_AR'
  | 'ES_BO'
  | 'ES_BR'
  | 'ES_BZ'
  | 'ES_CL'
  | 'ES_CO'
  | 'ES_CR'
  | 'ES_CU'
  | 'ES_DO'
  | 'ES_EA'
  | 'ES_EC'
  | 'ES_ES'
  | 'ES_GQ'
  | 'ES_GT'
  | 'ES_HN'
  | 'ES_IC'
  | 'ES_MX'
  | 'ES_NI'
  | 'ES_PA'
  | 'ES_PE'
  | 'ES_PH'
  | 'ES_PR'
  | 'ES_PY'
  | 'ES_SV'
  | 'ES_US'
  | 'ES_UY'
  | 'ES_VE'
  | 'ET'
  | 'ET_EE'
  | 'EU'
  | 'EU_ES'
  | 'EWO'
  | 'EWO_CM'
  | 'FA'
  | 'FA_AF'
  | 'FA_IR'
  | 'FF'
  | 'FF_ADLM'
  | 'FF_ADLM_BF'
  | 'FF_ADLM_CM'
  | 'FF_ADLM_GH'
  | 'FF_ADLM_GM'
  | 'FF_ADLM_GN'
  | 'FF_ADLM_GW'
  | 'FF_ADLM_LR'
  | 'FF_ADLM_MR'
  | 'FF_ADLM_NE'
  | 'FF_ADLM_NG'
  | 'FF_ADLM_SL'
  | 'FF_ADLM_SN'
  | 'FF_LATN'
  | 'FF_LATN_BF'
  | 'FF_LATN_CM'
  | 'FF_LATN_GH'
  | 'FF_LATN_GM'
  | 'FF_LATN_GN'
  | 'FF_LATN_GW'
  | 'FF_LATN_LR'
  | 'FF_LATN_MR'
  | 'FF_LATN_NE'
  | 'FF_LATN_NG'
  | 'FF_LATN_SL'
  | 'FF_LATN_SN'
  | 'FI'
  | 'FIL'
  | 'FIL_PH'
  | 'FI_FI'
  | 'FO'
  | 'FO_DK'
  | 'FO_FO'
  | 'FR'
  | 'FR_BE'
  | 'FR_BF'
  | 'FR_BI'
  | 'FR_BJ'
  | 'FR_BL'
  | 'FR_CA'
  | 'FR_CD'
  | 'FR_CF'
  | 'FR_CG'
  | 'FR_CH'
  | 'FR_CI'
  | 'FR_CM'
  | 'FR_DJ'
  | 'FR_DZ'
  | 'FR_FR'
  | 'FR_GA'
  | 'FR_GF'
  | 'FR_GN'
  | 'FR_GP'
  | 'FR_GQ'
  | 'FR_HT'
  | 'FR_KM'
  | 'FR_LU'
  | 'FR_MA'
  | 'FR_MC'
  | 'FR_MF'
  | 'FR_MG'
  | 'FR_ML'
  | 'FR_MQ'
  | 'FR_MR'
  | 'FR_MU'
  | 'FR_NC'
  | 'FR_NE'
  | 'FR_PF'
  | 'FR_PM'
  | 'FR_RE'
  | 'FR_RW'
  | 'FR_SC'
  | 'FR_SN'
  | 'FR_SY'
  | 'FR_TD'
  | 'FR_TG'
  | 'FR_TN'
  | 'FR_VU'
  | 'FR_WF'
  | 'FR_YT'
  | 'FUR'
  | 'FUR_IT'
  | 'FY'
  | 'FY_NL'
  | 'GA'
  | 'GA_GB'
  | 'GA_IE'
  | 'GD'
  | 'GD_GB'
  | 'GL'
  | 'GL_ES'
  | 'GSW'
  | 'GSW_CH'
  | 'GSW_FR'
  | 'GSW_LI'
  | 'GU'
  | 'GUZ'
  | 'GUZ_KE'
  | 'GU_IN'
  | 'GV'
  | 'GV_IM'
  | 'HA'
  | 'HAW'
  | 'HAW_US'
  | 'HA_GH'
  | 'HA_NE'
  | 'HA_NG'
  | 'HE'
  | 'HE_IL'
  | 'HI'
  | 'HI_IN'
  | 'HR'
  | 'HR_BA'
  | 'HR_HR'
  | 'HSB'
  | 'HSB_DE'
  | 'HU'
  | 'HU_HU'
  | 'HY'
  | 'HY_AM'
  | 'IA'
  | 'ID'
  | 'ID_ID'
  | 'IG'
  | 'IG_NG'
  | 'II'
  | 'II_CN'
  | 'IS'
  | 'IS_IS'
  | 'IT'
  | 'IT_CH'
  | 'IT_IT'
  | 'IT_SM'
  | 'IT_VA'
  | 'JA'
  | 'JA_JP'
  | 'JGO'
  | 'JGO_CM'
  | 'JMC'
  | 'JMC_TZ'
  | 'JV'
  | 'JV_ID'
  | 'KA'
  | 'KAB'
  | 'KAB_DZ'
  | 'KAM'
  | 'KAM_KE'
  | 'KA_GE'
  | 'KDE'
  | 'KDE_TZ'
  | 'KEA'
  | 'KEA_CV'
  | 'KHQ'
  | 'KHQ_ML'
  | 'KI'
  | 'KI_KE'
  | 'KK'
  | 'KKJ'
  | 'KKJ_CM'
  | 'KK_KZ'
  | 'KL'
  | 'KLN'
  | 'KLN_KE'
  | 'KL_GL'
  | 'KM'
  | 'KM_KH'
  | 'KN'
  | 'KN_IN'
  | 'KO'
  | 'KOK'
  | 'KOK_IN'
  | 'KO_KP'
  | 'KO_KR'
  | 'KS'
  | 'KSB'
  | 'KSB_TZ'
  | 'KSF'
  | 'KSF_CM'
  | 'KSH'
  | 'KSH_DE'
  | 'KS_ARAB'
  | 'KS_ARAB_IN'
  | 'KU'
  | 'KU_TR'
  | 'KW'
  | 'KW_GB'
  | 'KY'
  | 'KY_KG'
  | 'LAG'
  | 'LAG_TZ'
  | 'LB'
  | 'LB_LU'
  | 'LG'
  | 'LG_UG'
  | 'LKT'
  | 'LKT_US'
  | 'LN'
  | 'LN_AO'
  | 'LN_CD'
  | 'LN_CF'
  | 'LN_CG'
  | 'LO'
  | 'LO_LA'
  | 'LRC'
  | 'LRC_IQ'
  | 'LRC_IR'
  | 'LT'
  | 'LT_LT'
  | 'LU'
  | 'LUO'
  | 'LUO_KE'
  | 'LUY'
  | 'LUY_KE'
  | 'LU_CD'
  | 'LV'
  | 'LV_LV'
  | 'MAI'
  | 'MAI_IN'
  | 'MAS'
  | 'MAS_KE'
  | 'MAS_TZ'
  | 'MER'
  | 'MER_KE'
  | 'MFE'
  | 'MFE_MU'
  | 'MG'
  | 'MGH'
  | 'MGH_MZ'
  | 'MGO'
  | 'MGO_CM'
  | 'MG_MG'
  | 'MI'
  | 'MI_NZ'
  | 'MK'
  | 'MK_MK'
  | 'ML'
  | 'ML_IN'
  | 'MN'
  | 'MNI'
  | 'MNI_BENG'
  | 'MNI_BENG_IN'
  | 'MN_MN'
  | 'MR'
  | 'MR_IN'
  | 'MS'
  | 'MS_BN'
  | 'MS_ID'
  | 'MS_MY'
  | 'MS_SG'
  | 'MT'
  | 'MT_MT'
  | 'MUA'
  | 'MUA_CM'
  | 'MY'
  | 'MY_MM'
  | 'MZN'
  | 'MZN_IR'
  | 'NAQ'
  | 'NAQ_NA'
  | 'NB'
  | 'NB_NO'
  | 'NB_SJ'
  | 'ND'
  | 'NDS'
  | 'NDS_DE'
  | 'NDS_NL'
  | 'ND_ZW'
  | 'NE'
  | 'NE_IN'
  | 'NE_NP'
  | 'NL'
  | 'NL_AW'
  | 'NL_BE'
  | 'NL_BQ'
  | 'NL_CW'
  | 'NL_NL'
  | 'NL_SR'
  | 'NL_SX'
  | 'NMG'
  | 'NMG_CM'
  | 'NN'
  | 'NNH'
  | 'NNH_CM'
  | 'NN_NO'
  | 'NUS'
  | 'NUS_SS'
  | 'NYN'
  | 'NYN_UG'
  | 'OM'
  | 'OM_ET'
  | 'OM_KE'
  | 'OR'
  | 'OR_IN'
  | 'OS'
  | 'OS_GE'
  | 'OS_RU'
  | 'PA'
  | 'PA_ARAB'
  | 'PA_ARAB_PK'
  | 'PA_GURU'
  | 'PA_GURU_IN'
  | 'PCM'
  | 'PCM_NG'
  | 'PL'
  | 'PL_PL'
  | 'PRG'
  | 'PS'
  | 'PS_AF'
  | 'PS_PK'
  | 'PT'
  | 'PT_AO'
  | 'PT_BR'
  | 'PT_CH'
  | 'PT_CV'
  | 'PT_GQ'
  | 'PT_GW'
  | 'PT_LU'
  | 'PT_MO'
  | 'PT_MZ'
  | 'PT_PT'
  | 'PT_ST'
  | 'PT_TL'
  | 'QU'
  | 'QU_BO'
  | 'QU_EC'
  | 'QU_PE'
  | 'RM'
  | 'RM_CH'
  | 'RN'
  | 'RN_BI'
  | 'RO'
  | 'ROF'
  | 'ROF_TZ'
  | 'RO_MD'
  | 'RO_RO'
  | 'RU'
  | 'RU_BY'
  | 'RU_KG'
  | 'RU_KZ'
  | 'RU_MD'
  | 'RU_RU'
  | 'RU_UA'
  | 'RW'
  | 'RWK'
  | 'RWK_TZ'
  | 'RW_RW'
  | 'SAH'
  | 'SAH_RU'
  | 'SAQ'
  | 'SAQ_KE'
  | 'SAT'
  | 'SAT_OLCK'
  | 'SAT_OLCK_IN'
  | 'SBP'
  | 'SBP_TZ'
  | 'SD'
  | 'SD_ARAB'
  | 'SD_ARAB_PK'
  | 'SD_DEVA'
  | 'SD_DEVA_IN'
  | 'SE'
  | 'SEH'
  | 'SEH_MZ'
  | 'SES'
  | 'SES_ML'
  | 'SE_FI'
  | 'SE_NO'
  | 'SE_SE'
  | 'SG'
  | 'SG_CF'
  | 'SHI'
  | 'SHI_LATN'
  | 'SHI_LATN_MA'
  | 'SHI_TFNG'
  | 'SHI_TFNG_MA'
  | 'SI'
  | 'SI_LK'
  | 'SK'
  | 'SK_SK'
  | 'SL'
  | 'SL_SI'
  | 'SMN'
  | 'SMN_FI'
  | 'SN'
  | 'SN_ZW'
  | 'SO'
  | 'SO_DJ'
  | 'SO_ET'
  | 'SO_KE'
  | 'SO_SO'
  | 'SQ'
  | 'SQ_AL'
  | 'SQ_MK'
  | 'SQ_XK'
  | 'SR'
  | 'SR_CYRL'
  | 'SR_CYRL_BA'
  | 'SR_CYRL_ME'
  | 'SR_CYRL_RS'
  | 'SR_CYRL_XK'
  | 'SR_LATN'
  | 'SR_LATN_BA'
  | 'SR_LATN_ME'
  | 'SR_LATN_RS'
  | 'SR_LATN_XK'
  | 'SU'
  | 'SU_LATN'
  | 'SU_LATN_ID'
  | 'SV'
  | 'SV_AX'
  | 'SV_FI'
  | 'SV_SE'
  | 'SW'
  | 'SW_CD'
  | 'SW_KE'
  | 'SW_TZ'
  | 'SW_UG'
  | 'TA'
  | 'TA_IN'
  | 'TA_LK'
  | 'TA_MY'
  | 'TA_SG'
  | 'TE'
  | 'TEO'
  | 'TEO_KE'
  | 'TEO_UG'
  | 'TE_IN'
  | 'TG'
  | 'TG_TJ'
  | 'TH'
  | 'TH_TH'
  | 'TI'
  | 'TI_ER'
  | 'TI_ET'
  | 'TK'
  | 'TK_TM'
  | 'TO'
  | 'TO_TO'
  | 'TR'
  | 'TR_CY'
  | 'TR_TR'
  | 'TT'
  | 'TT_RU'
  | 'TWQ'
  | 'TWQ_NE'
  | 'TZM'
  | 'TZM_MA'
  | 'UG'
  | 'UG_CN'
  | 'UK'
  | 'UK_UA'
  | 'UR'
  | 'UR_IN'
  | 'UR_PK'
  | 'UZ'
  | 'UZ_ARAB'
  | 'UZ_ARAB_AF'
  | 'UZ_CYRL'
  | 'UZ_CYRL_UZ'
  | 'UZ_LATN'
  | 'UZ_LATN_UZ'
  | 'VAI'
  | 'VAI_LATN'
  | 'VAI_LATN_LR'
  | 'VAI_VAII'
  | 'VAI_VAII_LR'
  | 'VI'
  | 'VI_VN'
  | 'VO'
  | 'VUN'
  | 'VUN_TZ'
  | 'WAE'
  | 'WAE_CH'
  | 'WO'
  | 'WO_SN'
  | 'XH'
  | 'XH_ZA'
  | 'XOG'
  | 'XOG_UG'
  | 'YAV'
  | 'YAV_CM'
  | 'YI'
  | 'YO'
  | 'YO_BJ'
  | 'YO_NG'
  | 'YUE'
  | 'YUE_HANS'
  | 'YUE_HANS_CN'
  | 'YUE_HANT'
  | 'YUE_HANT_HK'
  | 'ZGH'
  | 'ZGH_MA'
  | 'ZH'
  | 'ZH_HANS'
  | 'ZH_HANS_CN'
  | 'ZH_HANS_HK'
  | 'ZH_HANS_MO'
  | 'ZH_HANS_SG'
  | 'ZH_HANT'
  | 'ZH_HANT_HK'
  | 'ZH_HANT_MO'
  | 'ZH_HANT_TW'
  | 'ZU'
  | 'ZU_ZA';

export type LanguageDisplay = {
  /** ISO 639 representation of the language name. */
  readonly code: LanguageCodeEnum;
  /** Full name of the language. */
  readonly language: Scalars['String']['output'];
};

/** Store the current and allowed usage. */
export type LimitInfo = {
  /** Defines the allowed maximum resource usage, null means unlimited. */
  readonly allowedUsage: Limits;
  /** Defines the current resource usage. */
  readonly currentUsage: Limits;
};

export type Limits = {
  /** Defines the number of channels. */
  readonly channels?: Maybe<Scalars['Int']['output']>;
  /** Defines the number of order. */
  readonly orders?: Maybe<Scalars['Int']['output']>;
  /** Defines the number of product variants. */
  readonly productVariants?: Maybe<Scalars['Int']['output']>;
  /** Defines the number of staff users. */
  readonly staffUsers?: Maybe<Scalars['Int']['output']>;
  /** Defines the number of warehouses. */
  readonly warehouses?: Maybe<Scalars['Int']['output']>;
};

/** Filter input for order lines data. */
export type LinesFilterInput = {
  /** Filter by metadata fields of order lines. */
  readonly metadata?: InputMaybe<MetadataFilterInput>;
};

/**
 * List payment methods stored for the user by payment gateway.
 *
 * Note: this API is currently in Feature Preview and can be subject to changes at later point.
 */
export type ListStoredPaymentMethods = Event & {
  /** Channel in context which was used to fetch the list of payment methods. */
  readonly channel: Channel;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The user for which the app should return a list of payment methods. */
  readonly user: User;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** The manifest definition. */
export type Manifest = {
  /** Description of the app displayed in the dashboard. */
  readonly about?: Maybe<Scalars['String']['output']>;
  /** App website rendered in the dashboard. */
  readonly appUrl?: Maybe<Scalars['String']['output']>;
  /** The audience that will be included in all JWT tokens for the app. */
  readonly audience?: Maybe<Scalars['String']['output']>;
  /** The App's author name. */
  readonly author?: Maybe<Scalars['String']['output']>;
  /** App's brand data. */
  readonly brand?: Maybe<AppManifestBrand>;
  /**
   * URL to iframe with the configuration for the app.
   * @deprecated Use `appUrl` instead.
   */
  readonly configurationUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Description of the data privacy defined for this app.
   * @deprecated Use `dataPrivacyUrl` instead.
   */
  readonly dataPrivacy?: Maybe<Scalars['String']['output']>;
  /** URL to the full privacy policy. */
  readonly dataPrivacyUrl?: Maybe<Scalars['String']['output']>;
  /** List of extensions that will be mounted in Saleor's dashboard. For details, please [see the extension section.](https://docs.saleor.io/developer/extending/apps/extending-dashboard-with-apps#key-concepts) */
  readonly extensions: ReadonlyArray<AppManifestExtension>;
  /** External URL to the app homepage. */
  readonly homepageUrl?: Maybe<Scalars['String']['output']>;
  /** The identifier of the manifest for the app. */
  readonly identifier: Scalars['String']['output'];
  /** The name of the manifest for the app . */
  readonly name: Scalars['String']['output'];
  /** The array permissions required for the app. */
  readonly permissions?: Maybe<ReadonlyArray<Permission>>;
  /** Determines the app's required Saleor version as semver range. */
  readonly requiredSaleorVersion?: Maybe<AppManifestRequiredSaleorVersion>;
  /** External URL to the page where app users can find support. */
  readonly supportUrl?: Maybe<Scalars['String']['output']>;
  /** Endpoint used during process of app installation, [see installing an app.](https://docs.saleor.io/developer/extending/apps/installing-apps#installing-an-app) */
  readonly tokenTargetUrl?: Maybe<Scalars['String']['output']>;
  /** The version of the manifest for the app. */
  readonly version: Scalars['String']['output'];
  /** List of the app's webhooks. */
  readonly webhooks: ReadonlyArray<AppManifestWebhook>;
};

/** Metadata for the Margin class. */
export type Margin = {
  /** The starting value of the margin. */
  readonly start?: Maybe<Scalars['Int']['output']>;
  /** The ending value of the margin. */
  readonly stop?: Maybe<Scalars['Int']['output']>;
};

/**
 * Determine the mark as paid strategy for the channel.
 *
 *     TRANSACTION_FLOW - new orders marked as paid will receive a
 *     `TransactionItem` object, that will cover the `order.total`.
 *
 *     PAYMENT_FLOW - new orders marked as paid will receive a
 *     `Payment` object, that will cover the `order.total`.
 */
export type MarkAsPaidStrategyEnum =
  | 'PAYMENT_FLOW'
  | 'TRANSACTION_FLOW';

export type MeasurementUnitsEnum =
  | 'ACRE_FT'
  | 'ACRE_IN'
  | 'CM'
  | 'CUBIC_CENTIMETER'
  | 'CUBIC_DECIMETER'
  | 'CUBIC_FOOT'
  | 'CUBIC_INCH'
  | 'CUBIC_METER'
  | 'CUBIC_MILLIMETER'
  | 'CUBIC_YARD'
  | 'DM'
  | 'FL_OZ'
  | 'FT'
  | 'G'
  | 'INCH'
  | 'KG'
  | 'KM'
  | 'LB'
  | 'LITER'
  | 'M'
  | 'MM'
  | 'OZ'
  | 'PINT'
  | 'QT'
  | 'SQ_CM'
  | 'SQ_DM'
  | 'SQ_FT'
  | 'SQ_INCH'
  | 'SQ_KM'
  | 'SQ_M'
  | 'SQ_MM'
  | 'SQ_YD'
  | 'TONNE'
  | 'YD';

export type MeasurementUnitsEnumFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<MeasurementUnitsEnum>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<MeasurementUnitsEnum>>;
};

export type MediaChoicesSortField =
  /** Sort media by ID. */
  | 'ID';

export type MediaInput = {
  /** Alt text for a product media. */
  readonly alt?: InputMaybe<Scalars['String']['input']>;
  /** Represents an image file in a multipart request. */
  readonly image?: InputMaybe<Scalars['Upload']['input']>;
  /** Represents an URL to an external media. */
  readonly mediaUrl?: InputMaybe<Scalars['String']['input']>;
};

export type MediaSortingInput = {
  /** Specifies the direction in which to sort media. */
  readonly direction: OrderDirection;
  /** Sort media by the selected field. */
  readonly field: MediaChoicesSortField;
};

/** Represents a single menu - an object that is used to help navigate through the store. */
export type Menu = Node & ObjectWithMetadata & {
  /** The ID of the menu. */
  readonly id: Scalars['ID']['output'];
  /** Menu items associated with this menu. */
  readonly items?: Maybe<ReadonlyArray<MenuItem>>;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** The name of the menu. */
  readonly name: Scalars['String']['output'];
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Slug of the menu. */
  readonly slug: Scalars['String']['output'];
};


/** Represents a single menu - an object that is used to help navigate through the store. */
export type MenuMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a single menu - an object that is used to help navigate through the store. */
export type MenuMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a single menu - an object that is used to help navigate through the store. */
export type MenuPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a single menu - an object that is used to help navigate through the store. */
export type MenuPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/**
 * Deletes menus.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_DELETED (async): A menu was deleted.
 */
export type MenuBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<MenuError>;
  /** @deprecated Use `errors` field instead. */
  readonly menuErrors: ReadonlyArray<MenuError>;
};

export type MenuCountableConnection = {
  readonly edges: ReadonlyArray<MenuCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type MenuCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Menu;
};

/**
 * Creates a new Menu.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_CREATED (async): A menu was created.
 */
export type MenuCreate = {
  readonly errors: ReadonlyArray<MenuError>;
  readonly menu?: Maybe<Menu>;
  /** @deprecated Use `errors` field instead. */
  readonly menuErrors: ReadonlyArray<MenuError>;
};

export type MenuCreateInput = {
  /** List of menu items. */
  readonly items?: InputMaybe<ReadonlyArray<MenuItemInput>>;
  /** Name of the menu. */
  readonly name: Scalars['String']['input'];
  /** Slug of the menu. Will be generated if not provided. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when new menu is created. */
export type MenuCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The menu the event relates to. */
  readonly menu?: Maybe<Menu>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when new menu is created. */
export type MenuCreatedMenuArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Deletes a menu.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_DELETED (async): A menu was deleted.
 */
export type MenuDelete = {
  readonly errors: ReadonlyArray<MenuError>;
  readonly menu?: Maybe<Menu>;
  /** @deprecated Use `errors` field instead. */
  readonly menuErrors: ReadonlyArray<MenuError>;
};

/** Event sent when menu is deleted. */
export type MenuDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The menu the event relates to. */
  readonly menu?: Maybe<Menu>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when menu is deleted. */
export type MenuDeletedMenuArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

export type MenuError = {
  /** The error code. */
  readonly code: MenuErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type MenuErrorCode =
  | 'CANNOT_ASSIGN_NODE'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_MENU_ITEM'
  | 'NOT_FOUND'
  | 'NO_MENU_ITEM_PROVIDED'
  | 'REQUIRED'
  | 'TOO_MANY_MENU_ITEMS'
  | 'UNIQUE';

export type MenuFilterInput = {
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly slug?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly slugs?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

export type MenuInput = {
  /** Name of the menu. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Slug of the menu. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
};

/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItem = Node & ObjectWithMetadata & {
  /** Category associated with the menu item. */
  readonly category?: Maybe<Category>;
  /** Represents the child items of the current menu item. */
  readonly children?: Maybe<ReadonlyArray<MenuItem>>;
  /** A collection associated with this menu item. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  readonly collection?: Maybe<Collection>;
  /** The ID of the menu item. */
  readonly id: Scalars['ID']['output'];
  /** Indicates the position of the menu item within the menu structure. */
  readonly level: Scalars['Int']['output'];
  /** Represents the menu to which the menu item belongs. */
  readonly menu: Menu;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** The name of the menu item. */
  readonly name: Scalars['String']['output'];
  /** A page associated with this menu item. Requires one of the following permissions to include unpublished items: MANAGE_PAGES. */
  readonly page?: Maybe<Page>;
  /** ID of parent menu item. If empty, menu will be top level menu. */
  readonly parent?: Maybe<MenuItem>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Returns translated menu item fields for the given language code. */
  readonly translation?: Maybe<MenuItemTranslation>;
  /** URL to the menu item. */
  readonly url?: Maybe<Scalars['String']['output']>;
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Deletes menu items.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_ITEM_DELETED (async): A menu item was deleted.
 */
export type MenuItemBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<MenuError>;
  /** @deprecated Use `errors` field instead. */
  readonly menuErrors: ReadonlyArray<MenuError>;
};

export type MenuItemCountableConnection = {
  readonly edges: ReadonlyArray<MenuItemCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type MenuItemCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: MenuItem;
};

/**
 * Creates a new menu item.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_ITEM_CREATED (async): A menu item was created.
 */
export type MenuItemCreate = {
  readonly errors: ReadonlyArray<MenuError>;
  /** @deprecated Use `errors` field instead. */
  readonly menuErrors: ReadonlyArray<MenuError>;
  readonly menuItem?: Maybe<MenuItem>;
};

export type MenuItemCreateInput = {
  /** Category to which item points. */
  readonly category?: InputMaybe<Scalars['ID']['input']>;
  /** Collection to which item points. */
  readonly collection?: InputMaybe<Scalars['ID']['input']>;
  /** Menu to which item belongs. */
  readonly menu: Scalars['ID']['input'];
  /** Name of the menu item. */
  readonly name: Scalars['String']['input'];
  /** Page to which item points. */
  readonly page?: InputMaybe<Scalars['ID']['input']>;
  /** ID of the parent menu. If empty, menu will be top level menu. */
  readonly parent?: InputMaybe<Scalars['ID']['input']>;
  /** URL of the pointed item. */
  readonly url?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when new menu item is created. */
export type MenuItemCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The menu item the event relates to. */
  readonly menuItem?: Maybe<MenuItem>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when new menu item is created. */
export type MenuItemCreatedMenuItemArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Deletes a menu item.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_ITEM_DELETED (async): A menu item was deleted.
 */
export type MenuItemDelete = {
  readonly errors: ReadonlyArray<MenuError>;
  /** @deprecated Use `errors` field instead. */
  readonly menuErrors: ReadonlyArray<MenuError>;
  readonly menuItem?: Maybe<MenuItem>;
};

/** Event sent when menu item is deleted. */
export type MenuItemDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The menu item the event relates to. */
  readonly menuItem?: Maybe<MenuItem>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when menu item is deleted. */
export type MenuItemDeletedMenuItemArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

export type MenuItemFilterInput = {
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
};

export type MenuItemInput = {
  /** Category to which item points. */
  readonly category?: InputMaybe<Scalars['ID']['input']>;
  /** Collection to which item points. */
  readonly collection?: InputMaybe<Scalars['ID']['input']>;
  /** Name of the menu item. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Page to which item points. */
  readonly page?: InputMaybe<Scalars['ID']['input']>;
  /** URL of the pointed item. */
  readonly url?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Moves items of menus.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_ITEM_UPDATED (async): Optionally triggered when sort order or parent changed for menu item.
 */
export type MenuItemMove = {
  readonly errors: ReadonlyArray<MenuError>;
  /** Assigned menu to move within. */
  readonly menu?: Maybe<Menu>;
  /** @deprecated Use `errors` field instead. */
  readonly menuErrors: ReadonlyArray<MenuError>;
};

export type MenuItemMoveInput = {
  /** The menu item ID to move. */
  readonly itemId: Scalars['ID']['input'];
  /** ID of the parent menu. If empty, menu will be top level menu. */
  readonly parentId?: InputMaybe<Scalars['ID']['input']>;
  /** The new relative sorting position of the item (from -inf to +inf). 1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged. */
  readonly sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

export type MenuItemSortingInput = {
  /** Specifies the direction in which to sort menu items. */
  readonly direction: OrderDirection;
  /** Sort menu items by the selected field. */
  readonly field: MenuItemsSortField;
};

/** Represents menu item's original translatable fields and related translations. */
export type MenuItemTranslatableContent = Node & {
  /** The ID of the menu item translatable content. */
  readonly id: Scalars['ID']['output'];
  /**
   * Represents a single item of the related menu. Can store categories, collection or pages.
   * @deprecated Get model fields from the root level queries.
   */
  readonly menuItem?: Maybe<MenuItem>;
  /** The ID of the menu item to translate. */
  readonly menuItemId: Scalars['ID']['output'];
  /** Name of the menu item to translate. */
  readonly name: Scalars['String']['output'];
  /** Returns translated menu item fields for the given language code. */
  readonly translation?: Maybe<MenuItemTranslation>;
};


/** Represents menu item's original translatable fields and related translations. */
export type MenuItemTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a menu item.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type MenuItemTranslate = {
  readonly errors: ReadonlyArray<TranslationError>;
  readonly menuItem?: Maybe<MenuItem>;
  /** @deprecated Use `errors` field instead. */
  readonly translationErrors: ReadonlyArray<TranslationError>;
};

/** Represents menu item translations. */
export type MenuItemTranslation = Node & {
  /** The ID of the menu item translation. */
  readonly id: Scalars['ID']['output'];
  /** Translation language. */
  readonly language: LanguageDisplay;
  /** Translated menu item name. */
  readonly name: Scalars['String']['output'];
  /** Represents the menu item fields to translate. */
  readonly translatableContent?: Maybe<MenuItemTranslatableContent>;
};

/**
 * Updates a menu item.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_ITEM_UPDATED (async): A menu item was updated.
 */
export type MenuItemUpdate = {
  readonly errors: ReadonlyArray<MenuError>;
  /** @deprecated Use `errors` field instead. */
  readonly menuErrors: ReadonlyArray<MenuError>;
  readonly menuItem?: Maybe<MenuItem>;
};

/** Event sent when menu item is updated. */
export type MenuItemUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The menu item the event relates to. */
  readonly menuItem?: Maybe<MenuItem>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when menu item is updated. */
export type MenuItemUpdatedMenuItemArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

export type MenuItemsSortField =
  /** Sort menu items by name. */
  | 'NAME';

export type MenuSortField =
  /** Sort menus by items count. */
  | 'ITEMS_COUNT'
  /** Sort menus by name. */
  | 'NAME';

export type MenuSortingInput = {
  /** Specifies the direction in which to sort menus. */
  readonly direction: OrderDirection;
  /** Sort menus by the selected field. */
  readonly field: MenuSortField;
};

/**
 * Updates a menu.
 *
 * Requires one of the following permissions: MANAGE_MENUS.
 *
 * Triggers the following webhook events:
 * - MENU_UPDATED (async): A menu was updated.
 */
export type MenuUpdate = {
  readonly errors: ReadonlyArray<MenuError>;
  readonly menu?: Maybe<Menu>;
  /** @deprecated Use `errors` field instead. */
  readonly menuErrors: ReadonlyArray<MenuError>;
};

/** Event sent when menu is updated. */
export type MenuUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The menu the event relates to. */
  readonly menu?: Maybe<Menu>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when menu is updated. */
export type MenuUpdatedMenuArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

export type MetadataError = {
  /** The error code. */
  readonly code: MetadataErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type MetadataErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'NOT_UPDATED'
  | 'REQUIRED';

export type MetadataFilter = {
  /** Key of a metadata item. */
  readonly key: Scalars['String']['input'];
  /** Value of a metadata item. */
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Allows filtering based on metadata key/value pairs.
 *
 *         Examples:
 *         - `{key: "size"}`
 *           Matches objects where the metadata key "size" exists, regardless of its value.
 *         - `{key: "color", value: {oneOf: ["blue", "green"]}}`
 *           Matches objects where the metadata key "color" is set to either "blue" or "green".
 *         - `{key: "status", value: {eq: "active"}}`
 *           Matches objects where the metadata key "status" is set to "active".
 */
export type MetadataFilterInput = {
  /** Key to filter by. If not other fields provided - checking the existence of the key in metadata. */
  readonly key: Scalars['String']['input'];
  /** Value to filter by. */
  readonly value?: InputMaybe<MetadataValueFilterInput>;
};

export type MetadataInput = {
  /** Key of a metadata item. */
  readonly key: Scalars['String']['input'];
  /** Value of a metadata item. */
  readonly value: Scalars['String']['input'];
};

export type MetadataItem = {
  /** Key of a metadata item. */
  readonly key: Scalars['String']['output'];
  /** Value of a metadata item. */
  readonly value: Scalars['String']['output'];
};

/** Define the filtering options for metadata value fields. */
export type MetadataValueFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<Scalars['String']['input']>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** Represents amount of money in specific currency. */
export type Money = {
  /** Amount of money. */
  readonly amount: Scalars['Float']['output'];
  /** Currency code. */
  readonly currency: Scalars['String']['output'];
  /** Number of digits after the decimal point in the currency. */
  readonly fractionDigits: Scalars['Int']['output'];
  /** Amount of money represented as an integer in the smallest currency unit. */
  readonly fractionalAmount: Scalars['Int']['output'];
};

export type MoneyInput = {
  /** Amount of money. */
  readonly amount: Scalars['PositiveDecimal']['input'];
  /** Currency code. */
  readonly currency: Scalars['String']['input'];
};

/** Represents a range of amounts of money. */
export type MoneyRange = {
  /** Lower bound of a price range. */
  readonly start?: Maybe<Money>;
  /** Upper bound of a price range. */
  readonly stop?: Maybe<Money>;
};

export type MoveProductInput = {
  /** The ID of the product to move. */
  readonly productId: Scalars['ID']['input'];
  /** The relative sorting position of the product (from -inf to +inf) starting from the first given product's actual position.1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged. */
  readonly sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

export type Mutation = {
  /**
   * Create a new address for the customer.
   *
   * Requires one of following set of permissions: AUTHENTICATED_USER or AUTHENTICATED_APP + IMPERSONATE_USER.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_UPDATED (async): A customer account was updated.
   * - ADDRESS_CREATED (async): An address was created.
   */
  readonly accountAddressCreate?: Maybe<AccountAddressCreate>;
  /**
   * Deletes an address of the logged-in user. Requires one of the following permissions: MANAGE_USERS, IS_OWNER.
   *
   * Triggers the following webhook events:
   * - ADDRESS_DELETED (async): An address was deleted.
   */
  readonly accountAddressDelete?: Maybe<AccountAddressDelete>;
  /**
   * Updates an address of the logged-in user. Requires one of the following permissions: MANAGE_USERS, IS_OWNER.
   *
   * Triggers the following webhook events:
   * - ADDRESS_UPDATED (async): An address was updated.
   */
  readonly accountAddressUpdate?: Maybe<AccountAddressUpdate>;
  /**
   * Remove user account.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - ACCOUNT_DELETED (async): Account was deleted.
   */
  readonly accountDelete?: Maybe<AccountDelete>;
  /**
   * Register a new user.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_CREATED (async): A new customer account was created.
   * - NOTIFY_USER (async): A notification for account confirmation.
   * - ACCOUNT_CONFIRMATION_REQUESTED (async): An user confirmation was requested. This event is always sent regardless of settings.
   */
  readonly accountRegister?: Maybe<AccountRegister>;
  /**
   * Sends an email with the account removal link for the logged-in user.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - NOTIFY_USER (async): A notification for account delete request.
   * - ACCOUNT_DELETE_REQUESTED (async): An account delete requested.
   */
  readonly accountRequestDeletion?: Maybe<AccountRequestDeletion>;
  /**
   * Sets a default address for the authenticated user.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_UPDATED (async): A customer's address was updated.
   */
  readonly accountSetDefaultAddress?: Maybe<AccountSetDefaultAddress>;
  /**
   * Updates the account of the logged-in user.
   *
   * Requires one of following set of permissions: AUTHENTICATED_USER or AUTHENTICATED_APP + IMPERSONATE_USER.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_UPDATED (async): A customer account was updated.
   * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
   */
  readonly accountUpdate?: Maybe<AccountUpdate>;
  /**
   * Creates user address.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - ADDRESS_CREATED (async): A new address was created.
   */
  readonly addressCreate?: Maybe<AddressCreate>;
  /**
   * Deletes an address.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - ADDRESS_DELETED (async): An address was deleted.
   */
  readonly addressDelete?: Maybe<AddressDelete>;
  /**
   * Sets a default address for the given user.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_UPDATED (async): A customer was updated.
   */
  readonly addressSetDefault?: Maybe<AddressSetDefault>;
  /**
   * Updates an address.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - ADDRESS_UPDATED (async): An address was updated.
   */
  readonly addressUpdate?: Maybe<AddressUpdate>;
  /**
   * Activate the app.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   *
   * Triggers the following webhook events:
   * - APP_STATUS_CHANGED (async): An app was activated.
   */
  readonly appActivate?: Maybe<AppActivate>;
  /**
   * Creates a new app. Requires the following permissions: AUTHENTICATED_STAFF_USER and MANAGE_APPS.
   *
   * Triggers the following webhook events:
   * - APP_INSTALLED (async): An app was installed.
   */
  readonly appCreate?: Maybe<AppCreate>;
  /**
   * Deactivate the app.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   *
   * Triggers the following webhook events:
   * - APP_STATUS_CHANGED (async): An app was deactivated.
   */
  readonly appDeactivate?: Maybe<AppDeactivate>;
  /**
   * Deletes an app.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   *
   * Triggers the following webhook events:
   * - APP_DELETED (async): An app was deleted.
   */
  readonly appDelete?: Maybe<AppDelete>;
  /**
   * Deletes failed installation.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   */
  readonly appDeleteFailedInstallation?: Maybe<AppDeleteFailedInstallation>;
  /**
   * Fetch and validate manifest.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   */
  readonly appFetchManifest?: Maybe<AppFetchManifest>;
  /** Install new app by using app manifest. Requires the following permissions: AUTHENTICATED_STAFF_USER and MANAGE_APPS. */
  readonly appInstall?: Maybe<AppInstall>;
  /**
   * Re-enable sync webhooks for provided app. Can be used to manually re-enable sync webhooks for the app before the cooldown period ends.
   *
   * Added in Saleor 3.21.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   */
  readonly appReenableSyncWebhooks?: Maybe<AppReenableSyncWebhooks>;
  /**
   * Retry failed installation of new app.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   *
   * Triggers the following webhook events:
   * - APP_INSTALLED (async): An app was installed.
   */
  readonly appRetryInstall?: Maybe<AppRetryInstall>;
  /**
   * Creates a new token.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   */
  readonly appTokenCreate?: Maybe<AppTokenCreate>;
  /**
   * Deletes an authentication token assigned to app.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   */
  readonly appTokenDelete?: Maybe<AppTokenDelete>;
  /** Verify provided app token. */
  readonly appTokenVerify?: Maybe<AppTokenVerify>;
  /**
   * Updates an existing app.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   *
   * Triggers the following webhook events:
   * - APP_UPDATED (async): An app was updated.
   */
  readonly appUpdate?: Maybe<AppUpdate>;
  /**
   * Assigns storefront's navigation menus.
   *
   * Requires one of the following permissions: MANAGE_MENUS, MANAGE_SETTINGS.
   */
  readonly assignNavigation?: Maybe<AssignNavigation>;
  /**
   * Add shipping zone to given warehouse.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly assignWarehouseShippingZone?: Maybe<WarehouseShippingZoneAssign>;
  /**
   * Creates attributes.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_CREATED (async): An attribute was created.
   */
  readonly attributeBulkCreate?: Maybe<AttributeBulkCreate>;
  /**
   * Deletes attributes.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_DELETED (async): An attribute was deleted.
   */
  readonly attributeBulkDelete?: Maybe<AttributeBulkDelete>;
  /**
   * Creates/updates translations for attributes.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly attributeBulkTranslate?: Maybe<AttributeBulkTranslate>;
  /**
   * Updates attributes.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_UPDATED (async): An attribute was updated. Optionally called when new attribute value was created or deleted.
   * - ATTRIBUTE_VALUE_CREATED (async): Called optionally when an attribute value was created.
   * - ATTRIBUTE_VALUE_DELETED (async): Called optionally when an attribute value was deleted.
   */
  readonly attributeBulkUpdate?: Maybe<AttributeBulkUpdate>;
  /**
   * Creates an attribute.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_CREATED (async): An attribute was created.
   */
  readonly attributeCreate?: Maybe<AttributeCreate>;
  /**
   * Deletes an attribute.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_DELETED (async): An attribute was deleted.
   */
  readonly attributeDelete?: Maybe<AttributeDelete>;
  /**
   * Reorder the values of an attribute.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_VALUE_UPDATED (async): An attribute value was updated.
   * - ATTRIBUTE_UPDATED (async): An attribute was updated.
   */
  readonly attributeReorderValues?: Maybe<AttributeReorderValues>;
  /**
   * Creates/updates translations for an attribute.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly attributeTranslate?: Maybe<AttributeTranslate>;
  /**
   * Updates attribute.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_UPDATED (async): An attribute was updated.
   */
  readonly attributeUpdate?: Maybe<AttributeUpdate>;
  /**
   * Deletes values of attributes.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_VALUE_DELETED (async): An attribute value was deleted.
   * - ATTRIBUTE_UPDATED (async): An attribute was updated.
   */
  readonly attributeValueBulkDelete?: Maybe<AttributeValueBulkDelete>;
  /**
   * Creates/updates translations for attribute values.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly attributeValueBulkTranslate?: Maybe<AttributeValueBulkTranslate>;
  /**
   * Creates a value for an attribute.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_VALUE_CREATED (async): An attribute value was created.
   * - ATTRIBUTE_UPDATED (async): An attribute was updated.
   */
  readonly attributeValueCreate?: Maybe<AttributeValueCreate>;
  /**
   * Deletes a value of an attribute.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_VALUE_DELETED (async): An attribute value was deleted.
   * - ATTRIBUTE_UPDATED (async): An attribute was updated.
   */
  readonly attributeValueDelete?: Maybe<AttributeValueDelete>;
  /**
   * Creates/updates translations for an attribute value.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly attributeValueTranslate?: Maybe<AttributeValueTranslate>;
  /**
   * Updates value of an attribute.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   *
   * Triggers the following webhook events:
   * - ATTRIBUTE_VALUE_UPDATED (async): An attribute value was updated.
   * - ATTRIBUTE_UPDATED (async): An attribute was updated.
   */
  readonly attributeValueUpdate?: Maybe<AttributeValueUpdate>;
  /**
   * Deletes categories.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly categoryBulkDelete?: Maybe<CategoryBulkDelete>;
  /**
   * Creates a new category.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly categoryCreate?: Maybe<CategoryCreate>;
  /**
   * Deletes a category.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly categoryDelete?: Maybe<CategoryDelete>;
  /**
   * Creates/updates translations for a category.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly categoryTranslate?: Maybe<CategoryTranslate>;
  /**
   * Updates a category.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly categoryUpdate?: Maybe<CategoryUpdate>;
  /**
   * Activate a channel.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS.
   *
   * Triggers the following webhook events:
   * - CHANNEL_STATUS_CHANGED (async): A channel was activated.
   */
  readonly channelActivate?: Maybe<ChannelActivate>;
  /**
   * Creates a new channel.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS.
   *
   * Triggers the following webhook events:
   * - CHANNEL_CREATED (async): A channel was created.
   */
  readonly channelCreate?: Maybe<ChannelCreate>;
  /**
   * Deactivate a channel.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS.
   *
   * Triggers the following webhook events:
   * - CHANNEL_STATUS_CHANGED (async): A channel was deactivated.
   */
  readonly channelDeactivate?: Maybe<ChannelDeactivate>;
  /**
   * Deletes a channel. Orders associated with the deleted channel will be moved to the target channel. Checkouts, product availability, and pricing will be removed.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS.
   *
   * Triggers the following webhook events:
   * - CHANNEL_DELETED (async): A channel was deleted.
   */
  readonly channelDelete?: Maybe<ChannelDelete>;
  /**
   * Reorder the warehouses of a channel.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS.
   */
  readonly channelReorderWarehouses?: Maybe<ChannelReorderWarehouses>;
  /**
   * Update a channel.
   *
   * Requires one of the following permissions: MANAGE_CHANNELS.
   * Requires one of the following permissions when updating only `orderSettings` field: `MANAGE_CHANNELS`, `MANAGE_ORDERS`.
   * Requires one of the following permissions when updating only `checkoutSettings` field: `MANAGE_CHANNELS`, `MANAGE_CHECKOUTS`.
   * Requires one of the following permissions when updating only `paymentSettings` field: `MANAGE_CHANNELS`, `HANDLE_PAYMENTS`.
   *
   * Triggers the following webhook events:
   * - CHANNEL_UPDATED (async): A channel was updated.
   * - CHANNEL_METADATA_UPDATED (async): Optionally triggered when public or private metadata is updated.
   */
  readonly channelUpdate?: Maybe<ChannelUpdate>;
  /**
   * Adds a gift card or a voucher to a checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  readonly checkoutAddPromoCode?: Maybe<CheckoutAddPromoCode>;
  /**
   * Updates billing address in the existing checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  readonly checkoutBillingAddressUpdate?: Maybe<CheckoutBillingAddressUpdate>;
  /**
   * Completes the checkout. As a result a new order is created. The mutation allows to create the unpaid order when setting `orderSettings.allowUnpaidOrders` for given `Channel` is set to `true`. When `orderSettings.allowUnpaidOrders` is set to `false`, checkout can be completed only when attached `Payment`/`TransactionItem`s fully cover the checkout's total. When processing the checkout with `Payment`, in case of required additional confirmation step like 3D secure, the `confirmationNeeded` flag will be set to True and no order will be created until payment is confirmed with second call of this mutation.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
   * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   * - ORDER_CREATED (async): Triggered when order is created.
   * - NOTIFY_USER (async): A notification for order placement.
   * - NOTIFY_USER (async): A staff notification for order placement.
   * - ORDER_UPDATED (async): Triggered when order received the update after placement.
   * - ORDER_PAID (async): Triggered when newly created order is paid.
   * - ORDER_FULLY_PAID (async): Triggered when newly created order is fully paid.
   * - ORDER_CONFIRMED (async): Optionally triggered when newly created order are automatically marked as confirmed.
   */
  readonly checkoutComplete?: Maybe<CheckoutComplete>;
  /**
   * Create a new checkout.
   *
   * `skipValidation` field requires HANDLE_CHECKOUTS and AUTHENTICATED_APP permissions.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_CREATED (async): A checkout was created.
   */
  readonly checkoutCreate?: Maybe<CheckoutCreate>;
  /** Creates a new checkout from existing order. */
  readonly checkoutCreateFromOrder?: Maybe<CheckoutCreateFromOrder>;
  /**
   * Sets the customer as the owner of the checkout.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  readonly checkoutCustomerAttach?: Maybe<CheckoutCustomerAttach>;
  /**
   * Removes the user assigned as the owner of the checkout.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  readonly checkoutCustomerDetach?: Maybe<CheckoutCustomerDetach>;
  /**
   * Updates customer note in the existing checkout object.
   *
   * Added in Saleor 3.21.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  readonly checkoutCustomerNoteUpdate?: Maybe<CheckoutCustomerNoteUpdate>;
  /**
   * Updates the delivery method (shipping method or pick up point) of the checkout. Updates the checkout shipping_address for click and collect delivery for a warehouse address.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Triggered when updating the checkout delivery method with the external one.
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  readonly checkoutDeliveryMethodUpdate?: Maybe<CheckoutDeliveryMethodUpdate>;
  /**
   * Updates email address in the existing checkout object.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  readonly checkoutEmailUpdate?: Maybe<CheckoutEmailUpdate>;
  /**
   * Updates language code in the existing checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  readonly checkoutLanguageCodeUpdate?: Maybe<CheckoutLanguageCodeUpdate>;
  /**
   * Deletes a CheckoutLine.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   * @deprecated Use `checkoutLinesDelete` instead.
   */
  readonly checkoutLineDelete?: Maybe<CheckoutLineDelete>;
  /**
   * Adds a checkout line to the existing checkout.If line was already in checkout, its quantity will be increased.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  readonly checkoutLinesAdd?: Maybe<CheckoutLinesAdd>;
  /**
   * Deletes checkout lines.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  readonly checkoutLinesDelete?: Maybe<CheckoutLinesDelete>;
  /**
   * Updates checkout line in the existing checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  readonly checkoutLinesUpdate?: Maybe<CheckoutLinesUpdate>;
  /** Creates a new payment for given checkout. */
  readonly checkoutPaymentCreate?: Maybe<CheckoutPaymentCreate>;
  /**
   * Remove a gift card or a voucher from a checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  readonly checkoutRemovePromoCode?: Maybe<CheckoutRemovePromoCode>;
  /**
   * Updates shipping address in the existing checkout.
   *
   * Triggers the following webhook events:
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   */
  readonly checkoutShippingAddressUpdate?: Maybe<CheckoutShippingAddressUpdate>;
  /**
   * Updates the shipping method of the checkout.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Triggered when updating the checkout shipping method with the external one.
   * - CHECKOUT_UPDATED (async): A checkout was updated.
   * @deprecated Use `checkoutDeliveryMethodUpdate` instead.
   */
  readonly checkoutShippingMethodUpdate?: Maybe<CheckoutShippingMethodUpdate>;
  /**
   * Adds products to a collection.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly collectionAddProducts?: Maybe<CollectionAddProducts>;
  /**
   * Deletes collections.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly collectionBulkDelete?: Maybe<CollectionBulkDelete>;
  /**
   * Manage collection's availability in channels.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly collectionChannelListingUpdate?: Maybe<CollectionChannelListingUpdate>;
  /**
   * Creates a new collection.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly collectionCreate?: Maybe<CollectionCreate>;
  /**
   * Deletes a collection.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly collectionDelete?: Maybe<CollectionDelete>;
  /**
   * Remove products from a collection.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly collectionRemoveProducts?: Maybe<CollectionRemoveProducts>;
  /**
   * Reorder the products of a collection.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly collectionReorderProducts?: Maybe<CollectionReorderProducts>;
  /**
   * Creates/updates translations for a collection.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly collectionTranslate?: Maybe<CollectionTranslate>;
  /**
   * Updates a collection.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly collectionUpdate?: Maybe<CollectionUpdate>;
  /**
   * Confirm user account with token sent by email during registration.
   *
   * Triggers the following webhook events:
   * - ACCOUNT_CONFIRMED (async): Account was confirmed.
   */
  readonly confirmAccount?: Maybe<ConfirmAccount>;
  /**
   * Confirm the email change of the logged-in user.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_UPDATED (async): A customer account was updated.
   * - NOTIFY_USER (async): A notification that account email change was confirmed.
   * - ACCOUNT_EMAIL_CHANGED (async): An account email was changed.
   */
  readonly confirmEmailChange?: Maybe<ConfirmEmailChange>;
  /**
   * Creates a new warehouse.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly createWarehouse?: Maybe<WarehouseCreate>;
  /**
   * Deletes customers.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_DELETED (async): A customer account was deleted.
   */
  readonly customerBulkDelete?: Maybe<CustomerBulkDelete>;
  /**
   * Updates customers.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_UPDATED (async): A customer account was updated.
   * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
   */
  readonly customerBulkUpdate?: Maybe<CustomerBulkUpdate>;
  /**
   * Creates a new customer.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_CREATED (async): A new customer account was created.
   * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
   * - NOTIFY_USER (async): A notification for setting the password.
   * - ACCOUNT_SET_PASSWORD_REQUESTED (async): Setting a new password for the account is requested.
   */
  readonly customerCreate?: Maybe<CustomerCreate>;
  /**
   * Deletes a customer.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_DELETED (async): A customer account was deleted.
   */
  readonly customerDelete?: Maybe<CustomerDelete>;
  /**
   * Updates an existing customer.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   *
   * Triggers the following webhook events:
   * - CUSTOMER_UPDATED (async): A new customer account was updated.
   * - CUSTOMER_METADATA_UPDATED (async): Optionally called when customer's metadata was updated.
   */
  readonly customerUpdate?: Maybe<CustomerUpdate>;
  /** Delete metadata of an object. To use it, you need to have access to the modified object. */
  readonly deleteMetadata?: Maybe<DeleteMetadata>;
  /** Delete object's private metadata. To use it, you need to be an authenticated staff user or an app and have access to the modified object. */
  readonly deletePrivateMetadata?: Maybe<DeletePrivateMetadata>;
  /**
   * Deletes selected warehouse.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly deleteWarehouse?: Maybe<WarehouseDelete>;
  /**
   * Create new digital content. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly digitalContentCreate?: Maybe<DigitalContentCreate>;
  /**
   * Remove digital content assigned to given variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly digitalContentDelete?: Maybe<DigitalContentDelete>;
  /**
   * Updates digital content.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly digitalContentUpdate?: Maybe<DigitalContentUpdate>;
  /**
   * Generate new URL to digital content.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly digitalContentUrlCreate?: Maybe<DigitalContentUrlCreate>;
  /**
   * Deletes draft orders.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly draftOrderBulkDelete?: Maybe<DraftOrderBulkDelete>;
  /**
   * Completes creating an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly draftOrderComplete?: Maybe<DraftOrderComplete>;
  /**
   * Creates a new draft order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly draftOrderCreate?: Maybe<DraftOrderCreate>;
  /**
   * Deletes a draft order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly draftOrderDelete?: Maybe<DraftOrderDelete>;
  /**
   * Deletes order lines.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   * @deprecated Field no longer supported
   */
  readonly draftOrderLinesBulkDelete?: Maybe<DraftOrderLinesBulkDelete>;
  /**
   * Updates a draft order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly draftOrderUpdate?: Maybe<DraftOrderUpdate>;
  /**
   * Retries event delivery.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   */
  readonly eventDeliveryRetry?: Maybe<EventDeliveryRetry>;
  /**
   * Export gift cards to csv file.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - NOTIFY_USER (async): A notification for the exported file.
   * - GIFT_CARD_EXPORT_COMPLETED (async): A notification for the exported file.
   */
  readonly exportGiftCards?: Maybe<ExportGiftCards>;
  /**
   * Export products to csv file.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   *
   * Triggers the following webhook events:
   * - NOTIFY_USER (async): A notification for the exported file.
   * - PRODUCT_EXPORT_COMPLETED (async): A notification for the exported file.
   */
  readonly exportProducts?: Maybe<ExportProducts>;
  /**
   * Export voucher codes to csv/xlsx file.
   *
   * Added in Saleor 3.18.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_CODE_EXPORT_COMPLETED (async): A notification for the exported file.
   */
  readonly exportVoucherCodes?: Maybe<ExportVoucherCodes>;
  /** Prepare external authentication URL for user by custom plugin. */
  readonly externalAuthenticationUrl?: Maybe<ExternalAuthenticationUrl>;
  /** Logout user by custom plugin. */
  readonly externalLogout?: Maybe<ExternalLogout>;
  /**
   * Trigger sending a notification with the notify plugin method. Serializes nodes provided as ids parameter and includes this data in the notification payload.
   * @deprecated Field no longer supported
   */
  readonly externalNotificationTrigger?: Maybe<ExternalNotificationTrigger>;
  /** Obtain external access tokens for user by custom plugin. */
  readonly externalObtainAccessTokens?: Maybe<ExternalObtainAccessTokens>;
  /** Refresh user's access by custom plugin. */
  readonly externalRefresh?: Maybe<ExternalRefresh>;
  /** Verify external authentication data by plugin. */
  readonly externalVerify?: Maybe<ExternalVerify>;
  /**
   * Upload a file. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  readonly fileUpload?: Maybe<FileUpload>;
  /**
   * Activate a gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_STATUS_CHANGED (async): A gift card was activated.
   */
  readonly giftCardActivate?: Maybe<GiftCardActivate>;
  /**
   * Adds note to the gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_UPDATED (async): A gift card was updated.
   */
  readonly giftCardAddNote?: Maybe<GiftCardAddNote>;
  /**
   * Activate gift cards.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_STATUS_CHANGED (async): A gift card was activated.
   */
  readonly giftCardBulkActivate?: Maybe<GiftCardBulkActivate>;
  /**
   * Creates gift cards.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_CREATED (async): A gift card was created.
   * - NOTIFY_USER (async): A notification for created gift card.
   */
  readonly giftCardBulkCreate?: Maybe<GiftCardBulkCreate>;
  /**
   * Deactivate gift cards.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_STATUS_CHANGED (async): A gift card was deactivated.
   */
  readonly giftCardBulkDeactivate?: Maybe<GiftCardBulkDeactivate>;
  /**
   * Deletes gift cards.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_DELETED (async): A gift card was deleted.
   */
  readonly giftCardBulkDelete?: Maybe<GiftCardBulkDelete>;
  /**
   * Creates a new gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_CREATED (async): A gift card was created.
   * - NOTIFY_USER (async): A notification for created gift card.
   */
  readonly giftCardCreate?: Maybe<GiftCardCreate>;
  /**
   * Deactivate a gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_STATUS_CHANGED (async): A gift card was deactivated.
   */
  readonly giftCardDeactivate?: Maybe<GiftCardDeactivate>;
  /**
   * Deletes gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_DELETED (async): A gift card was deleted.
   */
  readonly giftCardDelete?: Maybe<GiftCardDelete>;
  /**
   * Resend a gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - NOTIFY_USER (async): A notification for gift card resend.
   */
  readonly giftCardResend?: Maybe<GiftCardResend>;
  /**
   * Update gift card settings.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  readonly giftCardSettingsUpdate?: Maybe<GiftCardSettingsUpdate>;
  /**
   * Update a gift card.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   *
   * Triggers the following webhook events:
   * - GIFT_CARD_UPDATED (async): A gift card was updated.
   */
  readonly giftCardUpdate?: Maybe<GiftCardUpdate>;
  /**
   * Creates a ready to send invoice.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly invoiceCreate?: Maybe<InvoiceCreate>;
  /**
   * Deletes an invoice.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly invoiceDelete?: Maybe<InvoiceDelete>;
  /**
   * Request an invoice for the order using plugin.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   *
   * Triggers the following webhook events:
   * - INVOICE_REQUESTED (async): An invoice was requested.
   */
  readonly invoiceRequest?: Maybe<InvoiceRequest>;
  /**
   * Requests deletion of an invoice.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   *
   * Triggers the following webhook events:
   * - INVOICE_DELETED (async): An invoice was requested to delete.
   */
  readonly invoiceRequestDelete?: Maybe<InvoiceRequestDelete>;
  /**
   * Send an invoice notification to the customer.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   *
   * Triggers the following webhook events:
   * - INVOICE_SENT (async): A notification for invoice send
   * - NOTIFY_USER (async): A notification for invoice send
   */
  readonly invoiceSendNotification?: Maybe<InvoiceSendNotification>;
  /**
   * Updates an invoice.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly invoiceUpdate?: Maybe<InvoiceUpdate>;
  /**
   * Deletes menus.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_DELETED (async): A menu was deleted.
   */
  readonly menuBulkDelete?: Maybe<MenuBulkDelete>;
  /**
   * Creates a new Menu.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_CREATED (async): A menu was created.
   */
  readonly menuCreate?: Maybe<MenuCreate>;
  /**
   * Deletes a menu.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_DELETED (async): A menu was deleted.
   */
  readonly menuDelete?: Maybe<MenuDelete>;
  /**
   * Deletes menu items.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_ITEM_DELETED (async): A menu item was deleted.
   */
  readonly menuItemBulkDelete?: Maybe<MenuItemBulkDelete>;
  /**
   * Creates a new menu item.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_ITEM_CREATED (async): A menu item was created.
   */
  readonly menuItemCreate?: Maybe<MenuItemCreate>;
  /**
   * Deletes a menu item.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_ITEM_DELETED (async): A menu item was deleted.
   */
  readonly menuItemDelete?: Maybe<MenuItemDelete>;
  /**
   * Moves items of menus.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_ITEM_UPDATED (async): Optionally triggered when sort order or parent changed for menu item.
   */
  readonly menuItemMove?: Maybe<MenuItemMove>;
  /**
   * Creates/updates translations for a menu item.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly menuItemTranslate?: Maybe<MenuItemTranslate>;
  /**
   * Updates a menu item.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_ITEM_UPDATED (async): A menu item was updated.
   */
  readonly menuItemUpdate?: Maybe<MenuItemUpdate>;
  /**
   * Updates a menu.
   *
   * Requires one of the following permissions: MANAGE_MENUS.
   *
   * Triggers the following webhook events:
   * - MENU_UPDATED (async): A menu was updated.
   */
  readonly menuUpdate?: Maybe<MenuUpdate>;
  /**
   * Adds note to the order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   * @deprecated Use `orderNoteAdd` instead.
   */
  readonly orderAddNote?: Maybe<OrderAddNote>;
  /**
   * Cancels orders.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderBulkCancel?: Maybe<OrderBulkCancel>;
  /**
   * Creates multiple orders.
   *
   * Requires one of the following permissions: MANAGE_ORDERS_IMPORT.
   */
  readonly orderBulkCreate?: Maybe<OrderBulkCreate>;
  /**
   * Cancel an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderCancel?: Maybe<OrderCancel>;
  /**
   * Capture an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderCapture?: Maybe<OrderCapture>;
  /**
   * Confirms an unconfirmed order by changing status to unfulfilled.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderConfirm?: Maybe<OrderConfirm>;
  /**
   * Create new order from existing checkout. Requires the following permissions: AUTHENTICATED_APP and HANDLE_CHECKOUTS.
   *
   * Triggers the following webhook events:
   * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
   * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
   * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
   * - ORDER_CREATED (async): Triggered when order is created.
   * - NOTIFY_USER (async): A notification for order placement.
   * - NOTIFY_USER (async): A staff notification for order placement.
   * - ORDER_UPDATED (async): Triggered when order received the update after placement.
   * - ORDER_PAID (async): Triggered when newly created order is paid.
   * - ORDER_FULLY_PAID (async): Triggered when newly created order is fully paid.
   * - ORDER_CONFIRMED (async): Optionally triggered when newly created order are automatically marked as confirmed.
   */
  readonly orderCreateFromCheckout?: Maybe<OrderCreateFromCheckout>;
  /**
   * Adds discount to the order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderDiscountAdd?: Maybe<OrderDiscountAdd>;
  /**
   * Remove discount from the order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderDiscountDelete?: Maybe<OrderDiscountDelete>;
  /**
   * Update discount for the order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderDiscountUpdate?: Maybe<OrderDiscountUpdate>;
  /**
   * Creates new fulfillments for an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   *
   * Triggers the following webhook events:
   * - FULFILLMENT_CREATED (async): A new fulfillment is created.
   * - ORDER_FULFILLED (async): Order is fulfilled.
   * - FULFILLMENT_TRACKING_NUMBER_UPDATED (async): Sent when fulfillment tracking number is updated.
   * - FULFILLMENT_APPROVED (async): A fulfillment is approved.
   */
  readonly orderFulfill?: Maybe<OrderFulfill>;
  /**
   * Approve existing fulfillment.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   *
   * Triggers the following webhook events:
   * - FULFILLMENT_APPROVED (async): Fulfillment is approved.
   */
  readonly orderFulfillmentApprove?: Maybe<FulfillmentApprove>;
  /**
   * Cancels existing fulfillment and optionally restocks items.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderFulfillmentCancel?: Maybe<FulfillmentCancel>;
  /**
   * Refund products.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderFulfillmentRefundProducts?: Maybe<FulfillmentRefundProducts>;
  /**
   * Return products.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderFulfillmentReturnProducts?: Maybe<FulfillmentReturnProducts>;
  /**
   * Updates a fulfillment for an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   *
   * Triggers the following webhook events:
   * - FULFILLMENT_TRACKING_NUMBER_UPDATED (async): Fulfillment tracking number is updated.
   */
  readonly orderFulfillmentUpdateTracking?: Maybe<FulfillmentUpdateTracking>;
  /**
   * Adds granted refund to the order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderGrantRefundCreate?: Maybe<OrderGrantRefundCreate>;
  /**
   * Updates granted refund.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderGrantRefundUpdate?: Maybe<OrderGrantRefundUpdate>;
  /**
   * Deletes an order line from an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderLineDelete?: Maybe<OrderLineDelete>;
  /**
   * Remove discount applied to the order line.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderLineDiscountRemove?: Maybe<OrderLineDiscountRemove>;
  /**
   * Update discount for the order line.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderLineDiscountUpdate?: Maybe<OrderLineDiscountUpdate>;
  /**
   * Updates an order line of an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderLineUpdate?: Maybe<OrderLineUpdate>;
  /**
   * Creates order lines for an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderLinesCreate?: Maybe<OrderLinesCreate>;
  /**
   * Mark order as manually paid.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderMarkAsPaid?: Maybe<OrderMarkAsPaid>;
  /**
   * Adds note to the order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderNoteAdd?: Maybe<OrderNoteAdd>;
  /**
   * Updates note of an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderNoteUpdate?: Maybe<OrderNoteUpdate>;
  /**
   * Refund an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderRefund?: Maybe<OrderRefund>;
  /**
   * Update shop order settings across all channels. Returns `orderSettings` for the first `channel` in alphabetical order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   * @deprecated Use `channelUpdate` mutation instead.
   */
  readonly orderSettingsUpdate?: Maybe<OrderSettingsUpdate>;
  /**
   * Updates an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderUpdate?: Maybe<OrderUpdate>;
  /**
   * Updates a shipping method of the order. Requires shipping method ID to update, when null is passed then currently assigned shipping method is removed.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderUpdateShipping?: Maybe<OrderUpdateShipping>;
  /**
   * Void an order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orderVoid?: Maybe<OrderVoid>;
  /**
   * Assign attributes to a given page type.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  readonly pageAttributeAssign?: Maybe<PageAttributeAssign>;
  /**
   * Unassign attributes from a given page type.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  readonly pageAttributeUnassign?: Maybe<PageAttributeUnassign>;
  /**
   * Deletes pages.
   *
   * Requires one of the following permissions: MANAGE_PAGES.
   */
  readonly pageBulkDelete?: Maybe<PageBulkDelete>;
  /**
   * Publish pages.
   *
   * Requires one of the following permissions: MANAGE_PAGES.
   */
  readonly pageBulkPublish?: Maybe<PageBulkPublish>;
  /**
   * Creates a new page.
   *
   * Requires one of the following permissions: MANAGE_PAGES.
   */
  readonly pageCreate?: Maybe<PageCreate>;
  /**
   * Deletes a page.
   *
   * Requires one of the following permissions: MANAGE_PAGES.
   */
  readonly pageDelete?: Maybe<PageDelete>;
  /**
   * Reorder page attribute values.
   *
   * Requires one of the following permissions: MANAGE_PAGES.
   */
  readonly pageReorderAttributeValues?: Maybe<PageReorderAttributeValues>;
  /**
   * Creates/updates translations for a page.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly pageTranslate?: Maybe<PageTranslate>;
  /**
   * Deletes page types.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  readonly pageTypeBulkDelete?: Maybe<PageTypeBulkDelete>;
  /**
   * Creates a new page type.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  readonly pageTypeCreate?: Maybe<PageTypeCreate>;
  /**
   * Deletes a page type.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  readonly pageTypeDelete?: Maybe<PageTypeDelete>;
  /**
   * Reorder the attributes of a page type.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  readonly pageTypeReorderAttributes?: Maybe<PageTypeReorderAttributes>;
  /**
   * Updates page type.
   *
   * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  readonly pageTypeUpdate?: Maybe<PageTypeUpdate>;
  /**
   * Updates an existing page.
   *
   * Requires one of the following permissions: MANAGE_PAGES.
   */
  readonly pageUpdate?: Maybe<PageUpdate>;
  /**
   * Change the password of the logged in user.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   */
  readonly passwordChange?: Maybe<PasswordChange>;
  /**
   * Captures the authorized payment amount.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly paymentCapture?: Maybe<PaymentCapture>;
  /** Check payment balance. */
  readonly paymentCheckBalance?: Maybe<PaymentCheckBalance>;
  /** Initializes a payment gateway session. It triggers the webhook `PAYMENT_GATEWAY_INITIALIZE_SESSION`, to the requested `paymentGateways`. If `paymentGateways` is not provided, the webhook will be send to all subscribed payment gateways. There is a limit of 100 transaction items per checkout / order. */
  readonly paymentGatewayInitialize?: Maybe<PaymentGatewayInitialize>;
  /**
   * Initializes payment gateway for tokenizing payment method session.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION (sync): The customer requested to initialize payment gateway for tokenization.
   */
  readonly paymentGatewayInitializeTokenization?: Maybe<PaymentGatewayInitializeTokenization>;
  /** Initializes payment process when it is required by gateway. */
  readonly paymentInitialize?: Maybe<PaymentInitialize>;
  /**
   * Tokenize payment method.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION (sync): The customer requested to tokenize payment method.
   */
  readonly paymentMethodInitializeTokenization?: Maybe<PaymentMethodInitializeTokenization>;
  /**
   * Tokenize payment method.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION (sync): The customer continues payment method tokenization.
   */
  readonly paymentMethodProcessTokenization?: Maybe<PaymentMethodProcessTokenization>;
  /**
   * Refunds the captured payment amount.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly paymentRefund?: Maybe<PaymentRefund>;
  /**
   * Voids the authorized payment.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly paymentVoid?: Maybe<PaymentVoid>;
  /**
   * Create new permission group. Apps are not allowed to perform this mutation.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   *
   * Triggers the following webhook events:
   * - PERMISSION_GROUP_CREATED (async)
   */
  readonly permissionGroupCreate?: Maybe<PermissionGroupCreate>;
  /**
   * Delete permission group. Apps are not allowed to perform this mutation.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   *
   * Triggers the following webhook events:
   * - PERMISSION_GROUP_DELETED (async)
   */
  readonly permissionGroupDelete?: Maybe<PermissionGroupDelete>;
  /**
   * Update permission group. Apps are not allowed to perform this mutation.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   *
   * Triggers the following webhook events:
   * - PERMISSION_GROUP_UPDATED (async)
   */
  readonly permissionGroupUpdate?: Maybe<PermissionGroupUpdate>;
  /**
   * Update plugin configuration.
   *
   * Requires one of the following permissions: MANAGE_PLUGINS.
   */
  readonly pluginUpdate?: Maybe<PluginUpdate>;
  /**
   * Assign attributes to a given product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  readonly productAttributeAssign?: Maybe<ProductAttributeAssign>;
  /**
   * Update attributes assigned to product variant for given product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  readonly productAttributeAssignmentUpdate?: Maybe<ProductAttributeAssignmentUpdate>;
  /**
   * Un-assign attributes from a given product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  readonly productAttributeUnassign?: Maybe<ProductAttributeUnassign>;
  /**
   * Creates products.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productBulkCreate?: Maybe<ProductBulkCreate>;
  /**
   * Deletes products.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productBulkDelete?: Maybe<ProductBulkDelete>;
  /**
   * Creates/updates translations for products.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   *
   * Triggers the following webhook events:
   * - TRANSLATION_CREATED (async): Called when a translation was created.
   * - TRANSLATION_UPDATED (async): Called when a translation was updated.
   */
  readonly productBulkTranslate?: Maybe<ProductBulkTranslate>;
  /**
   * Manage product's availability in channels.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productChannelListingUpdate?: Maybe<ProductChannelListingUpdate>;
  /**
   * Creates a new product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productCreate?: Maybe<ProductCreate>;
  /**
   * Deletes a product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productDelete?: Maybe<ProductDelete>;
  /**
   * Deletes product media.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productMediaBulkDelete?: Maybe<ProductMediaBulkDelete>;
  /**
   * Create a media object (image or video URL) associated with product. For image, this mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productMediaCreate?: Maybe<ProductMediaCreate>;
  /**
   * Deletes a product media.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productMediaDelete?: Maybe<ProductMediaDelete>;
  /**
   * Changes ordering of the product media.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productMediaReorder?: Maybe<ProductMediaReorder>;
  /**
   * Updates a product media.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productMediaUpdate?: Maybe<ProductMediaUpdate>;
  /**
   * Reorder product attribute values.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productReorderAttributeValues?: Maybe<ProductReorderAttributeValues>;
  /**
   * Creates/updates translations for a product.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly productTranslate?: Maybe<ProductTranslate>;
  /**
   * Deletes product types.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  readonly productTypeBulkDelete?: Maybe<ProductTypeBulkDelete>;
  /**
   * Creates a new product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  readonly productTypeCreate?: Maybe<ProductTypeCreate>;
  /**
   * Deletes a product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  readonly productTypeDelete?: Maybe<ProductTypeDelete>;
  /**
   * Reorder the attributes of a product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  readonly productTypeReorderAttributes?: Maybe<ProductTypeReorderAttributes>;
  /**
   * Updates an existing product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
   */
  readonly productTypeUpdate?: Maybe<ProductTypeUpdate>;
  /**
   * Updates an existing product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productUpdate?: Maybe<ProductUpdate>;
  /**
   * Creates product variants for a given product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productVariantBulkCreate?: Maybe<ProductVariantBulkCreate>;
  /**
   * Deletes product variants.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productVariantBulkDelete?: Maybe<ProductVariantBulkDelete>;
  /**
   * Creates/updates translations for product variants.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   *
   * Triggers the following webhook events:
   * - TRANSLATION_CREATED (async): A translation was created.
   * - TRANSLATION_UPDATED (async): A translation was updated.
   */
  readonly productVariantBulkTranslate?: Maybe<ProductVariantBulkTranslate>;
  /**
   * Updates multiple product variants.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productVariantBulkUpdate?: Maybe<ProductVariantBulkUpdate>;
  /**
   * Manage product variant prices in channels.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productVariantChannelListingUpdate?: Maybe<ProductVariantChannelListingUpdate>;
  /**
   * Creates a new variant for a product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productVariantCreate?: Maybe<ProductVariantCreate>;
  /**
   * Deletes a product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productVariantDelete?: Maybe<ProductVariantDelete>;
  /**
   * Deactivates product variant preorder. It changes all preorder allocation into regular allocation.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productVariantPreorderDeactivate?: Maybe<ProductVariantPreorderDeactivate>;
  /**
   * Reorder the variants of a product. Mutation updates updated_at on product and triggers PRODUCT_UPDATED webhook.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productVariantReorder?: Maybe<ProductVariantReorder>;
  /**
   * Reorder product variant attribute values.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productVariantReorderAttributeValues?: Maybe<ProductVariantReorderAttributeValues>;
  /**
   * Set default variant for a product. Mutation triggers PRODUCT_UPDATED webhook.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productVariantSetDefault?: Maybe<ProductVariantSetDefault>;
  /**
   * Creates stocks for product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productVariantStocksCreate?: Maybe<ProductVariantStocksCreate>;
  /**
   * Deletes stocks from product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productVariantStocksDelete?: Maybe<ProductVariantStocksDelete>;
  /**
   * Updates stocks for product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productVariantStocksUpdate?: Maybe<ProductVariantStocksUpdate>;
  /**
   * Creates/updates translations for a product variant.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly productVariantTranslate?: Maybe<ProductVariantTranslate>;
  /**
   * Updates an existing variant for product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly productVariantUpdate?: Maybe<ProductVariantUpdate>;
  /**
   * Deletes promotions.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - PROMOTION_DELETED (async): A promotion was deleted.
   */
  readonly promotionBulkDelete?: Maybe<PromotionBulkDelete>;
  /**
   * Creates a new promotion.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - PROMOTION_CREATED (async): A promotion was created.
   * - PROMOTION_STARTED (async): Optionally called if promotion was started.
   */
  readonly promotionCreate?: Maybe<PromotionCreate>;
  /**
   * Deletes a promotion.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - PROMOTION_DELETED (async): A promotion was deleted.
   */
  readonly promotionDelete?: Maybe<PromotionDelete>;
  /**
   * Creates a new promotion rule.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - PROMOTION_RULE_CREATED (async): A promotion rule was created.
   */
  readonly promotionRuleCreate?: Maybe<PromotionRuleCreate>;
  /**
   * Deletes a promotion rule.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - PROMOTION_RULE_DELETED (async): A promotion rule was deleted.
   */
  readonly promotionRuleDelete?: Maybe<PromotionRuleDelete>;
  /**
   * Creates/updates translations for a promotion rule.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly promotionRuleTranslate?: Maybe<PromotionRuleTranslate>;
  /**
   * Updates an existing promotion rule.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - PROMOTION_RULE_UPDATED (async): A promotion rule was updated.
   */
  readonly promotionRuleUpdate?: Maybe<PromotionRuleUpdate>;
  /**
   * Creates/updates translations for a promotion.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly promotionTranslate?: Maybe<PromotionTranslate>;
  /**
   * Updates an existing promotion.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - PROMOTION_UPDATED (async): A promotion was updated.
   * - PROMOTION_STARTED (async): Optionally called if promotion was started.
   * - PROMOTION_ENDED (async): Optionally called if promotion was ended.
   */
  readonly promotionUpdate?: Maybe<PromotionUpdate>;
  /**
   * Updates RefundSettings. The `Page` (Model) Type will be cleared from `reasonReferenceType`. When it's cleared, passing reason reference to refund mutations is no longer accepted and will raise error.
   *
   * Added in Saleor 3.22.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly refundReasonReferenceClear?: Maybe<RefundReasonReferenceTypeClear>;
  /**
   * Update refund settings across all channels.
   *
   * Added in Saleor 3.22.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly refundSettingsUpdate?: Maybe<RefundSettingsUpdate>;
  /**
   * Request email change of the logged in user.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - NOTIFY_USER (async): A notification for account email change.
   * - ACCOUNT_CHANGE_EMAIL_REQUESTED (async): An account email change was requested.
   */
  readonly requestEmailChange?: Maybe<RequestEmailChange>;
  /**
   * Sends an email with the account password modification link.
   *
   * Triggers the following webhook events:
   * - NOTIFY_USER (async): A notification for password reset.
   * - ACCOUNT_SET_PASSWORD_REQUESTED (async): Setting a new password for the account is requested.
   * - STAFF_SET_PASSWORD_REQUESTED (async): Setting a new password for the staff account is requested.
   */
  readonly requestPasswordReset?: Maybe<RequestPasswordReset>;
  /**
   * Deletes sales.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - SALE_DELETED (async): A sale was deleted.
   */
  readonly saleBulkDelete?: Maybe<SaleBulkDelete>;
  /**
   * Adds products, categories, collections to a sale.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - SALE_UPDATED (async): A sale was updated.
   * @deprecated Use `promotionRuleCreate` and `promotionRuleUpdate` mutations instead.
   */
  readonly saleCataloguesAdd?: Maybe<SaleAddCatalogues>;
  /**
   * Removes products, categories, collections from a sale.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - SALE_UPDATED (async): A sale was updated.
   * @deprecated Use `promotionRuleUpdate` and `promotionRuleDelete` mutations instead.
   */
  readonly saleCataloguesRemove?: Maybe<SaleRemoveCatalogues>;
  /**
   * Manage sale's availability in channels.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   * @deprecated Use `promotionRuleUpdate` mutation instead.
   */
  readonly saleChannelListingUpdate?: Maybe<SaleChannelListingUpdate>;
  /**
   * Creates a new sale.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - SALE_CREATED (async): A sale was created.
   * @deprecated Use `promotionCreate` mutation instead.
   */
  readonly saleCreate?: Maybe<SaleCreate>;
  /**
   * Deletes a sale.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - SALE_DELETED (async): A sale was deleted.
   * @deprecated Use `promotionDelete` mutation instead.
   */
  readonly saleDelete?: Maybe<SaleDelete>;
  /**
   * Creates/updates translations for a sale.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   * @deprecated Use `promotionTranslate` mutation instead.
   */
  readonly saleTranslate?: Maybe<SaleTranslate>;
  /**
   * Updates a sale.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - SALE_UPDATED (async): A sale was updated.
   * - SALE_TOGGLE (async): Optionally triggered when a sale is started or stopped.
   * @deprecated Use `promotionUpdate` mutation instead.
   */
  readonly saleUpdate?: Maybe<SaleUpdate>;
  /**
   * Sends a notification confirmation.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - NOTIFY_USER (async): A notification for account confirmation.
   * - ACCOUNT_CONFIRMATION_REQUESTED (async): An account confirmation was requested. This event is always sent regardless of settings.
   */
  readonly sendConfirmationEmail?: Maybe<SendConfirmationEmail>;
  /** Sets the user's password from the token sent by email using the RequestPasswordReset mutation. */
  readonly setPassword?: Maybe<SetPassword>;
  /**
   * Manage shipping method's availability in channels.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly shippingMethodChannelListingUpdate?: Maybe<ShippingMethodChannelListingUpdate>;
  /**
   * Deletes shipping prices.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly shippingPriceBulkDelete?: Maybe<ShippingPriceBulkDelete>;
  /**
   * Creates a new shipping price.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly shippingPriceCreate?: Maybe<ShippingPriceCreate>;
  /**
   * Deletes a shipping price.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly shippingPriceDelete?: Maybe<ShippingPriceDelete>;
  /**
   * Exclude products from shipping price.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly shippingPriceExcludeProducts?: Maybe<ShippingPriceExcludeProducts>;
  /**
   * Remove product from excluded list for shipping price.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly shippingPriceRemoveProductFromExclude?: Maybe<ShippingPriceRemoveProductFromExclude>;
  /**
   * Creates/updates translations for a shipping method.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly shippingPriceTranslate?: Maybe<ShippingPriceTranslate>;
  /**
   * Updates a new shipping price.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly shippingPriceUpdate?: Maybe<ShippingPriceUpdate>;
  /**
   * Deletes shipping zones.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly shippingZoneBulkDelete?: Maybe<ShippingZoneBulkDelete>;
  /**
   * Creates a new shipping zone.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly shippingZoneCreate?: Maybe<ShippingZoneCreate>;
  /**
   * Deletes a shipping zone.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly shippingZoneDelete?: Maybe<ShippingZoneDelete>;
  /**
   * Updates a new shipping zone.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly shippingZoneUpdate?: Maybe<ShippingZoneUpdate>;
  /**
   * Update the shop's address. If the `null` value is passed, the currently selected address will be deleted.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly shopAddressUpdate?: Maybe<ShopAddressUpdate>;
  /**
   * Updates site domain of the shop.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   * @deprecated Use `PUBLIC_URL` environment variable instead.
   */
  readonly shopDomainUpdate?: Maybe<ShopDomainUpdate>;
  /**
   * Fetch tax rates.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   * @deprecated Field no longer supported
   */
  readonly shopFetchTaxRates?: Maybe<ShopFetchTaxRates>;
  /**
   * Creates/updates translations for shop settings.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly shopSettingsTranslate?: Maybe<ShopSettingsTranslate>;
  /**
   * Updates shop settings.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   *
   * Triggers the following webhook events:
   * - SHOP_METADATA_UPDATED (async): Optionally triggered when public or private metadata is updated.
   */
  readonly shopSettingsUpdate?: Maybe<ShopSettingsUpdate>;
  /**
   * Deletes staff users. Apps are not allowed to perform this mutation.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   *
   * Triggers the following webhook events:
   * - STAFF_DELETED (async): A staff account was deleted.
   */
  readonly staffBulkDelete?: Maybe<StaffBulkDelete>;
  /**
   * Creates a new staff user. Apps are not allowed to perform this mutation.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   *
   * Triggers the following webhook events:
   * - STAFF_CREATED (async): A new staff account was created.
   * - NOTIFY_USER (async): A notification for setting the password.
   * - STAFF_SET_PASSWORD_REQUESTED (async): Setting a new password for the staff account is requested.
   */
  readonly staffCreate?: Maybe<StaffCreate>;
  /**
   * Deletes a staff user. Apps are not allowed to perform this mutation.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   *
   * Triggers the following webhook events:
   * - STAFF_DELETED (async): A staff account was deleted.
   */
  readonly staffDelete?: Maybe<StaffDelete>;
  /**
   * Creates a new staff notification recipient.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly staffNotificationRecipientCreate?: Maybe<StaffNotificationRecipientCreate>;
  /**
   * Deletes staff notification recipient.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly staffNotificationRecipientDelete?: Maybe<StaffNotificationRecipientDelete>;
  /**
   * Updates a staff notification recipient.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly staffNotificationRecipientUpdate?: Maybe<StaffNotificationRecipientUpdate>;
  /**
   * Updates an existing staff user. Apps are not allowed to perform this mutation.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   *
   * Triggers the following webhook events:
   * - STAFF_UPDATED (async): A staff account was updated.
   */
  readonly staffUpdate?: Maybe<StaffUpdate>;
  /**
   * Updates stocks for a given variant and warehouse. Variant and warehouse selectors have to be the same for all stock inputs. Is not allowed to use 'variantId' in one input and 'variantExternalReference' in another.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   *
   * Triggers the following webhook events:
   * - PRODUCT_VARIANT_STOCK_UPDATED (async): A product variant stock details were updated.
   */
  readonly stockBulkUpdate?: Maybe<StockBulkUpdate>;
  /**
   * Request to delete a stored payment method on payment provider side.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   *
   * Triggers the following webhook events:
   * - STORED_PAYMENT_METHOD_DELETE_REQUESTED (sync): The customer requested to delete a payment method.
   */
  readonly storedPaymentMethodRequestDelete?: Maybe<StoredPaymentMethodRequestDelete>;
  /**
   * Creates a tax class.
   *
   * Requires one of the following permissions: MANAGE_TAXES.
   */
  readonly taxClassCreate?: Maybe<TaxClassCreate>;
  /**
   * Deletes a tax class. After deleting the tax class any products, product types or shipping methods using it are updated to use the default tax class.
   *
   * Requires one of the following permissions: MANAGE_TAXES.
   */
  readonly taxClassDelete?: Maybe<TaxClassDelete>;
  /**
   * Updates a tax class.
   *
   * Requires one of the following permissions: MANAGE_TAXES.
   */
  readonly taxClassUpdate?: Maybe<TaxClassUpdate>;
  /**
   * Updates tax configuration for a channel.
   *
   * Requires one of the following permissions: MANAGE_TAXES.
   */
  readonly taxConfigurationUpdate?: Maybe<TaxConfigurationUpdate>;
  /**
   * Remove all tax class rates for a specific country.
   *
   * Requires one of the following permissions: MANAGE_TAXES.
   */
  readonly taxCountryConfigurationDelete?: Maybe<TaxCountryConfigurationDelete>;
  /**
   * Updates tax class rates for a specific country.
   *
   * Requires one of the following permissions: MANAGE_TAXES.
   */
  readonly taxCountryConfigurationUpdate?: Maybe<TaxCountryConfigurationUpdate>;
  /**
   * Exempt checkout or order from charging the taxes. When tax exemption is enabled, taxes won't be charged for the checkout or order. Taxes may still be calculated in cases when product prices are entered with the tax included and the net price needs to be known.
   *
   * Requires one of the following permissions: MANAGE_TAXES.
   */
  readonly taxExemptionManage?: Maybe<TaxExemptionManage>;
  /** Create JWT token. */
  readonly tokenCreate?: Maybe<CreateToken>;
  /** Refresh JWT token. Mutation tries to take refreshToken from the input. If it fails it will try to take `refreshToken` from the http-only cookie `refreshToken`. `csrfToken` is required when `refreshToken` is provided as a cookie. */
  readonly tokenRefresh?: Maybe<RefreshToken>;
  /** Verify JWT token. */
  readonly tokenVerify?: Maybe<VerifyToken>;
  /**
   * Deactivate all JWT tokens of the currently authenticated user.
   *
   * Requires one of the following permissions: AUTHENTICATED_USER.
   */
  readonly tokensDeactivateAll?: Maybe<DeactivateAllUserTokens>;
  /**
   * Creates transaction for checkout or order.
   *
   * Requires one of the following permissions: HANDLE_PAYMENTS.
   */
  readonly transactionCreate?: Maybe<TransactionCreate>;
  /**
   * Report the event for the transaction.
   *
   * Requires the following permissions: OWNER and HANDLE_PAYMENTS for apps, HANDLE_PAYMENTS for staff users. Staff user cannot update a transaction that is owned by the app.
   *
   * Triggers the following webhook events:
   * - TRANSACTION_ITEM_METADATA_UPDATED (async): Optionally called when transaction's metadata was updated.
   * - CHECKOUT_FULLY_PAID (async): Optionally called when the checkout charge status changed to `FULL` or `OVERCHARGED`.
   * - ORDER_UPDATED (async): Optionally called when the transaction is related to the order and the order was updated.
   */
  readonly transactionEventReport?: Maybe<TransactionEventReport>;
  /** Initializes a transaction session. It triggers the webhook `TRANSACTION_INITIALIZE_SESSION`, to the requested `paymentGateways`. There is a limit of 100 transaction items per checkout / order. */
  readonly transactionInitialize?: Maybe<TransactionInitialize>;
  /** Processes a transaction session. It triggers the webhook `TRANSACTION_PROCESS_SESSION`, to the assigned `paymentGateways`. */
  readonly transactionProcess?: Maybe<TransactionProcess>;
  /**
   * Request an action for payment transaction.
   *
   * Requires one of the following permissions: HANDLE_PAYMENTS.
   */
  readonly transactionRequestAction?: Maybe<TransactionRequestAction>;
  /**
   * Request a refund for payment transaction based on granted refund.
   *
   * Requires one of the following permissions: HANDLE_PAYMENTS.
   */
  readonly transactionRequestRefundForGrantedRefund?: Maybe<TransactionRequestRefundForGrantedRefund>;
  /**
   * Update transaction.
   *
   * Requires the following permissions: OWNER and HANDLE_PAYMENTS for apps, HANDLE_PAYMENTS for staff users. Staff user cannot update a transaction that is owned by the app.
   */
  readonly transactionUpdate?: Maybe<TransactionUpdate>;
  /**
   * Remove shipping zone from given warehouse.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly unassignWarehouseShippingZone?: Maybe<WarehouseShippingZoneUnassign>;
  /**
   * Updates metadata of an object.Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly updateMetadata?: Maybe<UpdateMetadata>;
  /**
   * Updates private metadata of an object. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly updatePrivateMetadata?: Maybe<UpdatePrivateMetadata>;
  /**
   * Updates given warehouse.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly updateWarehouse?: Maybe<WarehouseUpdate>;
  /**
   * Deletes a user avatar. Only for staff members.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
   */
  readonly userAvatarDelete?: Maybe<UserAvatarDelete>;
  /**
   * Create a user avatar. Only for staff members. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
   */
  readonly userAvatarUpdate?: Maybe<UserAvatarUpdate>;
  /**
   * Activate or deactivate users.
   *
   * Requires one of the following permissions: MANAGE_USERS.
   */
  readonly userBulkSetActive?: Maybe<UserBulkSetActive>;
  /**
   * Assign an media to a product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly variantMediaAssign?: Maybe<VariantMediaAssign>;
  /**
   * Unassign an media from a product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly variantMediaUnassign?: Maybe<VariantMediaUnassign>;
  /**
   * Deletes vouchers.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_DELETED (async): A voucher was deleted.
   */
  readonly voucherBulkDelete?: Maybe<VoucherBulkDelete>;
  /**
   * Adds products, categories, collections to a voucher.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_UPDATED (async): A voucher was updated.
   */
  readonly voucherCataloguesAdd?: Maybe<VoucherAddCatalogues>;
  /**
   * Removes products, categories, collections from a voucher.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_UPDATED (async): A voucher was updated.
   */
  readonly voucherCataloguesRemove?: Maybe<VoucherRemoveCatalogues>;
  /**
   * Manage voucher's availability in channels.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_UPDATED (async): A voucher was updated.
   */
  readonly voucherChannelListingUpdate?: Maybe<VoucherChannelListingUpdate>;
  /**
   * Deletes voucher codes.
   *
   * Added in Saleor 3.18.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_CODES_DELETED (async): A voucher codes were deleted.
   */
  readonly voucherCodeBulkDelete?: Maybe<VoucherCodeBulkDelete>;
  /**
   * Creates a new voucher.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_CREATED (async): A voucher was created.
   * - VOUCHER_CODES_CREATED (async): A voucher codes were created.
   */
  readonly voucherCreate?: Maybe<VoucherCreate>;
  /**
   * Deletes a voucher.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_DELETED (async): A voucher was deleted.
   */
  readonly voucherDelete?: Maybe<VoucherDelete>;
  /**
   * Creates/updates translations for a voucher.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly voucherTranslate?: Maybe<VoucherTranslate>;
  /**
   * Updates a voucher.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   *
   * Triggers the following webhook events:
   * - VOUCHER_UPDATED (async): A voucher was updated.
   * - VOUCHER_CODES_CREATED (async): A voucher code was created.
   */
  readonly voucherUpdate?: Maybe<VoucherUpdate>;
  /**
   * Creates a new webhook subscription.
   *
   * Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP.
   */
  readonly webhookCreate?: Maybe<WebhookCreate>;
  /**
   * Deletes a webhook. Before the deletion, the webhook is deactivated to pause any deliveries that are already scheduled. The deletion might fail if delivery is in progress. In such a case, the webhook is not deleted but remains deactivated.
   *
   * Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP.
   */
  readonly webhookDelete?: Maybe<WebhookDelete>;
  /**
   * Performs a dry run of a webhook event. Supports a single event (the first, if multiple provided in the `query`). Requires permission relevant to processed event.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
   */
  readonly webhookDryRun?: Maybe<WebhookDryRun>;
  /**
   * Trigger a webhook event. Supports a single event (the first, if multiple provided in the `webhook.subscription_query`). Requires permission relevant to processed event. Successfully delivered webhook returns `delivery` with status='PENDING' and empty payload.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
   */
  readonly webhookTrigger?: Maybe<WebhookTrigger>;
  /**
   * Updates a webhook subscription.
   *
   * Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP.
   */
  readonly webhookUpdate?: Maybe<WebhookUpdate>;
};


export type MutationAccountAddressCreateArgs = {
  customerId?: InputMaybe<Scalars['ID']['input']>;
  input: AddressInput;
  type?: InputMaybe<AddressTypeEnum>;
};


export type MutationAccountAddressDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAccountAddressUpdateArgs = {
  id: Scalars['ID']['input'];
  input: AddressInput;
};


export type MutationAccountDeleteArgs = {
  token: Scalars['String']['input'];
};


export type MutationAccountRegisterArgs = {
  input: AccountRegisterInput;
};


export type MutationAccountRequestDeletionArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  redirectUrl: Scalars['String']['input'];
};


export type MutationAccountSetDefaultAddressArgs = {
  id: Scalars['ID']['input'];
  type: AddressTypeEnum;
};


export type MutationAccountUpdateArgs = {
  customerId?: InputMaybe<Scalars['ID']['input']>;
  input: AccountInput;
};


export type MutationAddressCreateArgs = {
  input: AddressInput;
  userId: Scalars['ID']['input'];
};


export type MutationAddressDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAddressSetDefaultArgs = {
  addressId: Scalars['ID']['input'];
  type: AddressTypeEnum;
  userId: Scalars['ID']['input'];
};


export type MutationAddressUpdateArgs = {
  id: Scalars['ID']['input'];
  input: AddressInput;
};


export type MutationAppActivateArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAppCreateArgs = {
  input: AppInput;
};


export type MutationAppDeactivateArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAppDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAppDeleteFailedInstallationArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAppFetchManifestArgs = {
  manifestUrl: Scalars['String']['input'];
};


export type MutationAppInstallArgs = {
  input: AppInstallInput;
};


export type MutationAppReenableSyncWebhooksArgs = {
  appId: Scalars['ID']['input'];
};


export type MutationAppRetryInstallArgs = {
  activateAfterInstallation?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
};


export type MutationAppTokenCreateArgs = {
  input: AppTokenInput;
};


export type MutationAppTokenDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAppTokenVerifyArgs = {
  token: Scalars['String']['input'];
};


export type MutationAppUpdateArgs = {
  id: Scalars['ID']['input'];
  input: AppInput;
};


export type MutationAssignNavigationArgs = {
  menu?: InputMaybe<Scalars['ID']['input']>;
  navigationType: NavigationType;
};


export type MutationAssignWarehouseShippingZoneArgs = {
  id: Scalars['ID']['input'];
  shippingZoneIds: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationAttributeBulkCreateArgs = {
  attributes: ReadonlyArray<AttributeCreateInput>;
  errorPolicy?: InputMaybe<ErrorPolicyEnum>;
};


export type MutationAttributeBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationAttributeBulkTranslateArgs = {
  errorPolicy?: InputMaybe<ErrorPolicyEnum>;
  translations: ReadonlyArray<AttributeBulkTranslateInput>;
};


export type MutationAttributeBulkUpdateArgs = {
  attributes: ReadonlyArray<AttributeBulkUpdateInput>;
  errorPolicy?: InputMaybe<ErrorPolicyEnum>;
};


export type MutationAttributeCreateArgs = {
  input: AttributeCreateInput;
};


export type MutationAttributeDeleteArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationAttributeReorderValuesArgs = {
  attributeId: Scalars['ID']['input'];
  moves: ReadonlyArray<ReorderInput>;
};


export type MutationAttributeTranslateArgs = {
  id: Scalars['ID']['input'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationAttributeUpdateArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  input: AttributeUpdateInput;
};


export type MutationAttributeValueBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationAttributeValueBulkTranslateArgs = {
  errorPolicy?: InputMaybe<ErrorPolicyEnum>;
  translations: ReadonlyArray<AttributeValueBulkTranslateInput>;
};


export type MutationAttributeValueCreateArgs = {
  attribute: Scalars['ID']['input'];
  input: AttributeValueCreateInput;
};


export type MutationAttributeValueDeleteArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationAttributeValueTranslateArgs = {
  id: Scalars['ID']['input'];
  input: AttributeValueTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationAttributeValueUpdateArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  input: AttributeValueUpdateInput;
};


export type MutationCategoryBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationCategoryCreateArgs = {
  input: CategoryInput;
  parent?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCategoryDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationCategoryTranslateArgs = {
  id: Scalars['ID']['input'];
  input: TranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationCategoryUpdateArgs = {
  id: Scalars['ID']['input'];
  input: CategoryInput;
};


export type MutationChannelActivateArgs = {
  id: Scalars['ID']['input'];
};


export type MutationChannelCreateArgs = {
  input: ChannelCreateInput;
};


export type MutationChannelDeactivateArgs = {
  id: Scalars['ID']['input'];
};


export type MutationChannelDeleteArgs = {
  id: Scalars['ID']['input'];
  input?: InputMaybe<ChannelDeleteInput>;
};


export type MutationChannelReorderWarehousesArgs = {
  channelId: Scalars['ID']['input'];
  moves: ReadonlyArray<ReorderInput>;
};


export type MutationChannelUpdateArgs = {
  id: Scalars['ID']['input'];
  input: ChannelUpdateInput;
};


export type MutationCheckoutAddPromoCodeArgs = {
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  promoCode: Scalars['String']['input'];
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationCheckoutBillingAddressUpdateArgs = {
  billingAddress: AddressInput;
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  saveAddress?: InputMaybe<Scalars['Boolean']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
  validationRules?: InputMaybe<CheckoutAddressValidationRules>;
};


export type MutationCheckoutCompleteArgs = {
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  paymentData?: InputMaybe<Scalars['JSONString']['input']>;
  redirectUrl?: InputMaybe<Scalars['String']['input']>;
  storeSource?: InputMaybe<Scalars['Boolean']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationCheckoutCreateArgs = {
  input: CheckoutCreateInput;
};


export type MutationCheckoutCreateFromOrderArgs = {
  id: Scalars['ID']['input'];
};


export type MutationCheckoutCustomerAttachArgs = {
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  customerId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationCheckoutCustomerDetachArgs = {
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationCheckoutCustomerNoteUpdateArgs = {
  customerNote: Scalars['String']['input'];
  id: Scalars['ID']['input'];
};


export type MutationCheckoutDeliveryMethodUpdateArgs = {
  deliveryMethodId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationCheckoutEmailUpdateArgs = {
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  email: Scalars['String']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationCheckoutLanguageCodeUpdateArgs = {
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  languageCode: LanguageCodeEnum;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationCheckoutLineDeleteArgs = {
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  lineId?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationCheckoutLinesAddArgs = {
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  lines: ReadonlyArray<CheckoutLineInput>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationCheckoutLinesDeleteArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  linesIds: ReadonlyArray<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationCheckoutLinesUpdateArgs = {
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  lines: ReadonlyArray<CheckoutLineUpdateInput>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationCheckoutPaymentCreateArgs = {
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  input: PaymentInput;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationCheckoutRemovePromoCodeArgs = {
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  promoCode?: InputMaybe<Scalars['String']['input']>;
  promoCodeId?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationCheckoutShippingAddressUpdateArgs = {
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  saveAddress?: InputMaybe<Scalars['Boolean']['input']>;
  shippingAddress: AddressInput;
  token?: InputMaybe<Scalars['UUID']['input']>;
  validationRules?: InputMaybe<CheckoutAddressValidationRules>;
};


export type MutationCheckoutShippingMethodUpdateArgs = {
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  shippingMethodId?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationCollectionAddProductsArgs = {
  collectionId: Scalars['ID']['input'];
  products: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationCollectionBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationCollectionChannelListingUpdateArgs = {
  id: Scalars['ID']['input'];
  input: CollectionChannelListingUpdateInput;
};


export type MutationCollectionCreateArgs = {
  input: CollectionCreateInput;
};


export type MutationCollectionDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationCollectionRemoveProductsArgs = {
  collectionId: Scalars['ID']['input'];
  products: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationCollectionReorderProductsArgs = {
  collectionId: Scalars['ID']['input'];
  moves: ReadonlyArray<MoveProductInput>;
};


export type MutationCollectionTranslateArgs = {
  id: Scalars['ID']['input'];
  input: TranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationCollectionUpdateArgs = {
  id: Scalars['ID']['input'];
  input: CollectionInput;
};


export type MutationConfirmAccountArgs = {
  email: Scalars['String']['input'];
  token: Scalars['String']['input'];
};


export type MutationConfirmEmailChangeArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['String']['input'];
};


export type MutationCreateWarehouseArgs = {
  input: WarehouseCreateInput;
};


export type MutationCustomerBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationCustomerBulkUpdateArgs = {
  customers: ReadonlyArray<CustomerBulkUpdateInput>;
  errorPolicy?: InputMaybe<ErrorPolicyEnum>;
};


export type MutationCustomerCreateArgs = {
  input: UserCreateInput;
};


export type MutationCustomerDeleteArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCustomerUpdateArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  input: CustomerInput;
};


export type MutationDeleteMetadataArgs = {
  id: Scalars['ID']['input'];
  keys: ReadonlyArray<Scalars['String']['input']>;
};


export type MutationDeletePrivateMetadataArgs = {
  id: Scalars['ID']['input'];
  keys: ReadonlyArray<Scalars['String']['input']>;
};


export type MutationDeleteWarehouseArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDigitalContentCreateArgs = {
  input: DigitalContentUploadInput;
  variantId: Scalars['ID']['input'];
};


export type MutationDigitalContentDeleteArgs = {
  variantId: Scalars['ID']['input'];
};


export type MutationDigitalContentUpdateArgs = {
  input: DigitalContentInput;
  variantId: Scalars['ID']['input'];
};


export type MutationDigitalContentUrlCreateArgs = {
  input: DigitalContentUrlCreateInput;
};


export type MutationDraftOrderBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationDraftOrderCompleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDraftOrderCreateArgs = {
  input: DraftOrderCreateInput;
};


export type MutationDraftOrderDeleteArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDraftOrderLinesBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationDraftOrderUpdateArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  input: DraftOrderInput;
};


export type MutationEventDeliveryRetryArgs = {
  id: Scalars['ID']['input'];
};


export type MutationExportGiftCardsArgs = {
  input: ExportGiftCardsInput;
};


export type MutationExportProductsArgs = {
  input: ExportProductsInput;
};


export type MutationExportVoucherCodesArgs = {
  input: ExportVoucherCodesInput;
};


export type MutationExternalAuthenticationUrlArgs = {
  input: Scalars['JSONString']['input'];
  pluginId: Scalars['String']['input'];
};


export type MutationExternalLogoutArgs = {
  input: Scalars['JSONString']['input'];
  pluginId: Scalars['String']['input'];
};


export type MutationExternalNotificationTriggerArgs = {
  channel: Scalars['String']['input'];
  input: ExternalNotificationTriggerInput;
  pluginId?: InputMaybe<Scalars['String']['input']>;
};


export type MutationExternalObtainAccessTokensArgs = {
  input: Scalars['JSONString']['input'];
  pluginId: Scalars['String']['input'];
};


export type MutationExternalRefreshArgs = {
  input: Scalars['JSONString']['input'];
  pluginId: Scalars['String']['input'];
};


export type MutationExternalVerifyArgs = {
  input: Scalars['JSONString']['input'];
  pluginId: Scalars['String']['input'];
};


export type MutationFileUploadArgs = {
  file: Scalars['Upload']['input'];
};


export type MutationGiftCardActivateArgs = {
  id: Scalars['ID']['input'];
};


export type MutationGiftCardAddNoteArgs = {
  id: Scalars['ID']['input'];
  input: GiftCardAddNoteInput;
};


export type MutationGiftCardBulkActivateArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationGiftCardBulkCreateArgs = {
  input: GiftCardBulkCreateInput;
};


export type MutationGiftCardBulkDeactivateArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationGiftCardBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationGiftCardCreateArgs = {
  input: GiftCardCreateInput;
};


export type MutationGiftCardDeactivateArgs = {
  id: Scalars['ID']['input'];
};


export type MutationGiftCardDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationGiftCardResendArgs = {
  input: GiftCardResendInput;
};


export type MutationGiftCardSettingsUpdateArgs = {
  input: GiftCardSettingsUpdateInput;
};


export type MutationGiftCardUpdateArgs = {
  id: Scalars['ID']['input'];
  input: GiftCardUpdateInput;
};


export type MutationInvoiceCreateArgs = {
  input: InvoiceCreateInput;
  orderId: Scalars['ID']['input'];
};


export type MutationInvoiceDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationInvoiceRequestArgs = {
  number?: InputMaybe<Scalars['String']['input']>;
  orderId: Scalars['ID']['input'];
};


export type MutationInvoiceRequestDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationInvoiceSendNotificationArgs = {
  id: Scalars['ID']['input'];
};


export type MutationInvoiceUpdateArgs = {
  id: Scalars['ID']['input'];
  input: UpdateInvoiceInput;
};


export type MutationMenuBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationMenuCreateArgs = {
  input: MenuCreateInput;
};


export type MutationMenuDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationMenuItemBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationMenuItemCreateArgs = {
  input: MenuItemCreateInput;
};


export type MutationMenuItemDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationMenuItemMoveArgs = {
  menu: Scalars['ID']['input'];
  moves: ReadonlyArray<MenuItemMoveInput>;
};


export type MutationMenuItemTranslateArgs = {
  id: Scalars['ID']['input'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationMenuItemUpdateArgs = {
  id: Scalars['ID']['input'];
  input: MenuItemInput;
};


export type MutationMenuUpdateArgs = {
  id: Scalars['ID']['input'];
  input: MenuInput;
};


export type MutationOrderAddNoteArgs = {
  input: OrderAddNoteInput;
  order: Scalars['ID']['input'];
};


export type MutationOrderBulkCancelArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationOrderBulkCreateArgs = {
  errorPolicy?: InputMaybe<ErrorPolicyEnum>;
  orders: ReadonlyArray<OrderBulkCreateInput>;
  stockUpdatePolicy?: InputMaybe<StockUpdatePolicyEnum>;
};


export type MutationOrderCancelArgs = {
  id: Scalars['ID']['input'];
};


export type MutationOrderCaptureArgs = {
  amount: Scalars['PositiveDecimal']['input'];
  id: Scalars['ID']['input'];
};


export type MutationOrderConfirmArgs = {
  id: Scalars['ID']['input'];
};


export type MutationOrderCreateFromCheckoutArgs = {
  id: Scalars['ID']['input'];
  metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  removeCheckout?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationOrderDiscountAddArgs = {
  input: OrderDiscountCommonInput;
  orderId: Scalars['ID']['input'];
};


export type MutationOrderDiscountDeleteArgs = {
  discountId: Scalars['ID']['input'];
};


export type MutationOrderDiscountUpdateArgs = {
  discountId: Scalars['ID']['input'];
  input: OrderDiscountCommonInput;
};


export type MutationOrderFulfillArgs = {
  input: OrderFulfillInput;
  order?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationOrderFulfillmentApproveArgs = {
  allowStockToBeExceeded?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
  notifyCustomer: Scalars['Boolean']['input'];
};


export type MutationOrderFulfillmentCancelArgs = {
  id: Scalars['ID']['input'];
  input?: InputMaybe<FulfillmentCancelInput>;
};


export type MutationOrderFulfillmentRefundProductsArgs = {
  input: OrderRefundProductsInput;
  order: Scalars['ID']['input'];
};


export type MutationOrderFulfillmentReturnProductsArgs = {
  input: OrderReturnProductsInput;
  order: Scalars['ID']['input'];
};


export type MutationOrderFulfillmentUpdateTrackingArgs = {
  id: Scalars['ID']['input'];
  input: FulfillmentUpdateTrackingInput;
};


export type MutationOrderGrantRefundCreateArgs = {
  id: Scalars['ID']['input'];
  input: OrderGrantRefundCreateInput;
};


export type MutationOrderGrantRefundUpdateArgs = {
  id: Scalars['ID']['input'];
  input: OrderGrantRefundUpdateInput;
};


export type MutationOrderLineDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationOrderLineDiscountRemoveArgs = {
  orderLineId: Scalars['ID']['input'];
};


export type MutationOrderLineDiscountUpdateArgs = {
  input: OrderDiscountCommonInput;
  orderLineId: Scalars['ID']['input'];
};


export type MutationOrderLineUpdateArgs = {
  id: Scalars['ID']['input'];
  input: OrderLineInput;
};


export type MutationOrderLinesCreateArgs = {
  id: Scalars['ID']['input'];
  input: ReadonlyArray<OrderLineCreateInput>;
};


export type MutationOrderMarkAsPaidArgs = {
  id: Scalars['ID']['input'];
  transactionReference?: InputMaybe<Scalars['String']['input']>;
};


export type MutationOrderNoteAddArgs = {
  input: OrderNoteInput;
  order: Scalars['ID']['input'];
};


export type MutationOrderNoteUpdateArgs = {
  input: OrderNoteInput;
  note: Scalars['ID']['input'];
};


export type MutationOrderRefundArgs = {
  amount: Scalars['PositiveDecimal']['input'];
  id: Scalars['ID']['input'];
};


export type MutationOrderSettingsUpdateArgs = {
  input: OrderSettingsUpdateInput;
};


export type MutationOrderUpdateArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  input: OrderUpdateInput;
};


export type MutationOrderUpdateShippingArgs = {
  input: OrderUpdateShippingInput;
  order: Scalars['ID']['input'];
};


export type MutationOrderVoidArgs = {
  id: Scalars['ID']['input'];
};


export type MutationPageAttributeAssignArgs = {
  attributeIds: ReadonlyArray<Scalars['ID']['input']>;
  pageTypeId: Scalars['ID']['input'];
};


export type MutationPageAttributeUnassignArgs = {
  attributeIds: ReadonlyArray<Scalars['ID']['input']>;
  pageTypeId: Scalars['ID']['input'];
};


export type MutationPageBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationPageBulkPublishArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
  isPublished: Scalars['Boolean']['input'];
};


export type MutationPageCreateArgs = {
  input: PageCreateInput;
};


export type MutationPageDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationPageReorderAttributeValuesArgs = {
  attributeId: Scalars['ID']['input'];
  moves: ReadonlyArray<ReorderInput>;
  pageId: Scalars['ID']['input'];
};


export type MutationPageTranslateArgs = {
  id: Scalars['ID']['input'];
  input: PageTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationPageTypeBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationPageTypeCreateArgs = {
  input: PageTypeCreateInput;
};


export type MutationPageTypeDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationPageTypeReorderAttributesArgs = {
  moves: ReadonlyArray<ReorderInput>;
  pageTypeId: Scalars['ID']['input'];
};


export type MutationPageTypeUpdateArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  input: PageTypeUpdateInput;
};


export type MutationPageUpdateArgs = {
  id: Scalars['ID']['input'];
  input: PageInput;
};


export type MutationPasswordChangeArgs = {
  newPassword: Scalars['String']['input'];
  oldPassword?: InputMaybe<Scalars['String']['input']>;
};


export type MutationPaymentCaptureArgs = {
  amount?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  paymentId: Scalars['ID']['input'];
};


export type MutationPaymentCheckBalanceArgs = {
  input: PaymentCheckBalanceInput;
};


export type MutationPaymentGatewayInitializeArgs = {
  amount?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  id: Scalars['ID']['input'];
  paymentGateways?: InputMaybe<ReadonlyArray<PaymentGatewayToInitialize>>;
};


export type MutationPaymentGatewayInitializeTokenizationArgs = {
  channel: Scalars['String']['input'];
  data?: InputMaybe<Scalars['JSON']['input']>;
  id: Scalars['String']['input'];
};


export type MutationPaymentInitializeArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  gateway: Scalars['String']['input'];
  paymentData?: InputMaybe<Scalars['JSONString']['input']>;
};


export type MutationPaymentMethodInitializeTokenizationArgs = {
  channel: Scalars['String']['input'];
  data?: InputMaybe<Scalars['JSON']['input']>;
  id: Scalars['String']['input'];
  paymentFlowToSupport: TokenizedPaymentFlowEnum;
};


export type MutationPaymentMethodProcessTokenizationArgs = {
  channel: Scalars['String']['input'];
  data?: InputMaybe<Scalars['JSON']['input']>;
  id: Scalars['String']['input'];
};


export type MutationPaymentRefundArgs = {
  amount?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  paymentId: Scalars['ID']['input'];
};


export type MutationPaymentVoidArgs = {
  paymentId: Scalars['ID']['input'];
};


export type MutationPermissionGroupCreateArgs = {
  input: PermissionGroupCreateInput;
};


export type MutationPermissionGroupDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationPermissionGroupUpdateArgs = {
  id: Scalars['ID']['input'];
  input: PermissionGroupUpdateInput;
};


export type MutationPluginUpdateArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  id: Scalars['ID']['input'];
  input: PluginUpdateInput;
};


export type MutationProductAttributeAssignArgs = {
  operations: ReadonlyArray<ProductAttributeAssignInput>;
  productTypeId: Scalars['ID']['input'];
};


export type MutationProductAttributeAssignmentUpdateArgs = {
  operations: ReadonlyArray<ProductAttributeAssignmentUpdateInput>;
  productTypeId: Scalars['ID']['input'];
};


export type MutationProductAttributeUnassignArgs = {
  attributeIds: ReadonlyArray<Scalars['ID']['input']>;
  productTypeId: Scalars['ID']['input'];
};


export type MutationProductBulkCreateArgs = {
  errorPolicy?: InputMaybe<ErrorPolicyEnum>;
  products: ReadonlyArray<ProductBulkCreateInput>;
};


export type MutationProductBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationProductBulkTranslateArgs = {
  errorPolicy?: InputMaybe<ErrorPolicyEnum>;
  translations: ReadonlyArray<ProductBulkTranslateInput>;
};


export type MutationProductChannelListingUpdateArgs = {
  id: Scalars['ID']['input'];
  input: ProductChannelListingUpdateInput;
};


export type MutationProductCreateArgs = {
  input: ProductCreateInput;
};


export type MutationProductDeleteArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationProductMediaBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationProductMediaCreateArgs = {
  input: ProductMediaCreateInput;
};


export type MutationProductMediaDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationProductMediaReorderArgs = {
  mediaIds: ReadonlyArray<Scalars['ID']['input']>;
  productId: Scalars['ID']['input'];
};


export type MutationProductMediaUpdateArgs = {
  id: Scalars['ID']['input'];
  input: ProductMediaUpdateInput;
};


export type MutationProductReorderAttributeValuesArgs = {
  attributeId: Scalars['ID']['input'];
  moves: ReadonlyArray<ReorderInput>;
  productId: Scalars['ID']['input'];
};


export type MutationProductTranslateArgs = {
  id: Scalars['ID']['input'];
  input: TranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationProductTypeBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationProductTypeCreateArgs = {
  input: ProductTypeInput;
};


export type MutationProductTypeDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationProductTypeReorderAttributesArgs = {
  moves: ReadonlyArray<ReorderInput>;
  productTypeId: Scalars['ID']['input'];
  type: ProductAttributeType;
};


export type MutationProductTypeUpdateArgs = {
  id: Scalars['ID']['input'];
  input: ProductTypeInput;
};


export type MutationProductUpdateArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  input: ProductInput;
};


export type MutationProductVariantBulkCreateArgs = {
  errorPolicy?: InputMaybe<ErrorPolicyEnum>;
  product: Scalars['ID']['input'];
  variants: ReadonlyArray<ProductVariantBulkCreateInput>;
};


export type MutationProductVariantBulkDeleteArgs = {
  ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  skus?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type MutationProductVariantBulkTranslateArgs = {
  errorPolicy?: InputMaybe<ErrorPolicyEnum>;
  translations: ReadonlyArray<ProductVariantBulkTranslateInput>;
};


export type MutationProductVariantBulkUpdateArgs = {
  errorPolicy?: InputMaybe<ErrorPolicyEnum>;
  product: Scalars['ID']['input'];
  variants: ReadonlyArray<ProductVariantBulkUpdateInput>;
};


export type MutationProductVariantChannelListingUpdateArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  input: ReadonlyArray<ProductVariantChannelListingAddInput>;
  sku?: InputMaybe<Scalars['String']['input']>;
};


export type MutationProductVariantCreateArgs = {
  input: ProductVariantCreateInput;
};


export type MutationProductVariantDeleteArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
};


export type MutationProductVariantPreorderDeactivateArgs = {
  id: Scalars['ID']['input'];
};


export type MutationProductVariantReorderArgs = {
  moves: ReadonlyArray<ReorderInput>;
  productId: Scalars['ID']['input'];
};


export type MutationProductVariantReorderAttributeValuesArgs = {
  attributeId: Scalars['ID']['input'];
  moves: ReadonlyArray<ReorderInput>;
  variantId: Scalars['ID']['input'];
};


export type MutationProductVariantSetDefaultArgs = {
  productId: Scalars['ID']['input'];
  variantId: Scalars['ID']['input'];
};


export type MutationProductVariantStocksCreateArgs = {
  stocks: ReadonlyArray<StockInput>;
  variantId: Scalars['ID']['input'];
};


export type MutationProductVariantStocksDeleteArgs = {
  sku?: InputMaybe<Scalars['String']['input']>;
  variantId?: InputMaybe<Scalars['ID']['input']>;
  warehouseIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};


export type MutationProductVariantStocksUpdateArgs = {
  sku?: InputMaybe<Scalars['String']['input']>;
  stocks: ReadonlyArray<StockInput>;
  variantId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationProductVariantTranslateArgs = {
  id: Scalars['ID']['input'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationProductVariantUpdateArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  input: ProductVariantInput;
  sku?: InputMaybe<Scalars['String']['input']>;
};


export type MutationPromotionBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationPromotionCreateArgs = {
  input: PromotionCreateInput;
};


export type MutationPromotionDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationPromotionRuleCreateArgs = {
  input: PromotionRuleCreateInput;
};


export type MutationPromotionRuleDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationPromotionRuleTranslateArgs = {
  id: Scalars['ID']['input'];
  input: PromotionRuleTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationPromotionRuleUpdateArgs = {
  id: Scalars['ID']['input'];
  input: PromotionRuleUpdateInput;
};


export type MutationPromotionTranslateArgs = {
  id: Scalars['ID']['input'];
  input: PromotionTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationPromotionUpdateArgs = {
  id: Scalars['ID']['input'];
  input: PromotionUpdateInput;
};


export type MutationRefundSettingsUpdateArgs = {
  input: RefundSettingsUpdateInput;
};


export type MutationRequestEmailChangeArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  newEmail: Scalars['String']['input'];
  password: Scalars['String']['input'];
  redirectUrl: Scalars['String']['input'];
};


export type MutationRequestPasswordResetArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  redirectUrl: Scalars['String']['input'];
};


export type MutationSaleBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationSaleCataloguesAddArgs = {
  id: Scalars['ID']['input'];
  input: CatalogueInput;
};


export type MutationSaleCataloguesRemoveArgs = {
  id: Scalars['ID']['input'];
  input: CatalogueInput;
};


export type MutationSaleChannelListingUpdateArgs = {
  id: Scalars['ID']['input'];
  input: SaleChannelListingInput;
};


export type MutationSaleCreateArgs = {
  input: SaleInput;
};


export type MutationSaleDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationSaleTranslateArgs = {
  id: Scalars['ID']['input'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationSaleUpdateArgs = {
  id: Scalars['ID']['input'];
  input: SaleInput;
};


export type MutationSendConfirmationEmailArgs = {
  channel: Scalars['String']['input'];
  redirectUrl: Scalars['String']['input'];
};


export type MutationSetPasswordArgs = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
  token: Scalars['String']['input'];
};


export type MutationShippingMethodChannelListingUpdateArgs = {
  id: Scalars['ID']['input'];
  input: ShippingMethodChannelListingInput;
};


export type MutationShippingPriceBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationShippingPriceCreateArgs = {
  input: ShippingPriceInput;
};


export type MutationShippingPriceDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationShippingPriceExcludeProductsArgs = {
  id: Scalars['ID']['input'];
  input: ShippingPriceExcludeProductsInput;
};


export type MutationShippingPriceRemoveProductFromExcludeArgs = {
  id: Scalars['ID']['input'];
  products: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationShippingPriceTranslateArgs = {
  id: Scalars['ID']['input'];
  input: ShippingPriceTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationShippingPriceUpdateArgs = {
  id: Scalars['ID']['input'];
  input: ShippingPriceInput;
};


export type MutationShippingZoneBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationShippingZoneCreateArgs = {
  input: ShippingZoneCreateInput;
};


export type MutationShippingZoneDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationShippingZoneUpdateArgs = {
  id: Scalars['ID']['input'];
  input: ShippingZoneUpdateInput;
};


export type MutationShopAddressUpdateArgs = {
  input?: InputMaybe<AddressInput>;
};


export type MutationShopDomainUpdateArgs = {
  input?: InputMaybe<SiteDomainInput>;
};


export type MutationShopSettingsTranslateArgs = {
  input: ShopSettingsTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationShopSettingsUpdateArgs = {
  input: ShopSettingsInput;
};


export type MutationStaffBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationStaffCreateArgs = {
  input: StaffCreateInput;
};


export type MutationStaffDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationStaffNotificationRecipientCreateArgs = {
  input: StaffNotificationRecipientInput;
};


export type MutationStaffNotificationRecipientDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationStaffNotificationRecipientUpdateArgs = {
  id: Scalars['ID']['input'];
  input: StaffNotificationRecipientInput;
};


export type MutationStaffUpdateArgs = {
  id: Scalars['ID']['input'];
  input: StaffUpdateInput;
};


export type MutationStockBulkUpdateArgs = {
  errorPolicy?: InputMaybe<ErrorPolicyEnum>;
  stocks: ReadonlyArray<StockBulkUpdateInput>;
};


export type MutationStoredPaymentMethodRequestDeleteArgs = {
  channel: Scalars['String']['input'];
  id: Scalars['ID']['input'];
};


export type MutationTaxClassCreateArgs = {
  input: TaxClassCreateInput;
};


export type MutationTaxClassDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationTaxClassUpdateArgs = {
  id: Scalars['ID']['input'];
  input: TaxClassUpdateInput;
};


export type MutationTaxConfigurationUpdateArgs = {
  id: Scalars['ID']['input'];
  input: TaxConfigurationUpdateInput;
};


export type MutationTaxCountryConfigurationDeleteArgs = {
  countryCode: CountryCode;
};


export type MutationTaxCountryConfigurationUpdateArgs = {
  countryCode: CountryCode;
  updateTaxClassRates: ReadonlyArray<TaxClassRateInput>;
};


export type MutationTaxExemptionManageArgs = {
  id: Scalars['ID']['input'];
  taxExemption: Scalars['Boolean']['input'];
};


export type MutationTokenCreateArgs = {
  audience?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};


export type MutationTokenRefreshArgs = {
  csrfToken?: InputMaybe<Scalars['String']['input']>;
  refreshToken?: InputMaybe<Scalars['String']['input']>;
};


export type MutationTokenVerifyArgs = {
  token: Scalars['String']['input'];
};


export type MutationTransactionCreateArgs = {
  id: Scalars['ID']['input'];
  transaction: TransactionCreateInput;
  transactionEvent?: InputMaybe<TransactionEventInput>;
};


export type MutationTransactionEventReportArgs = {
  amount?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  availableActions?: InputMaybe<ReadonlyArray<TransactionActionEnum>>;
  externalUrl?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  paymentMethodDetails?: InputMaybe<PaymentMethodDetailsInput>;
  pspReference: Scalars['String']['input'];
  time?: InputMaybe<Scalars['DateTime']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
  transactionMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  transactionPrivateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  type: TransactionEventTypeEnum;
};


export type MutationTransactionInitializeArgs = {
  action?: InputMaybe<TransactionFlowStrategyEnum>;
  amount?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  customerIpAddress?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  idempotencyKey?: InputMaybe<Scalars['String']['input']>;
  paymentGateway: PaymentGatewayToInitialize;
};


export type MutationTransactionProcessArgs = {
  customerIpAddress?: InputMaybe<Scalars['String']['input']>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationTransactionRequestActionArgs = {
  actionType: TransactionActionEnum;
  amount?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  refundReason?: InputMaybe<Scalars['String']['input']>;
  refundReasonReference?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationTransactionRequestRefundForGrantedRefundArgs = {
  grantedRefundId: Scalars['ID']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type MutationTransactionUpdateArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
  transaction?: InputMaybe<TransactionUpdateInput>;
  transactionEvent?: InputMaybe<TransactionEventInput>;
};


export type MutationUnassignWarehouseShippingZoneArgs = {
  id: Scalars['ID']['input'];
  shippingZoneIds: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationUpdateMetadataArgs = {
  id: Scalars['ID']['input'];
  input: ReadonlyArray<MetadataInput>;
};


export type MutationUpdatePrivateMetadataArgs = {
  id: Scalars['ID']['input'];
  input: ReadonlyArray<MetadataInput>;
};


export type MutationUpdateWarehouseArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  input: WarehouseUpdateInput;
};


export type MutationUserAvatarUpdateArgs = {
  image: Scalars['Upload']['input'];
};


export type MutationUserBulkSetActiveArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
  isActive: Scalars['Boolean']['input'];
};


export type MutationVariantMediaAssignArgs = {
  mediaId: Scalars['ID']['input'];
  variantId: Scalars['ID']['input'];
};


export type MutationVariantMediaUnassignArgs = {
  mediaId: Scalars['ID']['input'];
  variantId: Scalars['ID']['input'];
};


export type MutationVoucherBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationVoucherCataloguesAddArgs = {
  id: Scalars['ID']['input'];
  input: CatalogueInput;
};


export type MutationVoucherCataloguesRemoveArgs = {
  id: Scalars['ID']['input'];
  input: CatalogueInput;
};


export type MutationVoucherChannelListingUpdateArgs = {
  id: Scalars['ID']['input'];
  input: VoucherChannelListingInput;
};


export type MutationVoucherCodeBulkDeleteArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationVoucherCreateArgs = {
  input: VoucherInput;
};


export type MutationVoucherDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationVoucherTranslateArgs = {
  id: Scalars['ID']['input'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationVoucherUpdateArgs = {
  id: Scalars['ID']['input'];
  input: VoucherInput;
};


export type MutationWebhookCreateArgs = {
  input: WebhookCreateInput;
};


export type MutationWebhookDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationWebhookDryRunArgs = {
  objectId: Scalars['ID']['input'];
  query: Scalars['String']['input'];
};


export type MutationWebhookTriggerArgs = {
  objectId: Scalars['ID']['input'];
  webhookId: Scalars['ID']['input'];
};


export type MutationWebhookUpdateArgs = {
  id: Scalars['ID']['input'];
  input: WebhookUpdateInput;
};

export type NameTranslationInput = {
  readonly name?: InputMaybe<Scalars['String']['input']>;
};

export type NavigationType =
  /** Main storefront navigation. */
  | 'MAIN'
  /** Secondary storefront navigation. */
  | 'SECONDARY';

/** Represents the NEW_TAB target options for an app extension. */
export type NewTabTargetOptions = {
  /** HTTP method for New Tab target (GET or POST) */
  readonly method: HttpMethod;
};

/** An object with an ID */
export type Node = {
  /** The ID of the object. */
  readonly id: Scalars['ID']['output'];
};

/**
 * An object with attributes.
 *
 * Added in Saleor 3.22.
 */
export type ObjectWithAttributes = {
  /**
   * Get a single attribute attached to the object by attribute slug.
   *
   * Added in Saleor 3.22.
   */
  readonly assignedAttribute?: Maybe<AssignedAttribute>;
  /**
   * List of attributes assigned to the object.
   *
   * Added in Saleor 3.22.
   */
  readonly assignedAttributes: ReadonlyArray<AssignedAttribute>;
};


/**
 * An object with attributes.
 *
 * Added in Saleor 3.22.
 */
export type ObjectWithAttributesAssignedAttributeArgs = {
  slug: Scalars['String']['input'];
};


/**
 * An object with attributes.
 *
 * Added in Saleor 3.22.
 */
export type ObjectWithAttributesAssignedAttributesArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']['input']>;
};

export type ObjectWithMetadata = {
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
};


export type ObjectWithMetadataMetafieldArgs = {
  key: Scalars['String']['input'];
};


export type ObjectWithMetadataMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type ObjectWithMetadataPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


export type ObjectWithMetadataPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** Represents an order in the shop. */
export type Order = Node & ObjectWithMetadata & {
  /** List of actions that can be performed in the current state of an order. */
  readonly actions: ReadonlyArray<OrderAction>;
  /** The authorize status of the order. */
  readonly authorizeStatus: OrderAuthorizeStatusEnum;
  /** Collection points that can be used for this order. */
  readonly availableCollectionPoints: ReadonlyArray<Warehouse>;
  /**
   * Shipping methods that can be used with this order.
   * @deprecated Use `shippingMethods`, this field will be removed in 4.0
   */
  readonly availableShippingMethods?: Maybe<ReadonlyArray<ShippingMethod>>;
  /** Billing address. The full data can be access for orders created in Saleor 3.2 and later, for other orders requires one of the following permissions: MANAGE_ORDERS, OWNER. */
  readonly billingAddress?: Maybe<Address>;
  /** Informs whether a draft order can be finalized(turned into a regular order). */
  readonly canFinalize: Scalars['Boolean']['output'];
  /** Channel through which the order was placed. */
  readonly channel: Channel;
  /** The charge status of the order. */
  readonly chargeStatus: OrderChargeStatusEnum;
  /** ID of the checkout that the order was created from. */
  readonly checkoutId?: Maybe<Scalars['ID']['output']>;
  /** Name of the collection point where the order should be picked up by the customer. */
  readonly collectionPointName?: Maybe<Scalars['String']['output']>;
  /** Date and time when the order was created. */
  readonly created: Scalars['DateTime']['output'];
  /** Additional information provided by the customer about the order. */
  readonly customerNote: Scalars['String']['output'];
  /** The delivery method selected for this order. */
  readonly deliveryMethod?: Maybe<DeliveryMethod>;
  /**
   * Returns applied discount.
   * @deprecated Use the `discounts` field instead.
   */
  readonly discount?: Maybe<Money>;
  /**
   * Discount name.
   * @deprecated Use the `discounts` field instead.
   */
  readonly discountName?: Maybe<Scalars['String']['output']>;
  /** List of all discounts assigned to the order. */
  readonly discounts: ReadonlyArray<OrderDiscount>;
  /** Determines whether displayed prices should include taxes. */
  readonly displayGrossPrices: Scalars['Boolean']['output'];
  /** List of errors that occurred during order validation. */
  readonly errors: ReadonlyArray<OrderError>;
  /**
   * List of events associated with the order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly events: ReadonlyArray<OrderEvent>;
  /** External ID of this order. */
  readonly externalReference?: Maybe<Scalars['String']['output']>;
  /** List of shipments for the order. */
  readonly fulfillments: ReadonlyArray<Fulfillment>;
  /** List of user gift cards. */
  readonly giftCards: ReadonlyArray<GiftCard>;
  /**
   * List of granted refunds.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly grantedRefunds: ReadonlyArray<OrderGrantedRefund>;
  /** ID of the order. */
  readonly id: Scalars['ID']['output'];
  /** List of order invoices. Can be fetched for orders created in Saleor 3.2 and later, for other orders requires one of the following permissions: MANAGE_ORDERS, OWNER. */
  readonly invoices: ReadonlyArray<Invoice>;
  /** Informs if an order is fully paid. */
  readonly isPaid: Scalars['Boolean']['output'];
  /** Returns True, if order requires shipping. */
  readonly isShippingRequired: Scalars['Boolean']['output'];
  /** @deprecated Use the `languageCodeEnum` field to fetch the language code. */
  readonly languageCode: Scalars['String']['output'];
  /** Order language code. */
  readonly languageCodeEnum: LanguageCodeEnum;
  /** List of order lines. */
  readonly lines: ReadonlyArray<OrderLine>;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** User-friendly number of an order. */
  readonly number: Scalars['String']['output'];
  /** The order origin. */
  readonly origin: OrderOriginEnum;
  /** The ID of the order that was the base for this order. */
  readonly original?: Maybe<Scalars['ID']['output']>;
  /** Internal payment status. */
  readonly paymentStatus: PaymentChargeStatusEnum;
  /** User-friendly payment status. */
  readonly paymentStatusDisplay: Scalars['String']['output'];
  /** List of payments for the order. */
  readonly payments: ReadonlyArray<Payment>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** URL to which user should be redirected after order is placed. */
  readonly redirectUrl?: Maybe<Scalars['String']['output']>;
  /** Shipping address. The full data can be access for orders created in Saleor 3.2 and later, for other orders requires one of the following permissions: MANAGE_ORDERS, OWNER. */
  readonly shippingAddress?: Maybe<Address>;
  /**
   * Shipping method for this order.
   * @deprecated Use `deliveryMethod` instead.
   */
  readonly shippingMethod?: Maybe<ShippingMethod>;
  /** Method used for shipping. */
  readonly shippingMethodName?: Maybe<Scalars['String']['output']>;
  /** Shipping methods related to this order. */
  readonly shippingMethods: ReadonlyArray<ShippingMethod>;
  /** Total price of shipping. */
  readonly shippingPrice: TaxedMoney;
  /**
   * Denormalized tax class assigned to the shipping method.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly shippingTaxClass?: Maybe<TaxClass>;
  /** Denormalized public metadata of the shipping method's tax class. */
  readonly shippingTaxClassMetadata: ReadonlyArray<MetadataItem>;
  /** Denormalized name of the tax class assigned to the shipping method. */
  readonly shippingTaxClassName?: Maybe<Scalars['String']['output']>;
  /** Denormalized private metadata of the shipping method's tax class. Requires staff permissions to access. */
  readonly shippingTaxClassPrivateMetadata: ReadonlyArray<MetadataItem>;
  /** The shipping tax rate value. */
  readonly shippingTaxRate: Scalars['Float']['output'];
  /** Status of the order. */
  readonly status: OrderStatus;
  /** User-friendly order status. */
  readonly statusDisplay: Scalars['String']['output'];
  /** The sum of line prices not including shipping. */
  readonly subtotal: TaxedMoney;
  /** Returns True if order has to be exempt from taxes. */
  readonly taxExemption: Scalars['Boolean']['output'];
  /** @deprecated Use `id` instead. */
  readonly token: Scalars['String']['output'];
  /** Total amount of the order. */
  readonly total: TaxedMoney;
  /**
   * Total amount of ongoing authorize requests for the order's transactions.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly totalAuthorizePending: Money;
  /** Amount authorized for the order. */
  readonly totalAuthorized: Money;
  /** The difference between the paid and the order total amount. */
  readonly totalBalance: Money;
  /**
   * Total amount of ongoing cancel requests for the order's transactions.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly totalCancelPending: Money;
  /** Amount canceled for the order. */
  readonly totalCanceled: Money;
  /**
   * Amount captured for the order.
   * @deprecated Use `totalCharged` instead.
   */
  readonly totalCaptured: Money;
  /**
   * Total amount of ongoing charge requests for the order's transactions.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly totalChargePending: Money;
  /** Amount charged for the order. */
  readonly totalCharged: Money;
  /**
   * Total amount of granted refund.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly totalGrantedRefund: Money;
  /**
   * Total amount of ongoing refund requests for the order's transactions.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly totalRefundPending: Money;
  /** Total refund amount for the order. */
  readonly totalRefunded: Money;
  /**
   * The difference amount between granted refund and the amounts that are pending and refunded.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly totalRemainingGrant: Money;
  /** Google Analytics tracking client ID. */
  readonly trackingClientId: Scalars['String']['output'];
  /** List of transactions for the order. Requires one of the following permissions: MANAGE_ORDERS, HANDLE_PAYMENTS. */
  readonly transactions: ReadonlyArray<TransactionItem>;
  /**
   * Translated discount name.
   * @deprecated Use the `discounts` field instead.
   */
  readonly translatedDiscountName?: Maybe<Scalars['String']['output']>;
  /**
   * Undiscounted total price of shipping.
   *
   * Added in Saleor 3.19.
   */
  readonly undiscountedShippingPrice: Money;
  /** Undiscounted total amount of the order. */
  readonly undiscountedTotal: TaxedMoney;
  /** Date and time when the order was created. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** User who placed the order. This field is set only for orders placed by authenticated users. Can be fetched for orders created in Saleor 3.2 and later, for other orders requires one of the following permissions: MANAGE_USERS, MANAGE_ORDERS, HANDLE_PAYMENTS, OWNER. */
  readonly user?: Maybe<User>;
  /** Email address of the customer. The full data can be access for orders created in Saleor 3.2 and later, for other orders requires one of the following permissions: MANAGE_ORDERS, OWNER. */
  readonly userEmail?: Maybe<Scalars['String']['output']>;
  /** Voucher linked to the order. */
  readonly voucher?: Maybe<Voucher>;
  /**
   * Voucher code that was used for Order.
   *
   * Added in Saleor 3.18.
   */
  readonly voucherCode?: Maybe<Scalars['String']['output']>;
  /** Weight of the order. */
  readonly weight: Weight;
};


/** Represents an order in the shop. */
export type OrderMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents an order in the shop. */
export type OrderMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents an order in the shop. */
export type OrderPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents an order in the shop. */
export type OrderPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

export type OrderAction =
  /** Represents the capture action. */
  | 'CAPTURE'
  /** Represents a mark-as-paid action. */
  | 'MARK_AS_PAID'
  /** Represents a refund action. */
  | 'REFUND'
  /** Represents a void action. */
  | 'VOID';

/**
 * Adds note to the order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderAddNote = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Order note created. */
  readonly event?: Maybe<OrderEvent>;
  /** Order with the note added. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

export type OrderAddNoteInput = {
  /** Note message. */
  readonly message: Scalars['String']['input'];
};

/**
 * Determine a current authorize status for order.
 *
 *     We treat the order as fully authorized when the sum of authorized and charged funds
 *     cover the `order.total`-`order.totalGrantedRefund`.
 *     We treat the order as partially authorized when the sum of authorized and charged
 *     funds covers only part of the `order.total`-`order.totalGrantedRefund`.
 *     We treat the order as not authorized when the sum of authorized and charged funds is
 *     0.
 *
 *     NONE - the funds are not authorized
 *     PARTIAL - the funds that are authorized and charged don't cover fully the
 *     `order.total`-`order.totalGrantedRefund`
 *     FULL - the funds that are authorized and charged fully cover the
 *     `order.total`-`order.totalGrantedRefund`
 */
export type OrderAuthorizeStatusEnum =
  | 'FULL'
  | 'NONE'
  | 'PARTIAL';

/** Filter by authorize status. */
export type OrderAuthorizeStatusEnumFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<OrderAuthorizeStatusEnum>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<OrderAuthorizeStatusEnum>>;
};

/**
 * Cancels orders.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderBulkCancel = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<OrderError>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

/**
 * Creates multiple orders.
 *
 * Requires one of the following permissions: MANAGE_ORDERS_IMPORT.
 */
export type OrderBulkCreate = {
  /** Returns how many objects were created. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<OrderBulkCreateError>;
  /** List of the created orders. */
  readonly results: ReadonlyArray<OrderBulkCreateResult>;
};

export type OrderBulkCreateDeliveryMethodInput = {
  /** The ID of the shipping method. */
  readonly shippingMethodId?: InputMaybe<Scalars['ID']['input']>;
  /** The name of the shipping method. */
  readonly shippingMethodName?: InputMaybe<Scalars['String']['input']>;
  /** The price of the shipping. */
  readonly shippingPrice?: InputMaybe<TaxedMoneyInput>;
  /** The ID of the tax class. */
  readonly shippingTaxClassId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Metadata of the tax class. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly shippingTaxClassMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** The name of the tax class. */
  readonly shippingTaxClassName?: InputMaybe<Scalars['String']['input']>;
  /**
   * Private metadata of the tax class. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly shippingTaxClassPrivateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Tax rate of the shipping. */
  readonly shippingTaxRate?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** The ID of the warehouse. */
  readonly warehouseId?: InputMaybe<Scalars['ID']['input']>;
  /** The name of the warehouse. */
  readonly warehouseName?: InputMaybe<Scalars['String']['input']>;
};

export type OrderBulkCreateError = {
  /** The error code. */
  readonly code?: Maybe<OrderBulkCreateErrorCode>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly path?: Maybe<Scalars['String']['output']>;
};

export type OrderBulkCreateErrorCode =
  | 'BULK_LIMIT'
  | 'FUTURE_DATE'
  | 'GRAPHQL_ERROR'
  | 'INCORRECT_CURRENCY'
  | 'INSUFFICIENT_STOCK'
  | 'INVALID'
  | 'INVALID_QUANTITY'
  | 'METADATA_KEY_REQUIRED'
  | 'NEGATIVE_INDEX'
  | 'NON_EXISTING_STOCK'
  | 'NOTE_LENGTH'
  | 'NOT_FOUND'
  | 'NO_RELATED_ORDER_LINE'
  | 'ORDER_LINE_FULFILLMENT_LINE_MISMATCH'
  | 'PRICE_ERROR'
  | 'REQUIRED'
  | 'TOO_MANY_IDENTIFIERS'
  | 'UNIQUE';

export type OrderBulkCreateFulfillmentInput = {
  /** List of items informing how to fulfill the order. */
  readonly lines?: InputMaybe<ReadonlyArray<OrderBulkCreateFulfillmentLineInput>>;
  /** Fulfillment's tracking code. */
  readonly trackingCode?: InputMaybe<Scalars['String']['input']>;
};

export type OrderBulkCreateFulfillmentLineInput = {
  /** 0-based index of order line, which the fulfillment line refers to. */
  readonly orderLineIndex: Scalars['Int']['input'];
  /** The number of line items to be fulfilled from given warehouse. */
  readonly quantity: Scalars['Int']['input'];
  /** The external ID of the product variant. */
  readonly variantExternalReference?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the product variant. */
  readonly variantId?: InputMaybe<Scalars['ID']['input']>;
  /** The SKU of the product variant. */
  readonly variantSku?: InputMaybe<Scalars['String']['input']>;
  /** ID of the warehouse from which the item will be fulfilled. */
  readonly warehouse: Scalars['ID']['input'];
};

export type OrderBulkCreateInput = {
  /** Billing address of the customer. */
  readonly billingAddress: AddressInput;
  /** Slug of the channel associated with the order. */
  readonly channel: Scalars['String']['input'];
  /** The date, when the order was inserted to Saleor database. */
  readonly createdAt: Scalars['DateTime']['input'];
  /** Currency code. */
  readonly currency: Scalars['String']['input'];
  /** Note about customer. */
  readonly customerNote?: InputMaybe<Scalars['String']['input']>;
  /** The delivery method selected for this order. */
  readonly deliveryMethod?: InputMaybe<OrderBulkCreateDeliveryMethodInput>;
  /** List of discounts. */
  readonly discounts?: InputMaybe<ReadonlyArray<OrderDiscountCommonInput>>;
  /** Determines whether displayed prices should include taxes. */
  readonly displayGrossPrices?: InputMaybe<Scalars['Boolean']['input']>;
  /** External ID of the order. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** Fulfillments of the order. */
  readonly fulfillments?: InputMaybe<ReadonlyArray<OrderBulkCreateFulfillmentInput>>;
  /** List of gift card codes associated with the order. */
  readonly giftCards?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** Invoices related to the order. */
  readonly invoices?: InputMaybe<ReadonlyArray<OrderBulkCreateInvoiceInput>>;
  /** Order language code. */
  readonly languageCode: LanguageCodeEnum;
  /** List of order lines. */
  readonly lines: ReadonlyArray<OrderBulkCreateOrderLineInput>;
  /**
   * Metadata of the order. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Notes related to the order. */
  readonly notes?: InputMaybe<ReadonlyArray<OrderBulkCreateNoteInput>>;
  /**
   * Private metadata of the order. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** URL of a view, where users should be redirected to see the order details. */
  readonly redirectUrl?: InputMaybe<Scalars['String']['input']>;
  /** Shipping address of the customer. */
  readonly shippingAddress?: InputMaybe<AddressInput>;
  /** Status of the order. */
  readonly status?: InputMaybe<OrderStatus>;
  /** Transactions related to the order. */
  readonly transactions?: InputMaybe<ReadonlyArray<TransactionCreateInput>>;
  /** Customer associated with the order. */
  readonly user: OrderBulkCreateUserInput;
  /**
   * Code of a voucher associated with the order.
   *
   * Added in Saleor 3.18.
   */
  readonly voucherCode?: InputMaybe<Scalars['String']['input']>;
  /** Weight of the order in kg. */
  readonly weight?: InputMaybe<Scalars['WeightScalar']['input']>;
};

export type OrderBulkCreateInvoiceInput = {
  /** The date, when the invoice was created. */
  readonly createdAt: Scalars['DateTime']['input'];
  /**
   * Metadata of the invoice. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Invoice number. */
  readonly number?: InputMaybe<Scalars['String']['input']>;
  /**
   * Private metadata of the invoice. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** URL of the invoice to download. */
  readonly url?: InputMaybe<Scalars['String']['input']>;
};

export type OrderBulkCreateNoteInput = {
  /** The app ID associated with the message. */
  readonly appId?: InputMaybe<Scalars['ID']['input']>;
  /** The date associated with the message. */
  readonly date?: InputMaybe<Scalars['DateTime']['input']>;
  /** Note message. Max characters: 255. */
  readonly message: Scalars['String']['input'];
  /** The user email associated with the message. */
  readonly userEmail?: InputMaybe<Scalars['ID']['input']>;
  /** The user external ID associated with the message. */
  readonly userExternalReference?: InputMaybe<Scalars['ID']['input']>;
  /** The user ID associated with the message. */
  readonly userId?: InputMaybe<Scalars['ID']['input']>;
};

export type OrderBulkCreateOrderLineInput = {
  /** The date, when the order line was created. */
  readonly createdAt: Scalars['DateTime']['input'];
  /** Gift card flag. */
  readonly isGiftCard: Scalars['Boolean']['input'];
  /** Determines whether shipping of the order line items is required. */
  readonly isShippingRequired: Scalars['Boolean']['input'];
  /**
   * Metadata of the order line. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /**
   * Private metadata of the order line. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** The name of the product. */
  readonly productName?: InputMaybe<Scalars['String']['input']>;
  /**
   * The SKU of the product.
   *
   * Added in Saleor 3.18.
   */
  readonly productSku?: InputMaybe<Scalars['String']['input']>;
  /** Number of items in the order line */
  readonly quantity: Scalars['Int']['input'];
  /** The ID of the tax class. */
  readonly taxClassId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Metadata of the tax class. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly taxClassMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** The name of the tax class. */
  readonly taxClassName?: InputMaybe<Scalars['String']['input']>;
  /**
   * Private metadata of the tax class. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly taxClassPrivateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Tax rate of the order line. */
  readonly taxRate?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** Price of the order line. */
  readonly totalPrice: TaxedMoneyInput;
  /** Translation of the product name. */
  readonly translatedProductName?: InputMaybe<Scalars['String']['input']>;
  /** Translation of the product variant name. */
  readonly translatedVariantName?: InputMaybe<Scalars['String']['input']>;
  /** Price of the order line excluding applied discount. */
  readonly undiscountedTotalPrice: TaxedMoneyInput;
  /**
   * Reason of the discount on order line.
   *
   * Added in Saleor 3.19.
   */
  readonly unitDiscountReason?: InputMaybe<Scalars['String']['input']>;
  /**
   * Type of the discount: fixed or percent
   *
   * Added in Saleor 3.19.
   */
  readonly unitDiscountType?: InputMaybe<DiscountValueTypeEnum>;
  /**
   * Value of the discount. Can store fixed value or percent value
   *
   * Added in Saleor 3.19.
   */
  readonly unitDiscountValue?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** The external ID of the product variant. */
  readonly variantExternalReference?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the product variant. */
  readonly variantId?: InputMaybe<Scalars['ID']['input']>;
  /** The name of the product variant. */
  readonly variantName?: InputMaybe<Scalars['String']['input']>;
  /** The SKU of the product variant. */
  readonly variantSku?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the warehouse, where the line will be allocated. */
  readonly warehouse: Scalars['ID']['input'];
};

export type OrderBulkCreateResult = {
  /** List of errors occurred on create attempt. */
  readonly errors?: Maybe<ReadonlyArray<OrderBulkCreateError>>;
  /** Order data. */
  readonly order?: Maybe<Order>;
};

export type OrderBulkCreateUserInput = {
  /** Customer email associated with the order. */
  readonly email?: InputMaybe<Scalars['String']['input']>;
  /** Customer external ID associated with the order. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** Customer ID associated with the order. */
  readonly id?: InputMaybe<Scalars['ID']['input']>;
};

/** Event sent when orders are imported. */
export type OrderBulkCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The orders the event relates to. */
  readonly orders?: Maybe<ReadonlyArray<Order>>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Cancel an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderCancel = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Canceled order. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

/** Event sent when order is canceled. */
export type OrderCancelled = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Capture an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderCapture = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Captured order. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

/**
 * Determine the current charge status for the order.
 *
 *     An order is considered overcharged when the sum of the
 *     transactionItem's charge amounts exceeds the value of
 *     `order.total` - `order.totalGrantedRefund`.
 *     If the sum of the transactionItem's charge amounts equals
 *     `order.total` - `order.totalGrantedRefund`, we consider the order to be fully
 *     charged.
 *     If the sum of the transactionItem's charge amounts covers a part of the
 *     `order.total` - `order.totalGrantedRefund`, we treat the order as partially charged.
 *
 *     NONE - the funds are not charged.
 *     PARTIAL - the funds that are charged don't cover the
 *     `order.total`-`order.totalGrantedRefund`
 *     FULL - the funds that are charged fully cover the
 *     `order.total`-`order.totalGrantedRefund`
 *     OVERCHARGED - the charged funds are bigger than the
 *     `order.total`-`order.totalGrantedRefund`
 */
export type OrderChargeStatusEnum =
  | 'FULL'
  | 'NONE'
  | 'OVERCHARGED'
  | 'PARTIAL';

/** Filter by charge status. */
export type OrderChargeStatusEnumFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<OrderChargeStatusEnum>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<OrderChargeStatusEnum>>;
};

/**
 * Confirms an unconfirmed order by changing status to unfulfilled.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderConfirm = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Order which has been confirmed. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

/** Event sent when order is confirmed. */
export type OrderConfirmed = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type OrderCountableConnection = {
  readonly edges: ReadonlyArray<OrderCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type OrderCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Order;
};

/**
 * Create new order from existing checkout. Requires the following permissions: AUTHENTICATED_APP and HANDLE_CHECKOUTS.
 *
 * Triggers the following webhook events:
 * - SHIPPING_LIST_METHODS_FOR_CHECKOUT (sync): Optionally triggered when cached external shipping methods are invalid.
 * - CHECKOUT_FILTER_SHIPPING_METHODS (sync): Optionally triggered when cached filtered shipping methods are invalid.
 * - CHECKOUT_CALCULATE_TAXES (sync): Optionally triggered when checkout prices are expired.
 * - ORDER_CREATED (async): Triggered when order is created.
 * - NOTIFY_USER (async): A notification for order placement.
 * - NOTIFY_USER (async): A staff notification for order placement.
 * - ORDER_UPDATED (async): Triggered when order received the update after placement.
 * - ORDER_PAID (async): Triggered when newly created order is paid.
 * - ORDER_FULLY_PAID (async): Triggered when newly created order is fully paid.
 * - ORDER_CONFIRMED (async): Optionally triggered when newly created order are automatically marked as confirmed.
 */
export type OrderCreateFromCheckout = {
  readonly errors: ReadonlyArray<OrderCreateFromCheckoutError>;
  /** Placed order. */
  readonly order?: Maybe<Order>;
};

export type OrderCreateFromCheckoutError = {
  /** The error code. */
  readonly code: OrderCreateFromCheckoutErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** List of line Ids which cause the error. */
  readonly lines?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of variant IDs which causes the error. */
  readonly variants?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

export type OrderCreateFromCheckoutErrorCode =
  | 'BILLING_ADDRESS_NOT_SET'
  | 'CHANNEL_INACTIVE'
  | 'CHECKOUT_NOT_FOUND'
  | 'EMAIL_NOT_SET'
  | 'GIFT_CARD_NOT_APPLICABLE'
  | 'GRAPHQL_ERROR'
  | 'INSUFFICIENT_STOCK'
  | 'INVALID_SHIPPING_METHOD'
  | 'NO_LINES'
  | 'SHIPPING_ADDRESS_NOT_SET'
  | 'SHIPPING_METHOD_NOT_SET'
  | 'TAX_ERROR'
  | 'UNAVAILABLE_VARIANT_IN_CHANNEL'
  | 'VOUCHER_NOT_APPLICABLE';

/** Event sent when new order is created. */
export type OrderCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type OrderDirection =
  /** Specifies an ascending sort order. */
  | 'ASC'
  /** Specifies a descending sort order. */
  | 'DESC';

/** Contains all details related to the applied discount to the order. */
export type OrderDiscount = Node & {
  /**
   * Returns amount of discount.
   * @deprecated Use `total` instead.
   */
  readonly amount: Money;
  /** The ID of discount applied. */
  readonly id: Scalars['ID']['output'];
  /** The name of applied discount. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /**
   * Explanation for the applied discount.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly reason?: Maybe<Scalars['String']['output']>;
  /**
   * The amount of discount applied to the order.
   *
   * Added in Saleor 3.21.
   */
  readonly total: Money;
  /** Translated name of the applied discount. */
  readonly translatedName?: Maybe<Scalars['String']['output']>;
  /** The type of applied discount: Sale, Voucher or Manual. */
  readonly type: OrderDiscountType;
  /** Value of the discount. Can store fixed value or percent value */
  readonly value: Scalars['PositiveDecimal']['output'];
  /** Type of the discount: fixed or percent */
  readonly valueType: DiscountValueTypeEnum;
};

/**
 * Adds discount to the order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderDiscountAdd = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Order which has been discounted. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

export type OrderDiscountCommonInput = {
  /** Explanation for the applied discount. */
  readonly reason?: InputMaybe<Scalars['String']['input']>;
  /** Value of the discount. Can store fixed value or percent value */
  readonly value: Scalars['PositiveDecimal']['input'];
  /** Type of the discount: fixed or percent */
  readonly valueType: DiscountValueTypeEnum;
};

/**
 * Remove discount from the order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderDiscountDelete = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Order which has removed discount. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

export type OrderDiscountType =
  | 'MANUAL'
  | 'ORDER_PROMOTION'
  | 'PROMOTION'
  | 'SALE'
  | 'VOUCHER';

/**
 * Update discount for the order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderDiscountUpdate = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Order which has been discounted. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

export type OrderDraftFilterInput = {
  readonly channels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly created?: InputMaybe<DateRangeInput>;
  readonly customer?: InputMaybe<Scalars['String']['input']>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
};

export type OrderError = {
  /** A type of address that causes the error. */
  readonly addressType?: Maybe<AddressTypeEnum>;
  /** The error code. */
  readonly code: OrderErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of order line IDs that cause the error. */
  readonly orderLines?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** List of product variants that are associated with the error */
  readonly variants?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** Warehouse ID which causes the error. */
  readonly warehouse?: Maybe<Scalars['ID']['output']>;
};

export type OrderErrorCode =
  | 'BILLING_ADDRESS_NOT_SET'
  | 'CANNOT_CANCEL_FULFILLMENT'
  | 'CANNOT_CANCEL_ORDER'
  | 'CANNOT_DELETE'
  | 'CANNOT_DISCOUNT'
  | 'CANNOT_FULFILL_UNPAID_ORDER'
  | 'CANNOT_REFUND'
  | 'CAPTURE_INACTIVE_PAYMENT'
  | 'CHANNEL_INACTIVE'
  | 'DUPLICATED_INPUT_ITEM'
  | 'FULFILL_ORDER_LINE'
  | 'GIFT_CARD_LINE'
  | 'GRAPHQL_ERROR'
  | 'INSUFFICIENT_STOCK'
  | 'INVALID'
  | 'INVALID_QUANTITY'
  | 'INVALID_VOUCHER'
  | 'INVALID_VOUCHER_CODE'
  | 'MISSING_ADDRESS_DATA'
  | 'NON_EDITABLE_GIFT_LINE'
  | 'NON_REMOVABLE_GIFT_LINE'
  | 'NOT_AVAILABLE_IN_CHANNEL'
  | 'NOT_EDITABLE'
  | 'NOT_FOUND'
  | 'ORDER_NO_SHIPPING_ADDRESS'
  | 'PAYMENT_ERROR'
  | 'PAYMENT_MISSING'
  | 'PRODUCT_NOT_PUBLISHED'
  | 'PRODUCT_UNAVAILABLE_FOR_PURCHASE'
  | 'REQUIRED'
  | 'SHIPPING_METHOD_NOT_APPLICABLE'
  | 'SHIPPING_METHOD_REQUIRED'
  | 'TAX_ERROR'
  | 'TRANSACTION_ERROR'
  | 'UNIQUE'
  | 'VOID_INACTIVE_PAYMENT'
  | 'ZERO_QUANTITY';

/** History log of the order. */
export type OrderEvent = Node & {
  /** Amount of money. */
  readonly amount?: Maybe<Scalars['Float']['output']>;
  /** App that performed the action. Requires of of the following permissions: MANAGE_APPS, MANAGE_ORDERS, OWNER. */
  readonly app?: Maybe<App>;
  /** Composed ID of the Fulfillment. */
  readonly composedId?: Maybe<Scalars['String']['output']>;
  /** Date when event happened at in ISO 8601 format. */
  readonly date?: Maybe<Scalars['DateTime']['output']>;
  /** The discount applied to the order. */
  readonly discount?: Maybe<OrderEventDiscountObject>;
  /** Email of the customer. */
  readonly email?: Maybe<Scalars['String']['output']>;
  /** Type of an email sent to the customer. */
  readonly emailType?: Maybe<OrderEventsEmailsEnum>;
  /** The lines fulfilled. */
  readonly fulfilledItems?: Maybe<ReadonlyArray<FulfillmentLine>>;
  /** ID of the event associated with an order. */
  readonly id: Scalars['ID']['output'];
  /** Number of an invoice related to the order. */
  readonly invoiceNumber?: Maybe<Scalars['String']['output']>;
  /** The concerned lines. */
  readonly lines?: Maybe<ReadonlyArray<OrderEventOrderLineObject>>;
  /** Content of the event. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** User-friendly number of an order. */
  readonly orderNumber?: Maybe<Scalars['String']['output']>;
  /** List of oversold lines names. */
  readonly oversoldItems?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
  /** The payment gateway of the payment. */
  readonly paymentGateway?: Maybe<Scalars['String']['output']>;
  /** The payment reference from the payment provider. */
  readonly paymentId?: Maybe<Scalars['String']['output']>;
  /** Number of items. */
  readonly quantity?: Maybe<Scalars['Int']['output']>;
  /** The reference of payment's transaction. */
  readonly reference?: Maybe<Scalars['String']['output']>;
  /** The order event which is related to this event. */
  readonly related?: Maybe<OrderEvent>;
  /** The order which is related to this order. */
  readonly relatedOrder?: Maybe<Order>;
  /** Define if shipping costs were included to the refund. */
  readonly shippingCostsIncluded?: Maybe<Scalars['Boolean']['output']>;
  /** The transaction reference of captured payment. */
  readonly transactionReference?: Maybe<Scalars['String']['output']>;
  /** Order event type. */
  readonly type?: Maybe<OrderEventsEnum>;
  /** User who performed the action. */
  readonly user?: Maybe<User>;
  /** The warehouse were items were restocked. */
  readonly warehouse?: Maybe<Warehouse>;
};

export type OrderEventCountableConnection = {
  readonly edges: ReadonlyArray<OrderEventCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type OrderEventCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: OrderEvent;
};

export type OrderEventDiscountObject = {
  /** Returns amount of discount. */
  readonly amount?: Maybe<Money>;
  /** Returns amount of discount. */
  readonly oldAmount?: Maybe<Money>;
  /** Value of the discount. Can store fixed value or percent value. */
  readonly oldValue?: Maybe<Scalars['PositiveDecimal']['output']>;
  /** Type of the discount: fixed or percent. */
  readonly oldValueType?: Maybe<DiscountValueTypeEnum>;
  /** Explanation for the applied discount. */
  readonly reason?: Maybe<Scalars['String']['output']>;
  /** Value of the discount. Can store fixed value or percent value. */
  readonly value: Scalars['PositiveDecimal']['output'];
  /** Type of the discount: fixed or percent. */
  readonly valueType: DiscountValueTypeEnum;
};

/** Filter input for order events data. */
export type OrderEventFilterInput = {
  /** Filter order events by date. */
  readonly date?: InputMaybe<DateTimeRangeInput>;
  /** Filter order events by type. */
  readonly type?: InputMaybe<OrderEventTypeEnumFilterInput>;
};

export type OrderEventOrderLineObject = {
  /** The discount applied to the order line. */
  readonly discount?: Maybe<OrderEventDiscountObject>;
  /** The variant name. */
  readonly itemName?: Maybe<Scalars['String']['output']>;
  /** The order line. */
  readonly orderLine?: Maybe<OrderLine>;
  /** The variant quantity. */
  readonly quantity?: Maybe<Scalars['Int']['output']>;
};

export type OrderEventTypeEnumFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<OrderEventsEnum>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<OrderEventsEnum>>;
};

export type OrderEventsEmailsEnum =
  | 'CONFIRMED'
  | 'DIGITAL_LINKS'
  | 'FULFILLMENT_CONFIRMATION'
  | 'ORDER_CANCEL'
  | 'ORDER_CONFIRMATION'
  | 'ORDER_REFUND'
  | 'PAYMENT_CONFIRMATION'
  | 'SHIPPING_CONFIRMATION'
  | 'TRACKING_UPDATED';

/** The different order event types. */
export type OrderEventsEnum =
  | 'ADDED_PRODUCTS'
  | 'CANCELED'
  | 'CONFIRMED'
  | 'DRAFT_CREATED'
  | 'DRAFT_CREATED_FROM_REPLACE'
  | 'EMAIL_SENT'
  | 'EXPIRED'
  | 'EXTERNAL_SERVICE_NOTIFICATION'
  | 'FULFILLMENT_AWAITS_APPROVAL'
  | 'FULFILLMENT_CANCELED'
  | 'FULFILLMENT_FULFILLED_ITEMS'
  | 'FULFILLMENT_REFUNDED'
  | 'FULFILLMENT_REPLACED'
  | 'FULFILLMENT_RESTOCKED_ITEMS'
  | 'FULFILLMENT_RETURNED'
  | 'INVOICE_GENERATED'
  | 'INVOICE_REQUESTED'
  | 'INVOICE_SENT'
  | 'INVOICE_UPDATED'
  | 'NOTE_ADDED'
  | 'NOTE_UPDATED'
  | 'ORDER_DISCOUNT_ADDED'
  | 'ORDER_DISCOUNT_AUTOMATICALLY_UPDATED'
  | 'ORDER_DISCOUNT_DELETED'
  | 'ORDER_DISCOUNT_UPDATED'
  | 'ORDER_FULLY_PAID'
  | 'ORDER_LINE_DISCOUNT_REMOVED'
  | 'ORDER_LINE_DISCOUNT_UPDATED'
  | 'ORDER_LINE_PRODUCT_DELETED'
  | 'ORDER_LINE_VARIANT_DELETED'
  | 'ORDER_MARKED_AS_PAID'
  | 'ORDER_REPLACEMENT_CREATED'
  | 'OTHER'
  | 'OVERSOLD_ITEMS'
  | 'PAYMENT_AUTHORIZED'
  | 'PAYMENT_CAPTURED'
  | 'PAYMENT_FAILED'
  | 'PAYMENT_REFUNDED'
  | 'PAYMENT_VOIDED'
  | 'PLACED'
  | 'PLACED_AUTOMATICALLY_FROM_PAID_CHECKOUT'
  | 'PLACED_FROM_DRAFT'
  | 'REMOVED_PRODUCTS'
  | 'TRACKING_UPDATED'
  | 'TRANSACTION_CANCEL_REQUESTED'
  | 'TRANSACTION_CHARGE_REQUESTED'
  | 'TRANSACTION_EVENT'
  | 'TRANSACTION_MARK_AS_PAID_FAILED'
  | 'TRANSACTION_REFUND_REQUESTED'
  | 'UPDATED_ADDRESS';

/** Event sent when order becomes expired. */
export type OrderExpired = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type OrderFilterInput = {
  readonly authorizeStatus?: InputMaybe<ReadonlyArray<OrderAuthorizeStatusEnum>>;
  readonly channels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly chargeStatus?: InputMaybe<ReadonlyArray<OrderChargeStatusEnum>>;
  readonly checkoutIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly checkoutTokens?: InputMaybe<ReadonlyArray<Scalars['UUID']['input']>>;
  readonly created?: InputMaybe<DateRangeInput>;
  readonly customer?: InputMaybe<Scalars['String']['input']>;
  readonly giftCardBought?: InputMaybe<Scalars['Boolean']['input']>;
  readonly giftCardUsed?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly isClickAndCollect?: InputMaybe<Scalars['Boolean']['input']>;
  readonly isPreorder?: InputMaybe<Scalars['Boolean']['input']>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly numbers?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly paymentStatus?: InputMaybe<ReadonlyArray<PaymentChargeStatusEnum>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly status?: InputMaybe<ReadonlyArray<OrderStatusFilter>>;
  readonly updatedAt?: InputMaybe<DateTimeRangeInput>;
};

/** Filter shipping methods for order. */
export type OrderFilterShippingMethods = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Shipping methods that can be used with this checkout. */
  readonly shippingMethods?: Maybe<ReadonlyArray<ShippingMethod>>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Creates new fulfillments for an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 *
 * Triggers the following webhook events:
 * - FULFILLMENT_CREATED (async): A new fulfillment is created.
 * - ORDER_FULFILLED (async): Order is fulfilled.
 * - FULFILLMENT_TRACKING_NUMBER_UPDATED (async): Sent when fulfillment tracking number is updated.
 * - FULFILLMENT_APPROVED (async): A fulfillment is approved.
 */
export type OrderFulfill = {
  readonly errors: ReadonlyArray<OrderError>;
  /** List of created fulfillments. */
  readonly fulfillments?: Maybe<ReadonlyArray<Fulfillment>>;
  /** Fulfilled order. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

export type OrderFulfillInput = {
  /** If true, then allow proceed fulfillment when stock is exceeded. */
  readonly allowStockToBeExceeded?: InputMaybe<Scalars['Boolean']['input']>;
  /** List of items informing how to fulfill the order. */
  readonly lines: ReadonlyArray<OrderFulfillLineInput>;
  /** If true, send an email notification to the customer. */
  readonly notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  /** Fulfillment tracking number. */
  readonly trackingNumber?: InputMaybe<Scalars['String']['input']>;
};

export type OrderFulfillLineInput = {
  /** The ID of the order line. */
  readonly orderLineId?: InputMaybe<Scalars['ID']['input']>;
  /** List of stock items to create. */
  readonly stocks: ReadonlyArray<OrderFulfillStockInput>;
};

export type OrderFulfillStockInput = {
  /** The number of line items to be fulfilled from given warehouse. */
  readonly quantity: Scalars['Int']['input'];
  /** ID of the warehouse from which the item will be fulfilled. */
  readonly warehouse: Scalars['ID']['input'];
};

/** Event sent when order is fulfilled. */
export type OrderFulfilled = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Event sent when order is fully paid. */
export type OrderFullyPaid = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** The order is fully refunded. */
export type OrderFullyRefunded = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Adds granted refund to the order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderGrantRefundCreate = {
  readonly errors: ReadonlyArray<OrderGrantRefundCreateError>;
  /** Created granted refund. */
  readonly grantedRefund?: Maybe<OrderGrantedRefund>;
  /** Order which has assigned new grant refund. */
  readonly order?: Maybe<Order>;
};

export type OrderGrantRefundCreateError = {
  /** The error code. */
  readonly code: OrderGrantRefundCreateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** List of lines which cause the error. */
  readonly lines?: Maybe<ReadonlyArray<OrderGrantRefundCreateLineError>>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type OrderGrantRefundCreateErrorCode =
  | 'AMOUNT_GREATER_THAN_AVAILABLE'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'SHIPPING_COSTS_ALREADY_GRANTED';

export type OrderGrantRefundCreateInput = {
  /** Amount of the granted refund. If not provided, the amount will be calculated automatically based on provided `lines` and `grantRefundForShipping`. */
  readonly amount?: InputMaybe<Scalars['Decimal']['input']>;
  /** Determine if granted refund should include shipping costs. */
  readonly grantRefundForShipping?: InputMaybe<Scalars['Boolean']['input']>;
  /** Lines to assign to granted refund. */
  readonly lines?: InputMaybe<ReadonlyArray<OrderGrantRefundCreateLineInput>>;
  /** Reason of the granted refund. */
  readonly reason?: InputMaybe<Scalars['String']['input']>;
  /**
   * ID of a `Page` (Model) to reference in reason.
   *
   * Added in Saleor 3.22.
   */
  readonly reasonReference?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The ID of the transaction item related to the granted refund. If `amount` provided in the input, the transaction.chargedAmount needs to be equal or greater than provided `amount`.If `amount` is not provided in the input and calculated automatically by Saleor, the `min(calculatedAmount, transaction.chargedAmount)` will be used. Field required starting from Saleor 3.21.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly transactionId: Scalars['ID']['input'];
};

export type OrderGrantRefundCreateLineError = {
  /** The error code. */
  readonly code: OrderGrantRefundCreateLineErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The ID of the line related to the error. */
  readonly lineId: Scalars['ID']['output'];
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type OrderGrantRefundCreateLineErrorCode =
  | 'GRAPHQL_ERROR'
  | 'NOT_FOUND'
  | 'QUANTITY_GREATER_THAN_AVAILABLE';

export type OrderGrantRefundCreateLineInput = {
  /** The ID of the order line. */
  readonly id: Scalars['ID']['input'];
  /** The quantity of line items to be marked to refund. */
  readonly quantity: Scalars['Int']['input'];
  /** Reason of the granted refund for the line. */
  readonly reason?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Updates granted refund.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderGrantRefundUpdate = {
  readonly errors: ReadonlyArray<OrderGrantRefundUpdateError>;
  /** Created granted refund. */
  readonly grantedRefund?: Maybe<OrderGrantedRefund>;
  /** Order which has assigned updated grant refund. */
  readonly order?: Maybe<Order>;
};

export type OrderGrantRefundUpdateError = {
  /** List of lines to add which cause the error. */
  readonly addLines?: Maybe<ReadonlyArray<OrderGrantRefundUpdateLineError>>;
  /** The error code. */
  readonly code: OrderGrantRefundUpdateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of lines to remove which cause the error. */
  readonly removeLines?: Maybe<ReadonlyArray<OrderGrantRefundUpdateLineError>>;
};

export type OrderGrantRefundUpdateErrorCode =
  | 'AMOUNT_GREATER_THAN_AVAILABLE'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'SHIPPING_COSTS_ALREADY_GRANTED';

export type OrderGrantRefundUpdateInput = {
  /** Lines to assign to granted refund. */
  readonly addLines?: InputMaybe<ReadonlyArray<OrderGrantRefundUpdateLineAddInput>>;
  /** Amount of the granted refund. if not provided and `addLines` or `removeLines` or `grantRefundForShipping` is provided, amount will be calculated automatically. */
  readonly amount?: InputMaybe<Scalars['Decimal']['input']>;
  /** Determine if granted refund should include shipping costs. */
  readonly grantRefundForShipping?: InputMaybe<Scalars['Boolean']['input']>;
  /** Reason of the granted refund. */
  readonly reason?: InputMaybe<Scalars['String']['input']>;
  /**
   * ID of a `Page` (Model) to reference in reason.
   *
   * Added in Saleor 3.22.
   */
  readonly reasonReference?: InputMaybe<Scalars['ID']['input']>;
  /** Lines to remove from granted refund. */
  readonly removeLines?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /**
   * The ID of the transaction item related to the granted refund. If `amount` provided in the input, the transaction.chargedAmount needs to be equal or greater than provided `amount`.If `amount` is not provided in the input and calculated automatically by Saleor, the `min(calculatedAmount, transaction.chargedAmount)` will be used.Field will be required starting from Saleor 3.21.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly transactionId?: InputMaybe<Scalars['ID']['input']>;
};

export type OrderGrantRefundUpdateLineAddInput = {
  /** The ID of the order line. */
  readonly id: Scalars['ID']['input'];
  /** The quantity of line items to be marked to refund. */
  readonly quantity: Scalars['Int']['input'];
  /** Reason of the granted refund for the line. */
  readonly reason?: InputMaybe<Scalars['String']['input']>;
};

export type OrderGrantRefundUpdateLineError = {
  /** The error code. */
  readonly code: OrderGrantRefundUpdateLineErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The ID of the line related to the error. */
  readonly lineId: Scalars['ID']['output'];
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type OrderGrantRefundUpdateLineErrorCode =
  | 'GRAPHQL_ERROR'
  | 'NOT_FOUND'
  | 'QUANTITY_GREATER_THAN_AVAILABLE';

/** The details of granted refund. */
export type OrderGrantedRefund = {
  /** Refund amount. */
  readonly amount: Money;
  /** App that performed the action. */
  readonly app?: Maybe<App>;
  /** Time of creation. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Lines assigned to the granted refund. */
  readonly lines?: Maybe<ReadonlyArray<OrderGrantedRefundLine>>;
  /**
   * Reason of the refund.
   *
   * Added in Saleor 3.22.
   */
  readonly reason?: Maybe<Scalars['String']['output']>;
  /**
   * Reason Model (Page) reference for refund.
   *
   * Added in Saleor 3.22.
   */
  readonly reasonReference?: Maybe<Page>;
  /** If true, the refunded amount includes the shipping price.If false, the refunded amount does not include the shipping price. */
  readonly shippingCostsIncluded: Scalars['Boolean']['output'];
  /**
   * Status of the granted refund calculated based on transactionItem assigned to granted refund.
   *
   * Added in Saleor 3.20.
   */
  readonly status: OrderGrantedRefundStatusEnum;
  /**
   * The transaction assigned to the granted refund.
   *
   * Added in Saleor 3.20.
   */
  readonly transaction?: Maybe<TransactionItem>;
  /**
   * List of refund events associated with the granted refund.
   *
   * Added in Saleor 3.20.
   */
  readonly transactionEvents?: Maybe<ReadonlyArray<TransactionEvent>>;
  /** Time of last update. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** User who performed the action. Requires of of the following permissions: MANAGE_USERS, MANAGE_STAFF, OWNER. */
  readonly user?: Maybe<User>;
};

/** Represents granted refund line. */
export type OrderGrantedRefundLine = {
  readonly id: Scalars['ID']['output'];
  /** Line of the order associated with this granted refund. */
  readonly orderLine: OrderLine;
  /** Number of items to refund. */
  readonly quantity: Scalars['Int']['output'];
  /** Reason for refunding the line. */
  readonly reason?: Maybe<Scalars['String']['output']>;
};

/**
 * Represents the status of a granted refund.
 *
 *     NONE - the refund on related transactionItem is not processed
 *     PENDING - the refund on related transactionItem is pending
 *     FULL - the refund on related transactionItem is fully processed
 *     FAIL - the refund on related transactionItem failed
 */
export type OrderGrantedRefundStatusEnum =
  | 'FAILURE'
  | 'NONE'
  | 'PENDING'
  | 'SUCCESS';

/** Represents order line of particular order. */
export type OrderLine = Node & ObjectWithMetadata & {
  /**
   * List of allocations across warehouses.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  readonly allocations?: Maybe<ReadonlyArray<Allocation>>;
  readonly digitalContentUrl?: Maybe<DigitalContentUrl>;
  /**
   * List of applied discounts
   *
   * Added in Saleor 3.21.
   */
  readonly discounts?: Maybe<ReadonlyArray<OrderLineDiscount>>;
  /** ID of the order line. */
  readonly id: Scalars['ID']['output'];
  /**
   * Determine if the line is a gift.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly isGift?: Maybe<Scalars['Boolean']['output']>;
  /** Returns True, if the line unit price was overridden. */
  readonly isPriceOverridden?: Maybe<Scalars['Boolean']['output']>;
  /** Whether the product variant requires shipping. */
  readonly isShippingRequired: Scalars['Boolean']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Name of the product in order line. */
  readonly productName: Scalars['String']['output'];
  /** SKU of the product variant. */
  readonly productSku?: Maybe<Scalars['String']['output']>;
  /** The ID of the product variant. */
  readonly productVariantId?: Maybe<Scalars['String']['output']>;
  /** Number of variant items ordered. */
  readonly quantity: Scalars['Int']['output'];
  /** Number of variant items fulfilled. */
  readonly quantityFulfilled: Scalars['Int']['output'];
  /** A quantity of items remaining to be fulfilled. */
  readonly quantityToFulfill: Scalars['Int']['output'];
  /** Denormalized sale ID, set when order line is created for a product variant that is on sale. */
  readonly saleId?: Maybe<Scalars['ID']['output']>;
  /**
   * Denormalized tax class of the product in this order line.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly taxClass?: Maybe<TaxClass>;
  /** Denormalized public metadata of the tax class. */
  readonly taxClassMetadata: ReadonlyArray<MetadataItem>;
  /** Denormalized name of the tax class. */
  readonly taxClassName?: Maybe<Scalars['String']['output']>;
  /** Denormalized private metadata of the tax class. Requires staff permissions to access. */
  readonly taxClassPrivateMetadata: ReadonlyArray<MetadataItem>;
  /** Rate of tax applied on product variant. */
  readonly taxRate: Scalars['Float']['output'];
  readonly thumbnail?: Maybe<Image>;
  /** Price of the order line. */
  readonly totalPrice: TaxedMoney;
  /** Product name in the customer's language */
  readonly translatedProductName: Scalars['String']['output'];
  /** Variant name in the customer's language */
  readonly translatedVariantName: Scalars['String']['output'];
  /** Price of the order line without discounts. */
  readonly undiscountedTotalPrice: TaxedMoney;
  /** Price of the single item in the order line without any discount applied. */
  readonly undiscountedUnitPrice: TaxedMoney;
  /** Sum of the line-level discounts applied to the order line. Order-level discounts which affect the line are not visible in this field. For order-level discount portion (if any), please query `order.discounts` field. */
  readonly unitDiscount: Money;
  /** Reason for line-level discounts applied on the order line. Order-level discounts which affect the line are not visible in this field. For order-level discount reason (if any), please query `order.discounts` field. */
  readonly unitDiscountReason?: Maybe<Scalars['String']['output']>;
  /** Type of the discount: `fixed` or `percent`. This field shouldn't be used when multiple discounts affect the line. There is a limitation, that after running `checkoutComplete` mutation the field is always set to `fixed`. */
  readonly unitDiscountType?: Maybe<DiscountValueTypeEnum>;
  /** Value of the discount. Can store fixed value or percent value. This field shouldn't be used when multiple discounts affect the line. There is a limitation, that after running `checkoutComplete` mutation the field always stores fixed value. */
  readonly unitDiscountValue: Scalars['PositiveDecimal']['output'];
  /** Price of the single item in the order line with all the line-level discounts and order-level discount portions applied. */
  readonly unitPrice: TaxedMoney;
  /** A purchased product variant. Note: this field may be null if the variant has been removed from stock at all. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  readonly variant?: Maybe<ProductVariant>;
  /** Name of the variant of product in order line. */
  readonly variantName: Scalars['String']['output'];
  /** Voucher code that was used for this order line. */
  readonly voucherCode?: Maybe<Scalars['String']['output']>;
};


/** Represents order line of particular order. */
export type OrderLineMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents order line of particular order. */
export type OrderLineMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents order line of particular order. */
export type OrderLinePrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents order line of particular order. */
export type OrderLinePrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents order line of particular order. */
export type OrderLineThumbnailArgs = {
  format?: InputMaybe<ThumbnailFormatEnum>;
  size?: InputMaybe<Scalars['Int']['input']>;
};

export type OrderLineCreateInput = {
  /** Flag that allow force splitting the same variant into multiple lines by skipping the matching logic. */
  readonly forceNewLine?: InputMaybe<Scalars['Boolean']['input']>;
  /** Custom price of the item.When the line with the same variant will be provided multiple times, the last price will be used. */
  readonly price?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** Number of variant items ordered. */
  readonly quantity: Scalars['Int']['input'];
  /** Product variant ID. */
  readonly variantId: Scalars['ID']['input'];
};

/**
 * Deletes an order line from an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderLineDelete = {
  readonly errors: ReadonlyArray<OrderError>;
  /** A related order. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
  /** An order line that was deleted. */
  readonly orderLine?: Maybe<OrderLine>;
};

/** Represent the discount applied to order line. */
export type OrderLineDiscount = {
  /** The ID of discount applied. */
  readonly id: Scalars['ID']['output'];
  /** The name of applied discount. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /**
   * Explanation for the applied discount.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly reason?: Maybe<Scalars['String']['output']>;
  /** The discount amount applied to the line item. */
  readonly total: Money;
  /** Translated name of the applied discount. */
  readonly translatedName?: Maybe<Scalars['String']['output']>;
  /** The type of applied discount: Sale, Voucher or Manual. */
  readonly type: OrderDiscountType;
  /** The discount amount applied to the single line unit. */
  readonly unit: Money;
  /** Value of the discount. Can store fixed value or percent value */
  readonly value: Scalars['PositiveDecimal']['output'];
  /** Type of the discount: fixed or percent */
  readonly valueType: DiscountValueTypeEnum;
};

/**
 * Remove discount applied to the order line.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderLineDiscountRemove = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Order which is related to line which has removed discount. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
  /** Order line which has removed discount. */
  readonly orderLine?: Maybe<OrderLine>;
};

/**
 * Update discount for the order line.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderLineDiscountUpdate = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Order which is related to the discounted line. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
  /** Order line which has been discounted. */
  readonly orderLine?: Maybe<OrderLine>;
};

export type OrderLineInput = {
  /** Number of variant items ordered. */
  readonly quantity: Scalars['Int']['input'];
};

/**
 * Updates an order line of an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderLineUpdate = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Related order. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
  readonly orderLine?: Maybe<OrderLine>;
};

/**
 * Creates order lines for an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderLinesCreate = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Related order. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
  /** List of added order lines. */
  readonly orderLines?: Maybe<ReadonlyArray<OrderLine>>;
};

/**
 * Mark order as manually paid.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderMarkAsPaid = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Order marked as paid. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

/** Event sent when order metadata is updated. */
export type OrderMetadataUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Adds note to the order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderNoteAdd = {
  readonly errors: ReadonlyArray<OrderNoteAddError>;
  /** Order note created. */
  readonly event?: Maybe<OrderEvent>;
  /** Order with the note added. */
  readonly order?: Maybe<Order>;
};

export type OrderNoteAddError = {
  /** The error code. */
  readonly code?: Maybe<OrderNoteAddErrorCode>;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type OrderNoteAddErrorCode =
  | 'GRAPHQL_ERROR'
  | 'REQUIRED';

export type OrderNoteInput = {
  /** Note message. */
  readonly message: Scalars['String']['input'];
};

/**
 * Updates note of an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderNoteUpdate = {
  readonly errors: ReadonlyArray<OrderNoteUpdateError>;
  /** Order note updated. */
  readonly event?: Maybe<OrderEvent>;
  /** Order with the note updated. */
  readonly order?: Maybe<Order>;
};

export type OrderNoteUpdateError = {
  /** The error code. */
  readonly code?: Maybe<OrderNoteUpdateErrorCode>;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type OrderNoteUpdateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'NOT_FOUND'
  | 'REQUIRED';

export type OrderOrCheckout = Checkout | Order;

export type OrderOriginEnum =
  | 'BULK_CREATE'
  | 'CHECKOUT'
  | 'DRAFT'
  | 'REISSUE';

/** Payment has been made. The order may be partially or fully paid. */
export type OrderPaid = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type OrderPredicateInput = {
  /** List of conditions that must be met. */
  readonly AND?: InputMaybe<ReadonlyArray<OrderPredicateInput>>;
  /** A list of conditions of which at least one must be met. */
  readonly OR?: InputMaybe<ReadonlyArray<OrderPredicateInput>>;
  /** Defines the conditions related to checkout and order objects. */
  readonly discountedObjectPredicate?: InputMaybe<DiscountedObjectWhereInput>;
};

/**
 * Refund an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderRefund = {
  readonly errors: ReadonlyArray<OrderError>;
  /** A refunded order. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

export type OrderRefundFulfillmentLineInput = {
  /** The ID of the fulfillment line to refund. */
  readonly fulfillmentLineId: Scalars['ID']['input'];
  /** The number of items to be refunded. */
  readonly quantity: Scalars['Int']['input'];
};

export type OrderRefundLineInput = {
  /** The ID of the order line to refund. */
  readonly orderLineId: Scalars['ID']['input'];
  /** The number of items to be refunded. */
  readonly quantity: Scalars['Int']['input'];
};

export type OrderRefundProductsInput = {
  /** The total amount of refund when the value is provided manually. */
  readonly amountToRefund?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** List of fulfilled lines to refund. */
  readonly fulfillmentLines?: InputMaybe<ReadonlyArray<OrderRefundFulfillmentLineInput>>;
  /** If true, Saleor will refund shipping costs. If amountToRefund is providedincludeShippingCosts will be ignored. */
  readonly includeShippingCosts?: InputMaybe<Scalars['Boolean']['input']>;
  /** List of unfulfilled lines to refund. */
  readonly orderLines?: InputMaybe<ReadonlyArray<OrderRefundLineInput>>;
};

/** The order received a refund. The order may be partially or fully refunded. */
export type OrderRefunded = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type OrderReturnFulfillmentLineInput = {
  /** The ID of the fulfillment line to return. */
  readonly fulfillmentLineId: Scalars['ID']['input'];
  /** The number of items to be returned. */
  readonly quantity: Scalars['Int']['input'];
  /** Determines, if the line should be added to replace order. */
  readonly replace?: InputMaybe<Scalars['Boolean']['input']>;
};

export type OrderReturnLineInput = {
  /** The ID of the order line to return. */
  readonly orderLineId: Scalars['ID']['input'];
  /** The number of items to be returned. */
  readonly quantity: Scalars['Int']['input'];
  /** Determines, if the line should be added to replace order. */
  readonly replace?: InputMaybe<Scalars['Boolean']['input']>;
};

export type OrderReturnProductsInput = {
  /** The total amount of refund when the value is provided manually. */
  readonly amountToRefund?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** List of fulfilled lines to return. */
  readonly fulfillmentLines?: InputMaybe<ReadonlyArray<OrderReturnFulfillmentLineInput>>;
  /** If true, Saleor will refund shipping costs. If amountToRefund is providedincludeShippingCosts will be ignored. */
  readonly includeShippingCosts?: InputMaybe<Scalars['Boolean']['input']>;
  /** List of unfulfilled lines to return. */
  readonly orderLines?: InputMaybe<ReadonlyArray<OrderReturnLineInput>>;
  /** If true, Saleor will call refund action for all lines. */
  readonly refund?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents the channel-specific order settings. */
export type OrderSettings = {
  /** Determine if it is possible to place unpaid order by calling `checkoutComplete` mutation. */
  readonly allowUnpaidOrders: Scalars['Boolean']['output'];
  /** When disabled, all new orders from checkout will be marked as unconfirmed. When enabled orders from checkout will become unfulfilled immediately. */
  readonly automaticallyConfirmAllNewOrders: Scalars['Boolean']['output'];
  /** When enabled, all non-shippable gift card orders will be fulfilled automatically. */
  readonly automaticallyFulfillNonShippableGiftCard: Scalars['Boolean']['output'];
  /** The time in days after expired orders will be deleted. */
  readonly deleteExpiredOrdersAfter: Scalars['Day']['output'];
  /**
   * Time in hours after which the draft order line price will be refreshed.
   *
   * Added in Saleor 3.21.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly draftOrderLinePriceFreezePeriod?: Maybe<Scalars['Hour']['output']>;
  /** Expiration time in minutes. Default null - means do not expire any orders. */
  readonly expireOrdersAfter?: Maybe<Scalars['Minute']['output']>;
  /**
   * Determine if voucher applied on draft order should be count toward voucher usage.
   *
   * Added in Saleor 3.18.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly includeDraftOrderInVoucherUsage: Scalars['Boolean']['output'];
  /**
   * Determine what strategy will be used to mark the order as paid. Based on the chosen option, the proper object will be created and attached to the order when it's manually marked as paid.
   * `PAYMENT_FLOW` - [default option] creates the `Payment` object.
   * `TRANSACTION_FLOW` - creates the `TransactionItem` object.
   */
  readonly markAsPaidStrategy: MarkAsPaidStrategyEnum;
  /**
   * This flag only affects orders created from checkout and applies specifically to vouchers of the types: `SPECIFIC_PRODUCT` and `ENTIRE_ORDER` with `applyOncePerOrder` enabled.
   * - When legacy propagation is enabled, discounts from these vouchers are represented as `OrderDiscount` objects, attached to the order and returned in the `Order.discounts` field. Additionally, percentage-based vouchers are converted to fixed-value discounts.
   * - When legacy propagation is disabled, discounts are represented as `OrderLineDiscount` objects, attached to individual lines and returned in the `OrderLine.discounts` field. In this case, percentage-based vouchers retain their original type.
   * In future releases, `OrderLineDiscount` will become the default behavior, and this flag will be deprecated and removed.
   *
   * Added in Saleor 3.21.
   */
  readonly useLegacyLineDiscountPropagation: Scalars['Boolean']['output'];
};

export type OrderSettingsError = {
  /** The error code. */
  readonly code: OrderSettingsErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type OrderSettingsErrorCode =
  | 'INVALID';

export type OrderSettingsInput = {
  /** Determine if it is possible to place unpaid order by calling `checkoutComplete` mutation. */
  readonly allowUnpaidOrders?: InputMaybe<Scalars['Boolean']['input']>;
  /** When disabled, all new orders from checkout will be marked as unconfirmed. When enabled orders from checkout will become unfulfilled immediately. By default set to True */
  readonly automaticallyConfirmAllNewOrders?: InputMaybe<Scalars['Boolean']['input']>;
  /** When enabled, all non-shippable gift card orders will be fulfilled automatically. By default set to True. */
  readonly automaticallyFulfillNonShippableGiftCard?: InputMaybe<Scalars['Boolean']['input']>;
  /** The time in days after expired orders will be deleted.Allowed range is from 1 to 120. */
  readonly deleteExpiredOrdersAfter?: InputMaybe<Scalars['Day']['input']>;
  /**
   * Time in hours after which the draft order line price will be refreshed. Default value is 24 hours. Enter 0 or null to disable.
   *
   * Added in Saleor 3.21.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly draftOrderLinePriceFreezePeriod?: InputMaybe<Scalars['Hour']['input']>;
  /** Expiration time in minutes. Default null - means do not expire any orders. Enter 0 or null to disable. */
  readonly expireOrdersAfter?: InputMaybe<Scalars['Minute']['input']>;
  /**
   * Specify whether a coupon applied to draft orders will count toward voucher usage.
   *
   * Warning:  when switching this setting from `false` to `true`, the vouchers will be disconnected from all draft orders.
   *
   * Added in Saleor 3.18.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly includeDraftOrderInVoucherUsage?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Determine what strategy will be used to mark the order as paid. Based on the chosen option, the proper object will be created and attached to the order when it's manually marked as paid.
   * `PAYMENT_FLOW` - [default option] creates the `Payment` object.
   * `TRANSACTION_FLOW` - creates the `TransactionItem` object.
   */
  readonly markAsPaidStrategy?: InputMaybe<MarkAsPaidStrategyEnum>;
  /**
   * This flag only affects orders created from checkout and applies specifically to vouchers of the types: `SPECIFIC_PRODUCT` and `ENTIRE_ORDER` with `applyOncePerOrder` enabled.
   * - When legacy propagation is enabled, discounts from these vouchers are represented as `OrderDiscount` objects, attached to the order and returned in the `Order.discounts` field. Additionally, percentage-based vouchers are converted to fixed-value discounts.
   * - When legacy propagation is disabled, discounts are represented as `OrderLineDiscount` objects, attached to individual lines and returned in the `OrderLine.discounts` field. In this case, percentage-based vouchers retain their original type.
   * In future releases, `OrderLineDiscount` will become the default behavior, and this flag will be deprecated and removed.
   *
   * Added in Saleor 3.21.
   */
  readonly useLegacyLineDiscountPropagation?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * Update shop order settings across all channels. Returns `orderSettings` for the first `channel` in alphabetical order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderSettingsUpdate = {
  readonly errors: ReadonlyArray<OrderSettingsError>;
  /** Order settings. */
  readonly orderSettings?: Maybe<OrderSettings>;
  /** @deprecated Use `errors` field instead. */
  readonly orderSettingsErrors: ReadonlyArray<OrderSettingsError>;
};

export type OrderSettingsUpdateInput = {
  /** When disabled, all new orders from checkout will be marked as unconfirmed. When enabled orders from checkout will become unfulfilled immediately. By default set to True */
  readonly automaticallyConfirmAllNewOrders?: InputMaybe<Scalars['Boolean']['input']>;
  /** When enabled, all non-shippable gift card orders will be fulfilled automatically. By default set to True. */
  readonly automaticallyFulfillNonShippableGiftCard?: InputMaybe<Scalars['Boolean']['input']>;
};

export type OrderSortField =
  /** Sort orders by creation date. */
  | 'CREATED_AT'
  /** Sort orders by creation date */
  | 'CREATION_DATE'
  /** Sort orders by customer. */
  | 'CUSTOMER'
  /** Sort orders by fulfillment status. */
  | 'FULFILLMENT_STATUS'
  /** Sort orders by last modified date. */
  | 'LAST_MODIFIED_AT'
  /** Sort orders by number. */
  | 'NUMBER'
  /** Sort orders by payment status. */
  | 'PAYMENT'
  /** Sort orders by rank. Note: This option is available only with the `search` filter. */
  | 'RANK'
  /**
   * Sort orders by order status.
   *
   * Added in Saleor 3.22.
   */
  | 'STATUS';

export type OrderSortingInput = {
  /** Specifies the direction in which to sort orders. */
  readonly direction: OrderDirection;
  /** Sort orders by the selected field. */
  readonly field: OrderSortField;
};

export type OrderStatus =
  | 'CANCELED'
  | 'DRAFT'
  | 'EXPIRED'
  | 'FULFILLED'
  | 'PARTIALLY_FULFILLED'
  | 'PARTIALLY_RETURNED'
  | 'RETURNED'
  | 'UNCONFIRMED'
  | 'UNFULFILLED';

/** Filter by order status. */
export type OrderStatusEnumFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<OrderStatus>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<OrderStatus>>;
};

export type OrderStatusFilter =
  | 'CANCELED'
  | 'FULFILLED'
  | 'PARTIALLY_FULFILLED'
  | 'READY_TO_CAPTURE'
  | 'READY_TO_FULFILL'
  | 'UNCONFIRMED'
  | 'UNFULFILLED';

/**
 * Updates an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderUpdate = {
  readonly errors: ReadonlyArray<OrderError>;
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

export type OrderUpdateInput = {
  /** Billing address of the customer. */
  readonly billingAddress?: InputMaybe<AddressInput>;
  /** External ID of this order. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /**
   * Order language code.
   *
   * Added in Saleor 3.21.
   */
  readonly languageCode?: InputMaybe<LanguageCodeEnum>;
  /**
   * Order public metadata.
   *
   * Added in Saleor 3.21.Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /**
   * Order private metadata.
   *
   * Added in Saleor 3.21.Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Shipping address of the customer. */
  readonly shippingAddress?: InputMaybe<AddressInput>;
  /** Email address of the customer. */
  readonly userEmail?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Updates a shipping method of the order. Requires shipping method ID to update, when null is passed then currently assigned shipping method is removed.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderUpdateShipping = {
  readonly errors: ReadonlyArray<OrderError>;
  /** Order with updated shipping method. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

export type OrderUpdateShippingInput = {
  /** ID of the selected shipping method, pass null to remove currently assigned shipping method. */
  readonly shippingMethod?: InputMaybe<Scalars['ID']['input']>;
};

/** Event sent when order is updated. */
export type OrderUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The order the event relates to. */
  readonly order?: Maybe<Order>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Void an order.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type OrderVoid = {
  readonly errors: ReadonlyArray<OrderError>;
  /** A voided order. */
  readonly order?: Maybe<Order>;
  /** @deprecated Use `errors` field instead. */
  readonly orderErrors: ReadonlyArray<OrderError>;
};

export type OrderWhereInput = {
  /** List of conditions that must be met. */
  readonly AND?: InputMaybe<ReadonlyArray<OrderWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  readonly OR?: InputMaybe<ReadonlyArray<OrderWhereInput>>;
  /** Filter by authorize status. */
  readonly authorizeStatus?: InputMaybe<OrderAuthorizeStatusEnumFilterInput>;
  /** Filter by billing address of the order. */
  readonly billingAddress?: InputMaybe<AddressFilterInput>;
  /** Filter by channel. */
  readonly channelId?: InputMaybe<GlobalIdFilterInput>;
  /** Filter by charge status. */
  readonly chargeStatus?: InputMaybe<OrderChargeStatusEnumFilterInput>;
  /** Filter by checkout id. */
  readonly checkoutId?: InputMaybe<GlobalIdFilterInput>;
  /** Filter by checkout token. */
  readonly checkoutToken?: InputMaybe<UuidFilterInput>;
  /** Filter order by created at date. */
  readonly createdAt?: InputMaybe<DateTimeRangeInput>;
  /** Filter by order events. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  readonly events?: InputMaybe<ReadonlyArray<OrderEventFilterInput>>;
  /** Filter by fulfillment data associated with the order. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  readonly fulfillments?: InputMaybe<ReadonlyArray<FulfillmentFilterInput>>;
  /** Filter by whether the order has any fulfillments. */
  readonly hasFulfillments?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by whether the order has any invoices. */
  readonly hasInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Filter by invoice data associated with the order. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  readonly invoices?: InputMaybe<ReadonlyArray<InvoiceFilterInput>>;
  /** Filter by whether the order uses the click and collect delivery method. */
  readonly isClickAndCollect?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter based on whether the order includes a gift card purchase. */
  readonly isGiftCardBought?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter based on whether a gift card was used in the order. */
  readonly isGiftCardUsed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by line items associated with the order. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  readonly lines?: InputMaybe<ReadonlyArray<LinesFilterInput>>;
  /** Filter by number of lines in the order. */
  readonly linesCount?: InputMaybe<IntFilterInput>;
  /** Filter by metadata fields. */
  readonly metadata?: InputMaybe<MetadataFilterInput>;
  /** Filter by order number. */
  readonly number?: InputMaybe<IntFilterInput>;
  /** Filter by the product type of related order lines. */
  readonly productTypeId?: InputMaybe<GlobalIdFilterInput>;
  /** Filter by shipping address of the order. */
  readonly shippingAddress?: InputMaybe<AddressFilterInput>;
  /** Filter by order status. */
  readonly status?: InputMaybe<OrderStatusEnumFilterInput>;
  /** Filter by total gross amount of the order. */
  readonly totalGross?: InputMaybe<PriceFilterInput>;
  /** Filter by total net amount of the order. */
  readonly totalNet?: InputMaybe<PriceFilterInput>;
  /** Filter by transaction data associated with the order. Each list item represents conditions that must be satisfied by a single object. The filter matches orders that have related objects meeting all specified groups of conditions. */
  readonly transactions?: InputMaybe<ReadonlyArray<TransactionFilterInput>>;
  /** Filter order by updated at date. */
  readonly updatedAt?: InputMaybe<DateTimeRangeInput>;
  /** Filter by user. */
  readonly user?: InputMaybe<GlobalIdFilterInput>;
  /** Filter by user email. */
  readonly userEmail?: InputMaybe<StringFilterInput>;
  /** Filter by voucher code used in the order. */
  readonly voucherCode?: InputMaybe<StringFilterInput>;
};

/**
 * Represents a payment method used for a transaction.
 *
 * Added in Saleor 3.22.
 */
export type OtherPaymentMethodDetails = PaymentMethodDetails & {
  /** Name of the payment method. */
  readonly name: Scalars['String']['output'];
};

export type OtherPaymentMethodDetailsInput = {
  /** Name of the payment method used for the transaction. */
  readonly name: Scalars['String']['input'];
};

/** A static page that can be manually added by a shop operator through the dashboard. */
export type Page = Node & ObjectWithAttributes & ObjectWithMetadata & {
  /**
   * Get a single attribute attached to page by attribute slug.
   *
   * Added in Saleor 3.22.
   */
  readonly assignedAttribute?: Maybe<AssignedAttribute>;
  /**
   * List of attributes assigned to this page.
   *
   * Added in Saleor 3.22.
   */
  readonly assignedAttributes: ReadonlyArray<AssignedAttribute>;
  /**
   * Get a single attribute attached to page by attribute slug.
   * @deprecated Use `assignedAttribute` field instead.
   */
  readonly attribute?: Maybe<SelectedAttribute>;
  /**
   * List of attributes assigned to this page.
   * @deprecated Use `assignedAttributes` field instead.
   */
  readonly attributes: ReadonlyArray<SelectedAttribute>;
  /**
   * Content of the page.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly content?: Maybe<Scalars['JSONString']['output']>;
  /**
   * Content of the page.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `content` field instead.
   */
  readonly contentJson: Scalars['JSONString']['output'];
  /** Date and time at which page was created. */
  readonly created: Scalars['DateTime']['output'];
  /** ID of the page. */
  readonly id: Scalars['ID']['output'];
  /** Determines if the page is published. */
  readonly isPublished: Scalars['Boolean']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Determines the type of page */
  readonly pageType: PageType;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** @deprecated Use the `publishedAt` field to fetch the publication date. */
  readonly publicationDate?: Maybe<Scalars['Date']['output']>;
  /** The page publication date. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Description of the page for SEO. */
  readonly seoDescription?: Maybe<Scalars['String']['output']>;
  /** Title of the page for SEO. */
  readonly seoTitle?: Maybe<Scalars['String']['output']>;
  /** Slug of the page. */
  readonly slug: Scalars['String']['output'];
  /** Title of the page. */
  readonly title: Scalars['String']['output'];
  /** Returns translated page fields for the given language code. */
  readonly translation?: Maybe<PageTranslation>;
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageAssignedAttributeArgs = {
  slug: Scalars['String']['input'];
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageAssignedAttributesArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']['input']>;
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageAttributeArgs = {
  slug: Scalars['String']['input'];
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PagePrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PagePrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Assign attributes to a given page type.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 */
export type PageAttributeAssign = {
  readonly errors: ReadonlyArray<PageError>;
  /** @deprecated Use `errors` field instead. */
  readonly pageErrors: ReadonlyArray<PageError>;
  /** The updated page type. */
  readonly pageType?: Maybe<PageType>;
};

/**
 * Unassign attributes from a given page type.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 */
export type PageAttributeUnassign = {
  readonly errors: ReadonlyArray<PageError>;
  /** @deprecated Use `errors` field instead. */
  readonly pageErrors: ReadonlyArray<PageError>;
  /** The updated page type. */
  readonly pageType?: Maybe<PageType>;
};

/**
 * Deletes pages.
 *
 * Requires one of the following permissions: MANAGE_PAGES.
 */
export type PageBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<PageError>;
  /** @deprecated Use `errors` field instead. */
  readonly pageErrors: ReadonlyArray<PageError>;
};

/**
 * Publish pages.
 *
 * Requires one of the following permissions: MANAGE_PAGES.
 */
export type PageBulkPublish = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<PageError>;
  /** @deprecated Use `errors` field instead. */
  readonly pageErrors: ReadonlyArray<PageError>;
};

export type PageCountableConnection = {
  readonly edges: ReadonlyArray<PageCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type PageCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Page;
};

/**
 * Creates a new page.
 *
 * Requires one of the following permissions: MANAGE_PAGES.
 */
export type PageCreate = {
  readonly errors: ReadonlyArray<PageError>;
  readonly page?: Maybe<Page>;
  /** @deprecated Use `errors` field instead. */
  readonly pageErrors: ReadonlyArray<PageError>;
};

export type PageCreateInput = {
  /** List of attributes. */
  readonly attributes?: InputMaybe<ReadonlyArray<AttributeValueInput>>;
  /**
   * Page content.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly content?: InputMaybe<Scalars['JSONString']['input']>;
  /** Determines if page is visible in the storefront. */
  readonly isPublished?: InputMaybe<Scalars['Boolean']['input']>;
  /** ID of the page type that page belongs to. */
  readonly pageType: Scalars['ID']['input'];
  /**
   * Publication date. ISO 8601 standard.
   * @deprecated Use `publishedAt` field instead.
   */
  readonly publicationDate?: InputMaybe<Scalars['String']['input']>;
  /** Publication date time. ISO 8601 standard. */
  readonly publishedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** Search engine optimization fields. */
  readonly seo?: InputMaybe<SeoInput>;
  /** Page internal name. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
  /** Page title. */
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when new page is created. */
export type PageCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The page the event relates to. */
  readonly page?: Maybe<Page>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Deletes a page.
 *
 * Requires one of the following permissions: MANAGE_PAGES.
 */
export type PageDelete = {
  readonly errors: ReadonlyArray<PageError>;
  readonly page?: Maybe<Page>;
  /** @deprecated Use `errors` field instead. */
  readonly pageErrors: ReadonlyArray<PageError>;
};

/** Event sent when page is deleted. */
export type PageDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The page the event relates to. */
  readonly page?: Maybe<Page>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type PageError = {
  /** List of attributes IDs which causes the error. */
  readonly attributes?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error code. */
  readonly code: PageErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of attribute values IDs which causes the error. */
  readonly values?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

export type PageErrorCode =
  | 'ATTRIBUTE_ALREADY_ASSIGNED'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type PageFilterInput = {
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly pageTypes?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly slugs?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** The Relay compliant `PageInfo` type, containing data necessary to paginate this connection. */
export type PageInfo = {
  /** When paginating forwards, the cursor to continue. */
  readonly endCursor?: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  readonly hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  readonly hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  readonly startCursor?: Maybe<Scalars['String']['output']>;
};

export type PageInput = {
  /** List of attributes. */
  readonly attributes?: InputMaybe<ReadonlyArray<AttributeValueInput>>;
  /**
   * Page content.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly content?: InputMaybe<Scalars['JSONString']['input']>;
  /** Determines if page is visible in the storefront. */
  readonly isPublished?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Publication date. ISO 8601 standard.
   * @deprecated Use `publishedAt` field instead.
   */
  readonly publicationDate?: InputMaybe<Scalars['String']['input']>;
  /** Publication date time. ISO 8601 standard. */
  readonly publishedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** Search engine optimization fields. */
  readonly seo?: InputMaybe<SeoInput>;
  /** Page internal name. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
  /** Page title. */
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Reorder page attribute values.
 *
 * Requires one of the following permissions: MANAGE_PAGES.
 */
export type PageReorderAttributeValues = {
  readonly errors: ReadonlyArray<PageError>;
  /** Page from which attribute values are reordered. */
  readonly page?: Maybe<Page>;
  /** @deprecated Use `errors` field instead. */
  readonly pageErrors: ReadonlyArray<PageError>;
};

export type PageSortField =
  /** Sort pages by creation date. */
  | 'CREATED_AT'
  /** Sort pages by creation date. */
  | 'CREATION_DATE'
  /** Sort pages by publication date. */
  | 'PUBLICATION_DATE'
  /** Sort pages by publication date. */
  | 'PUBLISHED_AT'
  /** Sort pages by slug. */
  | 'SLUG'
  /** Sort pages by title. */
  | 'TITLE'
  /** Sort pages by visibility. */
  | 'VISIBILITY';

export type PageSortingInput = {
  /** Specifies the direction in which to sort pages. */
  readonly direction: OrderDirection;
  /** Sort pages by the selected field. */
  readonly field: PageSortField;
};

/** Represents page's original translatable fields and related translations. */
export type PageTranslatableContent = Node & {
  /** List of page content attribute values that can be translated. */
  readonly attributeValues: ReadonlyArray<AttributeValueTranslatableContent>;
  /**
   * Content of the page to translate.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly content?: Maybe<Scalars['JSONString']['output']>;
  /**
   * Content of the page.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `content` field instead.
   */
  readonly contentJson?: Maybe<Scalars['JSONString']['output']>;
  /** The ID of the page translatable content. */
  readonly id: Scalars['ID']['output'];
  /**
   * A static page that can be manually added by a shop operator through the dashboard.
   * @deprecated Get model fields from the root level queries.
   */
  readonly page?: Maybe<Page>;
  /** The ID of the page to translate. */
  readonly pageId: Scalars['ID']['output'];
  /** SEO description to translate. */
  readonly seoDescription?: Maybe<Scalars['String']['output']>;
  /** SEO title to translate. */
  readonly seoTitle?: Maybe<Scalars['String']['output']>;
  /**
   * Slug to translate.
   *
   * Added in Saleor 3.21.
   */
  readonly slug?: Maybe<Scalars['String']['output']>;
  /** Page title to translate. */
  readonly title: Scalars['String']['output'];
  /** Returns translated page fields for the given language code. */
  readonly translation?: Maybe<PageTranslation>;
};


/** Represents page's original translatable fields and related translations. */
export type PageTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a page.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type PageTranslate = {
  readonly errors: ReadonlyArray<TranslationError>;
  readonly page?: Maybe<PageTranslatableContent>;
  /** @deprecated Use `errors` field instead. */
  readonly translationErrors: ReadonlyArray<TranslationError>;
};

/** Represents page translations. */
export type PageTranslation = Node & {
  /**
   * Translated content of the page.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly content?: Maybe<Scalars['JSONString']['output']>;
  /**
   * Translated description of the page.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `content` field instead.
   */
  readonly contentJson?: Maybe<Scalars['JSONString']['output']>;
  /** The ID of the page translation. */
  readonly id: Scalars['ID']['output'];
  /** Translation language. */
  readonly language: LanguageDisplay;
  /** Translated SEO description. */
  readonly seoDescription?: Maybe<Scalars['String']['output']>;
  /** Translated SEO title. */
  readonly seoTitle?: Maybe<Scalars['String']['output']>;
  /**
   * Translated page slug.
   *
   * Added in Saleor 3.21.
   */
  readonly slug?: Maybe<Scalars['String']['output']>;
  /** Translated page title. */
  readonly title?: Maybe<Scalars['String']['output']>;
  /** Represents the page fields to translate. */
  readonly translatableContent?: Maybe<PageTranslatableContent>;
};

export type PageTranslationInput = {
  /**
   * Translated page content.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly content?: InputMaybe<Scalars['JSONString']['input']>;
  readonly seoDescription?: InputMaybe<Scalars['String']['input']>;
  readonly seoTitle?: InputMaybe<Scalars['String']['input']>;
  readonly slug?: InputMaybe<Scalars['String']['input']>;
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageType = Node & ObjectWithMetadata & {
  /** Page attributes of that page type. */
  readonly attributes?: Maybe<ReadonlyArray<Attribute>>;
  /**
   * Attributes that can be assigned to the page type.
   *
   * Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  readonly availableAttributes?: Maybe<AttributeCountableConnection>;
  /**
   * Whether page type has pages assigned.
   *
   * Requires one of the following permissions: MANAGE_PAGES, MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
   */
  readonly hasPages?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the page type. */
  readonly id: Scalars['ID']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Name of the page type. */
  readonly name: Scalars['String']['output'];
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Slug of the page type. */
  readonly slug: Scalars['String']['output'];
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypeAvailableAttributesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AttributeFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  where?: InputMaybe<AttributeWhereInput>;
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypeMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypeMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypePrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypePrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/**
 * Deletes page types.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 */
export type PageTypeBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<PageError>;
  /** @deprecated Use `errors` field instead. */
  readonly pageErrors: ReadonlyArray<PageError>;
};

export type PageTypeCountableConnection = {
  readonly edges: ReadonlyArray<PageTypeCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type PageTypeCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: PageType;
};

/**
 * Creates a new page type.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 */
export type PageTypeCreate = {
  readonly errors: ReadonlyArray<PageError>;
  /** @deprecated Use `errors` field instead. */
  readonly pageErrors: ReadonlyArray<PageError>;
  readonly pageType?: Maybe<PageType>;
};

export type PageTypeCreateInput = {
  /** List of attribute IDs to be assigned to the page type. */
  readonly addAttributes?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Name of the page type. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Page type slug. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when new page type is created. */
export type PageTypeCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The page type the event relates to. */
  readonly pageType?: Maybe<PageType>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Deletes a page type.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 */
export type PageTypeDelete = {
  readonly errors: ReadonlyArray<PageError>;
  /** @deprecated Use `errors` field instead. */
  readonly pageErrors: ReadonlyArray<PageError>;
  readonly pageType?: Maybe<PageType>;
};

/** Event sent when page type is deleted. */
export type PageTypeDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The page type the event relates to. */
  readonly pageType?: Maybe<PageType>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type PageTypeFilterInput = {
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly slugs?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/**
 * Reorder the attributes of a page type.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 */
export type PageTypeReorderAttributes = {
  readonly errors: ReadonlyArray<PageError>;
  /** @deprecated Use `errors` field instead. */
  readonly pageErrors: ReadonlyArray<PageError>;
  /** Page type from which attributes are reordered. */
  readonly pageType?: Maybe<PageType>;
};

export type PageTypeSortField =
  /** Sort page types by name. */
  | 'NAME'
  /** Sort page types by slug. */
  | 'SLUG';

export type PageTypeSortingInput = {
  /** Specifies the direction in which to sort page types. */
  readonly direction: OrderDirection;
  /** Sort page types by the selected field. */
  readonly field: PageTypeSortField;
};

/**
 * Updates page type.
 *
 * Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES.
 */
export type PageTypeUpdate = {
  readonly errors: ReadonlyArray<PageError>;
  /** @deprecated Use `errors` field instead. */
  readonly pageErrors: ReadonlyArray<PageError>;
  readonly pageType?: Maybe<PageType>;
};

export type PageTypeUpdateInput = {
  /** List of attribute IDs to be assigned to the page type. */
  readonly addAttributes?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Name of the page type. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** List of attribute IDs to be assigned to the page type. */
  readonly removeAttributes?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Page type slug. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when page type is updated. */
export type PageTypeUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The page type the event relates to. */
  readonly pageType?: Maybe<PageType>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Updates an existing page.
 *
 * Requires one of the following permissions: MANAGE_PAGES.
 */
export type PageUpdate = {
  readonly errors: ReadonlyArray<PageError>;
  readonly page?: Maybe<Page>;
  /** @deprecated Use `errors` field instead. */
  readonly pageErrors: ReadonlyArray<PageError>;
};

/** Event sent when page is updated. */
export type PageUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The page the event relates to. */
  readonly page?: Maybe<Page>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type PageWhereInput = {
  /** List of conditions that must be met. */
  readonly AND?: InputMaybe<ReadonlyArray<PageWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  readonly OR?: InputMaybe<ReadonlyArray<PageWhereInput>>;
  /** Filter by attributes associated with the page. */
  readonly attributes?: InputMaybe<ReadonlyArray<AssignedAttributeWhereInput>>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Filter by metadata fields. */
  readonly metadata?: InputMaybe<MetadataFilterInput>;
  /** Filter by page type. */
  readonly pageType?: InputMaybe<GlobalIdFilterInput>;
  /** Filter by page slug. */
  readonly slug?: InputMaybe<StringFilterInput>;
};

/**
 * Change the password of the logged in user.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 */
export type PasswordChange = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  /** A user instance with a new password. */
  readonly user?: Maybe<User>;
};

/** Represents a payment of a given type. */
export type Payment = Node & ObjectWithMetadata & {
  /**
   * List of actions that can be performed in the current state of a payment.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly actions: ReadonlyArray<OrderAction>;
  /**
   * Maximum amount of money that can be captured.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly availableCaptureAmount?: Maybe<Money>;
  /**
   * Maximum amount of money that can be refunded.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly availableRefundAmount?: Maybe<Money>;
  /** Total amount captured for this payment. */
  readonly capturedAmount?: Maybe<Money>;
  /** Internal payment status. */
  readonly chargeStatus: PaymentChargeStatusEnum;
  /** Checkout associated with a payment. */
  readonly checkout?: Maybe<Checkout>;
  /** Date and time at which payment was created. */
  readonly created: Scalars['DateTime']['output'];
  /** The details of the card used for this payment. */
  readonly creditCard?: Maybe<CreditCard>;
  /**
   * IP address of the user who created the payment.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly customerIpAddress?: Maybe<Scalars['String']['output']>;
  /** Payment gateway used for payment. */
  readonly gateway: Scalars['String']['output'];
  /** ID of the payment. */
  readonly id: Scalars['ID']['output'];
  /** Determines if the payment is active or not. */
  readonly isActive: Scalars['Boolean']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Date and time at which payment was modified. */
  readonly modified: Scalars['DateTime']['output'];
  /** Order associated with a payment. */
  readonly order?: Maybe<Order>;
  /** Informs whether this is a partial payment. */
  readonly partial: Scalars['Boolean']['output'];
  /** Type of method used for payment. */
  readonly paymentMethodType: Scalars['String']['output'];
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** PSP reference of the payment. */
  readonly pspReference?: Maybe<Scalars['String']['output']>;
  /** Unique token associated with a payment. */
  readonly token: Scalars['String']['output'];
  /** Total amount of the payment. */
  readonly total?: Maybe<Money>;
  /**
   * List of all transactions within this payment.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly transactions?: Maybe<ReadonlyArray<Transaction>>;
};


/** Represents a payment of a given type. */
export type PaymentMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a payment of a given type. */
export type PaymentMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a payment of a given type. */
export type PaymentPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a payment of a given type. */
export type PaymentPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** Authorize payment. */
export type PaymentAuthorize = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** Look up a payment. */
  readonly payment?: Maybe<Payment>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Captures the authorized payment amount.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type PaymentCapture = {
  readonly errors: ReadonlyArray<PaymentError>;
  /** Updated payment. */
  readonly payment?: Maybe<Payment>;
  /** @deprecated Use `errors` field instead. */
  readonly paymentErrors: ReadonlyArray<PaymentError>;
};

/** Capture payment. */
export type PaymentCaptureEvent = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** Look up a payment. */
  readonly payment?: Maybe<Payment>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type PaymentChargeStatusEnum =
  | 'CANCELLED'
  | 'FULLY_CHARGED'
  | 'FULLY_REFUNDED'
  | 'NOT_CHARGED'
  | 'PARTIALLY_CHARGED'
  | 'PARTIALLY_REFUNDED'
  | 'PENDING'
  | 'REFUSED';

/** Check payment balance. */
export type PaymentCheckBalance = {
  /** Response from the gateway. */
  readonly data?: Maybe<Scalars['JSONString']['output']>;
  readonly errors: ReadonlyArray<PaymentError>;
  /** @deprecated Use `errors` field instead. */
  readonly paymentErrors: ReadonlyArray<PaymentError>;
};

export type PaymentCheckBalanceInput = {
  /** Information about card. */
  readonly card: CardInput;
  /** Slug of a channel for which the data should be returned. */
  readonly channel: Scalars['String']['input'];
  /** An ID of a payment gateway to check. */
  readonly gatewayId: Scalars['String']['input'];
  /** Payment method name. */
  readonly method: Scalars['String']['input'];
};

/** Confirm payment. */
export type PaymentConfirmEvent = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** Look up a payment. */
  readonly payment?: Maybe<Payment>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type PaymentCountableConnection = {
  readonly edges: ReadonlyArray<PaymentCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type PaymentCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Payment;
};

export type PaymentError = {
  /** The error code. */
  readonly code: PaymentErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of variant IDs which causes the error. */
  readonly variants?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

export type PaymentErrorCode =
  | 'BALANCE_CHECK_ERROR'
  | 'BILLING_ADDRESS_NOT_SET'
  | 'CHANNEL_INACTIVE'
  | 'CHECKOUT_COMPLETION_IN_PROGRESS'
  | 'CHECKOUT_EMAIL_NOT_SET'
  | 'CHECKOUT_HAS_TRANSACTION'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_SHIPPING_METHOD'
  | 'NOT_FOUND'
  | 'NOT_SUPPORTED_GATEWAY'
  | 'NO_CHECKOUT_LINES'
  | 'PARTIAL_PAYMENT_NOT_ALLOWED'
  | 'PAYMENT_ERROR'
  | 'REQUIRED'
  | 'SHIPPING_ADDRESS_NOT_SET'
  | 'SHIPPING_METHOD_NOT_SET'
  | 'UNAVAILABLE_VARIANT_IN_CHANNEL'
  | 'UNIQUE';

export type PaymentFilterInput = {
  readonly checkouts?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Filter by ids. */
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/** Available payment gateway backend with configuration necessary to setup client. */
export type PaymentGateway = {
  /** Payment gateway client configuration. */
  readonly config: ReadonlyArray<GatewayConfigLine>;
  /** Payment gateway supported currencies. */
  readonly currencies: ReadonlyArray<Scalars['String']['output']>;
  /** Payment gateway ID. */
  readonly id: Scalars['ID']['output'];
  /** Payment gateway name. */
  readonly name: Scalars['String']['output'];
};

export type PaymentGatewayConfig = {
  /** The JSON data required to initialize the payment gateway. */
  readonly data?: Maybe<Scalars['JSON']['output']>;
  readonly errors?: Maybe<ReadonlyArray<PaymentGatewayConfigError>>;
  /** The app identifier. */
  readonly id: Scalars['String']['output'];
};

export type PaymentGatewayConfigError = {
  /** The error code. */
  readonly code: PaymentGatewayConfigErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type PaymentGatewayConfigErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

/** Initializes a payment gateway session. It triggers the webhook `PAYMENT_GATEWAY_INITIALIZE_SESSION`, to the requested `paymentGateways`. If `paymentGateways` is not provided, the webhook will be send to all subscribed payment gateways. There is a limit of 100 transaction items per checkout / order. */
export type PaymentGatewayInitialize = {
  readonly errors: ReadonlyArray<PaymentGatewayInitializeError>;
  /** List of payment gateway configurations. */
  readonly gatewayConfigs?: Maybe<ReadonlyArray<PaymentGatewayConfig>>;
};

export type PaymentGatewayInitializeError = {
  /** The error code. */
  readonly code: PaymentGatewayInitializeErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type PaymentGatewayInitializeErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

/** Event sent when user wants to initialize the payment gateway. */
export type PaymentGatewayInitializeSession = Event & {
  /** Amount requested for initializing the payment gateway. */
  readonly amount?: Maybe<Scalars['PositiveDecimal']['output']>;
  /** Payment gateway data in JSON format, received from storefront. */
  readonly data?: Maybe<Scalars['JSON']['output']>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Checkout or order */
  readonly sourceObject: OrderOrCheckout;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Initializes payment gateway for tokenizing payment method session.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION (sync): The customer requested to initialize payment gateway for tokenization.
 */
export type PaymentGatewayInitializeTokenization = {
  /** A data returned by payment app. */
  readonly data?: Maybe<Scalars['JSON']['output']>;
  readonly errors: ReadonlyArray<PaymentGatewayInitializeTokenizationError>;
  /** A status of the payment gateway initialization. */
  readonly result: PaymentGatewayInitializeTokenizationResult;
};

export type PaymentGatewayInitializeTokenizationError = {
  /** The error code. */
  readonly code: PaymentGatewayInitializeTokenizationErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type PaymentGatewayInitializeTokenizationErrorCode =
  | 'CHANNEL_INACTIVE'
  | 'GATEWAY_ERROR'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

/**
 * Result of initialize payment gateway for tokenization of payment method.
 *
 *     The result of initialize payment gateway for tokenization of payment method.
 *     SUCCESSFULLY_INITIALIZED - The payment gateway was successfully initialized.
 *     FAILED_TO_INITIALIZE - The payment gateway was not initialized.
 *     FAILED_TO_DELIVER - The request to initialize payment gateway was not delivered.
 */
export type PaymentGatewayInitializeTokenizationResult =
  | 'FAILED_TO_DELIVER'
  | 'FAILED_TO_INITIALIZE'
  | 'SUCCESSFULLY_INITIALIZED';

/** Event sent to initialize a new session in payment gateway to store the payment method. */
export type PaymentGatewayInitializeTokenizationSession = Event & {
  /** Channel related to the requested action. */
  readonly channel: Channel;
  /** Payment gateway data in JSON format, received from storefront. */
  readonly data?: Maybe<Scalars['JSON']['output']>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The user related to the requested action. */
  readonly user: User;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type PaymentGatewayToInitialize = {
  /** The data that will be passed to the payment gateway. */
  readonly data?: InputMaybe<Scalars['JSON']['input']>;
  /** The identifier of the payment gateway app to initialize. */
  readonly id: Scalars['String']['input'];
};

/** Initializes payment process when it is required by gateway. */
export type PaymentInitialize = {
  readonly errors: ReadonlyArray<PaymentError>;
  /** Payment that was initialized. */
  readonly initializedPayment?: Maybe<PaymentInitialized>;
  /** @deprecated Use `errors` field instead. */
  readonly paymentErrors: ReadonlyArray<PaymentError>;
};

/** Server-side data generated by a payment gateway. Optional step when the payment provider requires an additional action to initialize payment session. */
export type PaymentInitialized = {
  /** Initialized data by gateway. */
  readonly data?: Maybe<Scalars['JSONString']['output']>;
  /** ID of a payment gateway. */
  readonly gateway: Scalars['String']['output'];
  /** Payment gateway name. */
  readonly name: Scalars['String']['output'];
};

export type PaymentInput = {
  /** Total amount of the transaction, including all taxes and discounts. If no amount is provided, the checkout total will be used. */
  readonly amount?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** A gateway to use with that payment. */
  readonly gateway: Scalars['String']['input'];
  /**
   * User public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** URL of a storefront view where user should be redirected after requiring additional actions. Payment with additional actions will not be finished if this field is not provided. */
  readonly returnUrl?: InputMaybe<Scalars['String']['input']>;
  /** Payment store type. */
  readonly storePaymentMethod?: InputMaybe<StorePaymentMethodEnum>;
  /** Client-side generated payment token, representing customer's billing data in a secure manner. */
  readonly token?: InputMaybe<Scalars['String']['input']>;
};

/** List payment gateways. */
export type PaymentListGateways = Event & {
  /** The checkout the event relates to. */
  readonly checkout?: Maybe<Checkout>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Represents a payment method used for a transaction.
 *
 * Added in Saleor 3.22.
 */
export type PaymentMethodDetails = {
  /** Name of the payment method. */
  readonly name: Scalars['String']['output'];
};

export type PaymentMethodDetailsCardFilterInput = {
  /** Filter by payment method brand used to pay for the order. */
  readonly brand?: InputMaybe<StringFilterInput>;
};

export type PaymentMethodDetailsFilterInput = {
  /** Filter by card details used to pay for the order. Skips `type` filter if provided. */
  readonly card?: InputMaybe<PaymentMethodDetailsCardFilterInput>;
  /** Filter by payment method type used to pay for the order. */
  readonly type?: InputMaybe<PaymentMethodTypeEnumFilterInput>;
};

/**
 * Details of the payment method used for the transaction. One of `card` or `other` is required.
 *
 * Added in Saleor 3.22.
 */
export type PaymentMethodDetailsInput = {
  /** Details of the card payment method used for the transaction. */
  readonly card?: InputMaybe<CardPaymentMethodDetailsInput>;
  /** Details of the non-card payment method used for this transaction. */
  readonly other?: InputMaybe<OtherPaymentMethodDetailsInput>;
};

/**
 * Tokenize payment method.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION (sync): The customer requested to tokenize payment method.
 */
export type PaymentMethodInitializeTokenization = {
  /** A data returned by the payment app. */
  readonly data?: Maybe<Scalars['JSON']['output']>;
  readonly errors: ReadonlyArray<PaymentMethodInitializeTokenizationError>;
  /** The identifier of the payment method. */
  readonly id?: Maybe<Scalars['String']['output']>;
  /** A status of the payment method tokenization. */
  readonly result: PaymentMethodTokenizationResult;
};

export type PaymentMethodInitializeTokenizationError = {
  /** The error code. */
  readonly code: PaymentMethodInitializeTokenizationErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type PaymentMethodInitializeTokenizationErrorCode =
  | 'CHANNEL_INACTIVE'
  | 'GATEWAY_ERROR'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

/** Event sent when user requests a tokenization of payment method. */
export type PaymentMethodInitializeTokenizationSession = Event & {
  /** Channel related to the requested action. */
  readonly channel: Channel;
  /** Payment gateway data in JSON format, received from storefront. */
  readonly data?: Maybe<Scalars['JSON']['output']>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The payment flow that the tokenized payment method should support. */
  readonly paymentFlowToSupport: TokenizedPaymentFlowEnum;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The user related to the requested action. */
  readonly user: User;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Tokenize payment method.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION (sync): The customer continues payment method tokenization.
 */
export type PaymentMethodProcessTokenization = {
  /** A data returned by the payment app. */
  readonly data?: Maybe<Scalars['JSON']['output']>;
  readonly errors: ReadonlyArray<PaymentMethodProcessTokenizationError>;
  /** The identifier of the payment method. */
  readonly id?: Maybe<Scalars['String']['output']>;
  /** A status of the payment method tokenization. */
  readonly result: PaymentMethodTokenizationResult;
};

export type PaymentMethodProcessTokenizationError = {
  /** The error code. */
  readonly code: PaymentMethodProcessTokenizationErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type PaymentMethodProcessTokenizationErrorCode =
  | 'CHANNEL_INACTIVE'
  | 'GATEWAY_ERROR'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

/** Event sent when user continues a tokenization of payment method. */
export type PaymentMethodProcessTokenizationSession = Event & {
  /** Channel related to the requested action. */
  readonly channel: Channel;
  /** Payment gateway data in JSON format, received from storefront. */
  readonly data?: Maybe<Scalars['JSON']['output']>;
  /** The ID returned by app from `PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION` webhook. */
  readonly id: Scalars['String']['output'];
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The user related to the requested action. */
  readonly user: User;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type PaymentMethodRequestDeleteError = {
  /** The error code. */
  readonly code: StoredPaymentMethodRequestDeleteErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/**
 * Result of tokenization of payment method.
 *
 *     SUCCESSFULLY_TOKENIZED - The payment method was successfully tokenized.
 *     ADDITIONAL_ACTION_REQUIRED - The additional action is required to tokenize payment
 *     method.
 *     PENDING - The payment method is pending tokenization.
 *     FAILED_TO_TOKENIZE - The payment method was not tokenized.
 *     FAILED_TO_DELIVER - The request to tokenize payment method was not delivered.
 */
export type PaymentMethodTokenizationResult =
  | 'ADDITIONAL_ACTION_REQUIRED'
  | 'FAILED_TO_DELIVER'
  | 'FAILED_TO_TOKENIZE'
  | 'PENDING'
  | 'SUCCESSFULLY_TOKENIZED';

/**
 * Represents possible payment method types.
 *
 *     The following types are possible:
 *     CARD - represents a card payment method.
 *     OTHER - represents any payment method that is not a card payment.
 */
export type PaymentMethodTypeEnum =
  | 'CARD'
  | 'OTHER';

export type PaymentMethodTypeEnumFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<PaymentMethodTypeEnum>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<PaymentMethodTypeEnum>>;
};

/** Process payment. */
export type PaymentProcessEvent = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** Look up a payment. */
  readonly payment?: Maybe<Payment>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Refunds the captured payment amount.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type PaymentRefund = {
  readonly errors: ReadonlyArray<PaymentError>;
  /** Updated payment. */
  readonly payment?: Maybe<Payment>;
  /** @deprecated Use `errors` field instead. */
  readonly paymentErrors: ReadonlyArray<PaymentError>;
};

/** Refund payment. */
export type PaymentRefundEvent = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** Look up a payment. */
  readonly payment?: Maybe<Payment>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Represents the channel-specific payment settings. */
export type PaymentSettings = {
  /**
   * Specifies the earliest date on which funds for expired checkouts can begin to be released. Expired checkouts dated before this cut-off will not have their funds released. Additionally, no funds will be released for checkouts that are more than one year old, regardless of the cut-off date.
   *
   * Added in Saleor 3.20.
   */
  readonly checkoutReleaseFundsCutOffDate?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The time in hours after which funds for expired checkouts will be released.
   *
   * Added in Saleor 3.20.
   */
  readonly checkoutTtlBeforeReleasingFunds?: Maybe<Scalars['Hour']['output']>;
  /** Determine the transaction flow strategy to be used. Include the selected option in the payload sent to the payment app, as a requested action for the transaction. */
  readonly defaultTransactionFlowStrategy: TransactionFlowStrategyEnum;
  /**
   * Determine if the funds for expired checkouts should be released automatically.
   *
   * Added in Saleor 3.20.
   */
  readonly releaseFundsForExpiredCheckouts?: Maybe<Scalars['Boolean']['output']>;
};

export type PaymentSettingsInput = {
  /**
   * Specifies the earliest date on which funds for expired checkouts can begin to be released. Expired checkouts dated before this cut-off will not have their funds released. Additionally, no funds will be released for checkouts that are more than one year old, regardless of the cut-off date.
   *
   * Added in Saleor 3.20.
   */
  readonly checkoutReleaseFundsCutOffDate?: InputMaybe<Scalars['DateTime']['input']>;
  /**
   * The time in hours after which funds for expired checkouts will be released.
   *
   * Added in Saleor 3.20.
   */
  readonly checkoutTtlBeforeReleasingFunds?: InputMaybe<Scalars['Hour']['input']>;
  /** Determine the transaction flow strategy to be used. Include the selected option in the payload sent to the payment app, as a requested action for the transaction. */
  readonly defaultTransactionFlowStrategy?: InputMaybe<TransactionFlowStrategyEnum>;
  /**
   * Determine if the funds for expired checkouts should be released automatically.
   *
   * Added in Saleor 3.20.
   */
  readonly releaseFundsForExpiredCheckouts?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents a payment source stored for user in payment gateway, such as credit card. */
export type PaymentSource = {
  /** Stored credit card details if available. */
  readonly creditCardInfo?: Maybe<CreditCard>;
  /** Payment gateway name. */
  readonly gateway: Scalars['String']['output'];
  /**
   * List of public metadata items.
   *
   * Can be accessed without permissions.
   */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /** ID of stored payment method. */
  readonly paymentMethodId?: Maybe<Scalars['String']['output']>;
};

/**
 * Voids the authorized payment.
 *
 * Requires one of the following permissions: MANAGE_ORDERS.
 */
export type PaymentVoid = {
  readonly errors: ReadonlyArray<PaymentError>;
  /** Updated payment. */
  readonly payment?: Maybe<Payment>;
  /** @deprecated Use `errors` field instead. */
  readonly paymentErrors: ReadonlyArray<PaymentError>;
};

/** Void payment. */
export type PaymentVoidEvent = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** Look up a payment. */
  readonly payment?: Maybe<Payment>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Represents a permission object in a friendly form. */
export type Permission = {
  /** Internal code for permission. */
  readonly code: PermissionEnum;
  /** Describe action(s) allowed to do by permission. */
  readonly name: Scalars['String']['output'];
};

export type PermissionEnum =
  | 'HANDLE_CHECKOUTS'
  | 'HANDLE_PAYMENTS'
  | 'HANDLE_TAXES'
  | 'IMPERSONATE_USER'
  | 'MANAGE_APPS'
  | 'MANAGE_CHANNELS'
  | 'MANAGE_CHECKOUTS'
  | 'MANAGE_DISCOUNTS'
  | 'MANAGE_GIFT_CARD'
  | 'MANAGE_MENUS'
  | 'MANAGE_OBSERVABILITY'
  | 'MANAGE_ORDERS'
  | 'MANAGE_ORDERS_IMPORT'
  | 'MANAGE_PAGES'
  | 'MANAGE_PAGE_TYPES_AND_ATTRIBUTES'
  | 'MANAGE_PLUGINS'
  | 'MANAGE_PRODUCTS'
  | 'MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES'
  | 'MANAGE_SETTINGS'
  | 'MANAGE_SHIPPING'
  | 'MANAGE_STAFF'
  | 'MANAGE_TAXES'
  | 'MANAGE_TRANSLATIONS'
  | 'MANAGE_USERS';

/**
 * Create new permission group. Apps are not allowed to perform this mutation.
 *
 * Requires one of the following permissions: MANAGE_STAFF.
 *
 * Triggers the following webhook events:
 * - PERMISSION_GROUP_CREATED (async)
 */
export type PermissionGroupCreate = {
  readonly errors: ReadonlyArray<PermissionGroupError>;
  readonly group?: Maybe<Group>;
  /** @deprecated Use `errors` field instead. */
  readonly permissionGroupErrors: ReadonlyArray<PermissionGroupError>;
};

export type PermissionGroupCreateInput = {
  /** List of channels to assign to this group. */
  readonly addChannels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of permission code names to assign to this group. */
  readonly addPermissions?: InputMaybe<ReadonlyArray<PermissionEnum>>;
  /** List of users to assign to this group. */
  readonly addUsers?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Group name. */
  readonly name: Scalars['String']['input'];
  /** Determine if the group has restricted access to channels.  DEFAULT: False */
  readonly restrictedAccessToChannels?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Event sent when new permission group is created. */
export type PermissionGroupCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The permission group the event relates to. */
  readonly permissionGroup?: Maybe<Group>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Delete permission group. Apps are not allowed to perform this mutation.
 *
 * Requires one of the following permissions: MANAGE_STAFF.
 *
 * Triggers the following webhook events:
 * - PERMISSION_GROUP_DELETED (async)
 */
export type PermissionGroupDelete = {
  readonly errors: ReadonlyArray<PermissionGroupError>;
  readonly group?: Maybe<Group>;
  /** @deprecated Use `errors` field instead. */
  readonly permissionGroupErrors: ReadonlyArray<PermissionGroupError>;
};

/** Event sent when permission group is deleted. */
export type PermissionGroupDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The permission group the event relates to. */
  readonly permissionGroup?: Maybe<Group>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type PermissionGroupError = {
  /** List of channels IDs which causes the error. */
  readonly channels?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error code. */
  readonly code: PermissionGroupErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of permissions which causes the error. */
  readonly permissions?: Maybe<ReadonlyArray<PermissionEnum>>;
  /** List of user IDs which causes the error. */
  readonly users?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

export type PermissionGroupErrorCode =
  | 'ASSIGN_NON_STAFF_MEMBER'
  | 'CANNOT_REMOVE_FROM_LAST_GROUP'
  | 'DUPLICATED_INPUT_ITEM'
  | 'LEFT_NOT_MANAGEABLE_PERMISSION'
  | 'OUT_OF_SCOPE_CHANNEL'
  | 'OUT_OF_SCOPE_PERMISSION'
  | 'OUT_OF_SCOPE_USER'
  | 'REQUIRED'
  | 'UNIQUE';

export type PermissionGroupFilterInput = {
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
};

/** Sorting options for permission groups. */
export type PermissionGroupSortField =
  /** Sort permission group accounts by name. */
  | 'NAME';

export type PermissionGroupSortingInput = {
  /** Specifies the direction in which to sort permission group. */
  readonly direction: OrderDirection;
  /** Sort permission group by the selected field. */
  readonly field: PermissionGroupSortField;
};

/**
 * Update permission group. Apps are not allowed to perform this mutation.
 *
 * Requires one of the following permissions: MANAGE_STAFF.
 *
 * Triggers the following webhook events:
 * - PERMISSION_GROUP_UPDATED (async)
 */
export type PermissionGroupUpdate = {
  readonly errors: ReadonlyArray<PermissionGroupError>;
  readonly group?: Maybe<Group>;
  /** @deprecated Use `errors` field instead. */
  readonly permissionGroupErrors: ReadonlyArray<PermissionGroupError>;
};

export type PermissionGroupUpdateInput = {
  /** List of channels to assign to this group. */
  readonly addChannels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of permission code names to assign to this group. */
  readonly addPermissions?: InputMaybe<ReadonlyArray<PermissionEnum>>;
  /** List of users to assign to this group. */
  readonly addUsers?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Group name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** List of channels to unassign from this group. */
  readonly removeChannels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of permission code names to unassign from this group. */
  readonly removePermissions?: InputMaybe<ReadonlyArray<PermissionEnum>>;
  /** List of users to unassign from this group. */
  readonly removeUsers?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Determine if the group has restricted access to channels. */
  readonly restrictedAccessToChannels?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Event sent when permission group is updated. */
export type PermissionGroupUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The permission group the event relates to. */
  readonly permissionGroup?: Maybe<Group>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Plugin. */
export type Plugin = {
  /** Channel-specific plugin configuration. */
  readonly channelConfigurations: ReadonlyArray<PluginConfiguration>;
  /** Description of the plugin. */
  readonly description: Scalars['String']['output'];
  /** Global configuration of the plugin (not channel-specific). */
  readonly globalConfiguration?: Maybe<PluginConfiguration>;
  /** Identifier of the plugin. */
  readonly id: Scalars['ID']['output'];
  /** Name of the plugin. */
  readonly name: Scalars['String']['output'];
};

/** Stores information about a configuration of plugin. */
export type PluginConfiguration = {
  /** Determines if plugin is active or not. */
  readonly active: Scalars['Boolean']['output'];
  /** The channel to which the plugin configuration is assigned to. */
  readonly channel?: Maybe<Channel>;
  /** Configuration of the plugin. */
  readonly configuration?: Maybe<ReadonlyArray<ConfigurationItem>>;
};

export type PluginConfigurationType =
  | 'GLOBAL'
  | 'PER_CHANNEL';

export type PluginCountableConnection = {
  readonly edges: ReadonlyArray<PluginCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type PluginCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Plugin;
};

export type PluginError = {
  /** The error code. */
  readonly code: PluginErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type PluginErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'PLUGIN_MISCONFIGURED'
  | 'REQUIRED'
  | 'UNIQUE';

export type PluginFilterInput = {
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly statusInChannels?: InputMaybe<PluginStatusInChannelsInput>;
  readonly type?: InputMaybe<PluginConfigurationType>;
};

export type PluginSortField =
  | 'IS_ACTIVE'
  | 'NAME';

export type PluginSortingInput = {
  /** Specifies the direction in which to sort plugins. */
  readonly direction: OrderDirection;
  /** Sort plugins by the selected field. */
  readonly field: PluginSortField;
};

export type PluginStatusInChannelsInput = {
  readonly active: Scalars['Boolean']['input'];
  readonly channels: ReadonlyArray<Scalars['ID']['input']>;
};

/**
 * Update plugin configuration.
 *
 * Requires one of the following permissions: MANAGE_PLUGINS.
 */
export type PluginUpdate = {
  readonly errors: ReadonlyArray<PluginError>;
  readonly plugin?: Maybe<Plugin>;
  /** @deprecated Use `errors` field instead. */
  readonly pluginsErrors: ReadonlyArray<PluginError>;
};

export type PluginUpdateInput = {
  /** Indicates whether the plugin should be enabled. */
  readonly active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Configuration of the plugin. */
  readonly configuration?: InputMaybe<ReadonlyArray<ConfigurationItemInput>>;
};

export type PostalCodeRuleInclusionTypeEnum =
  | 'EXCLUDE'
  | 'INCLUDE';

/** Represents preorder settings for product variant. */
export type PreorderData = {
  /** Preorder end date. */
  readonly endDate?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Total number of sold product variant during preorder.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly globalSoldUnits: Scalars['Int']['output'];
  /**
   * The global preorder threshold for product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly globalThreshold?: Maybe<Scalars['Int']['output']>;
};

export type PreorderSettingsInput = {
  /** The end date for preorder. */
  readonly endDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** The global threshold for preorder variant. */
  readonly globalThreshold?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents preorder variant data for channel. */
export type PreorderThreshold = {
  /** Preorder threshold for product variant in this channel. */
  readonly quantity?: Maybe<Scalars['Int']['output']>;
  /** Number of sold product variant in this channel. */
  readonly soldUnits: Scalars['Int']['output'];
};

export type PriceFilterInput = {
  /** The amount of the price to filter by. */
  readonly amount: DecimalFilterInput;
  /** The currency of the price to filter by. */
  readonly currency?: InputMaybe<Scalars['String']['input']>;
};

export type PriceInput = {
  /** Amount of money. */
  readonly amount: Scalars['PositiveDecimal']['input'];
  /** Currency code. */
  readonly currency: Scalars['String']['input'];
};

export type PriceRangeInput = {
  /** Price greater than or equal to. */
  readonly gte?: InputMaybe<Scalars['Float']['input']>;
  /** Price less than or equal to. */
  readonly lte?: InputMaybe<Scalars['Float']['input']>;
};

/** Represents an individual item for sale in the storefront. */
export type Product = Node & ObjectWithAttributes & ObjectWithMetadata & {
  /**
   * Get a single attribute attached to product by attribute slug.
   *
   * Added in Saleor 3.22.
   */
  readonly assignedAttribute?: Maybe<AssignedAttribute>;
  /**
   * List of attributes assigned to this product.
   *
   * Added in Saleor 3.22.
   */
  readonly assignedAttributes: ReadonlyArray<AssignedAttribute>;
  /**
   * Get a single attribute attached to product by attribute slug.
   * @deprecated Use the `assignedAttribute` field instead.
   */
  readonly attribute?: Maybe<SelectedAttribute>;
  /**
   * List of attributes assigned to this product.
   * @deprecated Use the `assignedAttributes` field instead.
   */
  readonly attributes: ReadonlyArray<SelectedAttribute>;
  /**
   * Date when product is available for purchase.
   * @deprecated Use the `availableForPurchaseAt` field to fetch the available for purchase date.
   */
  readonly availableForPurchase?: Maybe<Scalars['Date']['output']>;
  /** Date when product is available for purchase. */
  readonly availableForPurchaseAt?: Maybe<Scalars['DateTime']['output']>;
  readonly category?: Maybe<Category>;
  /** Channel given to retrieve this product. Also used by federation gateway to resolve this object in a federated query. */
  readonly channel?: Maybe<Scalars['String']['output']>;
  /**
   * List of availability in channels for the product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly channelListings?: Maybe<ReadonlyArray<ProductChannelListing>>;
  /** @deprecated Use `Channel.taxConfiguration` field to determine whether tax collection is enabled. */
  readonly chargeTaxes: Scalars['Boolean']['output'];
  /** List of collections for the product. Requires the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  readonly collections?: Maybe<ReadonlyArray<Collection>>;
  /** The date and time when the product was created. */
  readonly created: Scalars['DateTime']['output'];
  /** Default variant of the product. */
  readonly defaultVariant?: Maybe<ProductVariant>;
  /**
   * Description of the product.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /**
   * Description of the product.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  readonly descriptionJson?: Maybe<Scalars['JSONString']['output']>;
  /** External ID of this product. */
  readonly externalReference?: Maybe<Scalars['String']['output']>;
  /** The ID of the product. */
  readonly id: Scalars['ID']['output'];
  /**
   * Get a single product image by ID.
   * @deprecated Use the `mediaById` field instead.
   */
  readonly imageById?: Maybe<ProductImage>;
  /**
   * List of images for the product.
   * @deprecated Use the `media` field instead.
   */
  readonly images?: Maybe<ReadonlyArray<ProductImage>>;
  /** Whether the product is in stock, set as available for purchase in the given channel, and published. */
  readonly isAvailable?: Maybe<Scalars['Boolean']['output']>;
  /** Refers to a state that can be set by admins to control whether a product is available for purchase in storefronts. This does not guarantee the availability of stock. When set to `False`, this product is still visible to customers, but it cannot be purchased. */
  readonly isAvailableForPurchase?: Maybe<Scalars['Boolean']['output']>;
  /** List of media for the product. */
  readonly media?: Maybe<ReadonlyArray<ProductMedia>>;
  /** Get a single product media by ID. */
  readonly mediaById?: Maybe<ProductMedia>;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** SEO description of the product. */
  readonly name: Scalars['String']['output'];
  /** Lists the storefront product's pricing, the current price and discounts, only meant for displaying. */
  readonly pricing?: Maybe<ProductPricingInfo>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Type of the product. */
  readonly productType: ProductType;
  /**
   * List of variants for the product. Requires the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS.
   *
   * Added in Saleor 3.21.
   */
  readonly productVariants?: Maybe<ProductVariantCountableConnection>;
  /** Rating of the product. */
  readonly rating?: Maybe<Scalars['Float']['output']>;
  /** SEO description of the product. */
  readonly seoDescription?: Maybe<Scalars['String']['output']>;
  /** SEO title of the product. */
  readonly seoTitle?: Maybe<Scalars['String']['output']>;
  /** Slug of the product. */
  readonly slug: Scalars['String']['output'];
  /**
   * Tax class assigned to this product type. All products of this product type use this tax class, unless it's overridden in the `Product` type.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly taxClass?: Maybe<TaxClass>;
  /**
   * A type of tax. Assigned by enabled tax gateway
   * @deprecated Use `taxClass` field instead.
   */
  readonly taxType?: Maybe<TaxType>;
  /** Thumbnail of the product. */
  readonly thumbnail?: Maybe<Image>;
  /** Returns translated product fields for the given language code. */
  readonly translation?: Maybe<ProductTranslation>;
  /** The date and time when the product was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /**
   * Get a single variant by SKU or ID.
   * @deprecated Use top-level `variant` query.
   */
  readonly variant?: Maybe<ProductVariant>;
  /**
   * List of variants for the product. Requires the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS.
   * @deprecated Use `productVariants` field instead.
   */
  readonly variants?: Maybe<ReadonlyArray<ProductVariant>>;
  /** Weight of the product. */
  readonly weight?: Maybe<Weight>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductAssignedAttributeArgs = {
  slug: Scalars['String']['input'];
};


/** Represents an individual item for sale in the storefront. */
export type ProductAssignedAttributesArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']['input']>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductAttributeArgs = {
  slug: Scalars['String']['input'];
};


/** Represents an individual item for sale in the storefront. */
export type ProductImageByIdArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductIsAvailableArgs = {
  address?: InputMaybe<AddressInput>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductMediaArgs = {
  sortBy?: InputMaybe<MediaSortingInput>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductMediaByIdArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents an individual item for sale in the storefront. */
export type ProductMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductPricingArgs = {
  address?: InputMaybe<AddressInput>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents an individual item for sale in the storefront. */
export type ProductPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductProductVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ProductVariantFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<ProductVariantSortingInput>;
  where?: InputMaybe<ProductVariantWhereInput>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductThumbnailArgs = {
  format?: InputMaybe<ThumbnailFormatEnum>;
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductTranslationArgs = {
  languageCode: LanguageCodeEnum;
};


/** Represents an individual item for sale in the storefront. */
export type ProductVariantArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Assign attributes to a given product type.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductAttributeAssign = {
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  /** The updated product type. */
  readonly productType?: Maybe<ProductType>;
};

export type ProductAttributeAssignInput = {
  /** The ID of the attribute to assign. */
  readonly id: Scalars['ID']['input'];
  /** The attribute type to be assigned as. */
  readonly type: ProductAttributeType;
  /** Whether attribute is allowed in variant selection. Allowed types are: ['dropdown', 'boolean', 'swatch', 'numeric']. */
  readonly variantSelection?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * Update attributes assigned to product variant for given product type.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductAttributeAssignmentUpdate = {
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  /** The updated product type. */
  readonly productType?: Maybe<ProductType>;
};

export type ProductAttributeAssignmentUpdateInput = {
  /** The ID of the attribute to assign. */
  readonly id: Scalars['ID']['input'];
  /** Whether attribute is allowed in variant selection. Allowed types are: ['dropdown', 'boolean', 'swatch', 'numeric']. */
  readonly variantSelection: Scalars['Boolean']['input'];
};

export type ProductAttributeType =
  | 'PRODUCT'
  | 'VARIANT';

/**
 * Un-assign attributes from a given product type.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductAttributeUnassign = {
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  /** The updated product type. */
  readonly productType?: Maybe<ProductType>;
};

/**
 * Creates products.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductBulkCreate = {
  /** Returns how many objects were created. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<ProductBulkCreateError>;
  /** List of the created products. */
  readonly results: ReadonlyArray<ProductBulkResult>;
};

export type ProductBulkCreateError = {
  /** List of attributes IDs which causes the error. */
  readonly attributes?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** List of channel IDs which causes the error. */
  readonly channels?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error code. */
  readonly code: ProductBulkCreateErrorCode;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly path?: Maybe<Scalars['String']['output']>;
  /** List of attribute values IDs which causes the error. */
  readonly values?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** List of warehouse IDs which causes the error. */
  readonly warehouses?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

export type ProductBulkCreateErrorCode =
  | 'ATTRIBUTE_ALREADY_ASSIGNED'
  | 'ATTRIBUTE_CANNOT_BE_ASSIGNED'
  | 'ATTRIBUTE_VARIANTS_DISABLED'
  | 'BLANK'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_PRICE'
  | 'MAX_LENGTH'
  | 'NOT_FOUND'
  | 'PRODUCT_NOT_ASSIGNED_TO_CHANNEL'
  | 'PRODUCT_WITHOUT_CATEGORY'
  | 'REQUIRED'
  | 'UNIQUE'
  | 'UNSUPPORTED_MEDIA_PROVIDER';

export type ProductBulkCreateInput = {
  /** List of attributes. */
  readonly attributes?: InputMaybe<ReadonlyArray<AttributeValueInput>>;
  /** ID of the product's category. */
  readonly category?: InputMaybe<Scalars['ID']['input']>;
  /** List of channels in which the product is available. */
  readonly channelListings?: InputMaybe<ReadonlyArray<ProductChannelListingCreateInput>>;
  /**
   * Determine if taxes are being charged for the product.
   * @deprecated Use `Channel.taxConfiguration` to configure whether tax collection is enabled.
   */
  readonly chargeTaxes?: InputMaybe<Scalars['Boolean']['input']>;
  /** List of IDs of collections that the product belongs to. */
  readonly collections?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /**
   * Product description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: InputMaybe<Scalars['JSONString']['input']>;
  /** External ID of this product. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** List of media inputs associated with the product. */
  readonly media?: InputMaybe<ReadonlyArray<MediaInput>>;
  /**
   * Fields required to update the product metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Product name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the product private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** ID of the type that product belongs to. */
  readonly productType: Scalars['ID']['input'];
  /** Defines the product rating value. */
  readonly rating?: InputMaybe<Scalars['Float']['input']>;
  /** Search engine optimization fields. */
  readonly seo?: InputMaybe<SeoInput>;
  /** Product slug. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
  /** ID of a tax class to assign to this product. If not provided, product will use the tax class which is assigned to the product type. */
  readonly taxClass?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Tax rate for enabled tax gateway.
   * @deprecated Use tax classes to control the tax calculation for a product. If taxCode is provided, Saleor will try to find a tax class with given code (codes are stored in metadata) and assign it. If no tax class is found, it would be created and assigned.
   */
  readonly taxCode?: InputMaybe<Scalars['String']['input']>;
  /** Input list of product variants to create. */
  readonly variants?: InputMaybe<ReadonlyArray<ProductVariantBulkCreateInput>>;
  /** Weight of the Product. */
  readonly weight?: InputMaybe<Scalars['WeightScalar']['input']>;
};

/**
 * Deletes products.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

export type ProductBulkResult = {
  /** List of errors occurred on create attempt. */
  readonly errors?: Maybe<ReadonlyArray<ProductBulkCreateError>>;
  /** Product data. */
  readonly product?: Maybe<Product>;
};

/**
 * Creates/updates translations for products.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 *
 * Triggers the following webhook events:
 * - TRANSLATION_CREATED (async): Called when a translation was created.
 * - TRANSLATION_UPDATED (async): Called when a translation was updated.
 */
export type ProductBulkTranslate = {
  /** Returns how many translations were created/updated. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<ProductBulkTranslateError>;
  /** List of the translations. */
  readonly results: ReadonlyArray<ProductBulkTranslateResult>;
};

export type ProductBulkTranslateError = {
  /** The error code. */
  readonly code: ProductTranslateErrorCode;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly path?: Maybe<Scalars['String']['output']>;
};

export type ProductBulkTranslateInput = {
  /** External reference of an product. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** Product ID. */
  readonly id?: InputMaybe<Scalars['ID']['input']>;
  /** Translation language code. */
  readonly languageCode: LanguageCodeEnum;
  /** Translation fields. */
  readonly translationFields: TranslationInput;
};

export type ProductBulkTranslateResult = {
  /** List of errors occurred on translation attempt. */
  readonly errors?: Maybe<ReadonlyArray<ProductBulkTranslateError>>;
  /** Product translation data. */
  readonly translation?: Maybe<ProductTranslation>;
};

/** Represents product channel listing. */
export type ProductChannelListing = Node & {
  /** @deprecated Use the `availableForPurchaseAt` field to fetch the available for purchase date. */
  readonly availableForPurchase?: Maybe<Scalars['Date']['output']>;
  /** The product available for purchase date time. */
  readonly availableForPurchaseAt?: Maybe<Scalars['DateTime']['output']>;
  /** The channel in which the product is listed. */
  readonly channel: Channel;
  /** The price of the cheapest variant (including discounts). */
  readonly discountedPrice?: Maybe<Money>;
  /** The ID of the product channel listing. */
  readonly id: Scalars['ID']['output'];
  /** Refers to a state that can be set by admins to control whether a product is available for purchase in storefronts in this channel. This does not guarantee the availability of stock. When set to `False`, this product is still visible to customers, but it cannot be purchased. */
  readonly isAvailableForPurchase?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if the product is published in the channel. */
  readonly isPublished: Scalars['Boolean']['output'];
  /**
   * Range of margin percentage value.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly margin?: Maybe<Margin>;
  /** Lists the storefront product's pricing, the current price and discounts, only meant for displaying. */
  readonly pricing?: Maybe<ProductPricingInfo>;
  /** @deprecated Use the `publishedAt` field to fetch the publication date. */
  readonly publicationDate?: Maybe<Scalars['Date']['output']>;
  /** The product publication date time. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Purchase cost of product.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly purchaseCost?: Maybe<MoneyRange>;
  /** Indicates product visibility in the channel listings. */
  readonly visibleInListings: Scalars['Boolean']['output'];
};


/** Represents product channel listing. */
export type ProductChannelListingPricingArgs = {
  address?: InputMaybe<AddressInput>;
};

export type ProductChannelListingAddInput = {
  /** List of variants to which the channel should be assigned. */
  readonly addVariants?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** A start date time from which a product will be available for purchase. When not set and `isAvailable` is set to True, the current day is assumed. */
  readonly availableForPurchaseAt?: InputMaybe<Scalars['DateTime']['input']>;
  /**
   * A start date from which a product will be available for purchase. When not set and isAvailable is set to True, the current day is assumed.
   * @deprecated Use `availableForPurchaseAt` field instead.
   */
  readonly availableForPurchaseDate?: InputMaybe<Scalars['Date']['input']>;
  /** ID of a channel. */
  readonly channelId: Scalars['ID']['input'];
  /** Determines if product should be available for purchase in this channel. This does not guarantee the availability of stock. When set to `False`, this product is still visible to customers, but it cannot be purchased. */
  readonly isAvailableForPurchase?: InputMaybe<Scalars['Boolean']['input']>;
  /** Determines if object is visible to customers. */
  readonly isPublished?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Publication date. ISO 8601 standard.
   * @deprecated Use `publishedAt` field instead.
   */
  readonly publicationDate?: InputMaybe<Scalars['Date']['input']>;
  /** Publication date time. ISO 8601 standard. */
  readonly publishedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** List of variants from which the channel should be unassigned. */
  readonly removeVariants?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Determines if product is visible in product listings (doesn't apply to product collections). */
  readonly visibleInListings?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductChannelListingCreateInput = {
  /** A start date time from which a product will be available for purchase. When not set and `isAvailable` is set to True, the current day is assumed. */
  readonly availableForPurchaseAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** ID of a channel. */
  readonly channelId: Scalars['ID']['input'];
  /** Determines if product should be available for purchase in this channel. This does not guarantee the availability of stock. When set to `False`, this product is still visible to customers, but it cannot be purchased. */
  readonly isAvailableForPurchase?: InputMaybe<Scalars['Boolean']['input']>;
  /** Determines if object is visible to customers. */
  readonly isPublished?: InputMaybe<Scalars['Boolean']['input']>;
  /** Publication date time. ISO 8601 standard. */
  readonly publishedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** Determines if product is visible in product listings (doesn't apply to product collections). */
  readonly visibleInListings?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductChannelListingError = {
  /** List of attributes IDs which causes the error. */
  readonly attributes?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** List of channels IDs which causes the error. */
  readonly channels?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error code. */
  readonly code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of attribute values IDs which causes the error. */
  readonly values?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** List of variants IDs which causes the error. */
  readonly variants?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

/**
 * Manage product's availability in channels.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductChannelListingUpdate = {
  readonly errors: ReadonlyArray<ProductChannelListingError>;
  /** An updated product instance. */
  readonly product?: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  readonly productChannelListingErrors: ReadonlyArray<ProductChannelListingError>;
};

export type ProductChannelListingUpdateInput = {
  /** List of channels from which the product should be unassigned. */
  readonly removeChannels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of channels to which the product should be assigned or updated. */
  readonly updateChannels?: InputMaybe<ReadonlyArray<ProductChannelListingAddInput>>;
};

export type ProductCountableConnection = {
  readonly edges: ReadonlyArray<ProductCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type ProductCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Product;
};

/**
 * Creates a new product.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductCreate = {
  readonly errors: ReadonlyArray<ProductError>;
  readonly product?: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

export type ProductCreateInput = {
  /** List of attributes. */
  readonly attributes?: InputMaybe<ReadonlyArray<AttributeValueInput>>;
  /** ID of the product's category. */
  readonly category?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Determine if taxes are being charged for the product.
   * @deprecated Use `Channel.taxConfiguration` to configure whether tax collection is enabled.
   */
  readonly chargeTaxes?: InputMaybe<Scalars['Boolean']['input']>;
  /** List of IDs of collections that the product belongs to. */
  readonly collections?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /**
   * Product description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: InputMaybe<Scalars['JSONString']['input']>;
  /** External ID of this product. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the product metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Product name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the product private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** ID of the type that product belongs to. */
  readonly productType: Scalars['ID']['input'];
  /** Defines the product rating value. */
  readonly rating?: InputMaybe<Scalars['Float']['input']>;
  /** Search engine optimization fields. */
  readonly seo?: InputMaybe<SeoInput>;
  /** Product slug. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
  /** ID of a tax class to assign to this product. If not provided, product will use the tax class which is assigned to the product type. */
  readonly taxClass?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Tax rate for enabled tax gateway.
   * @deprecated Use tax classes to control the tax calculation for a product. If taxCode is provided, Saleor will try to find a tax class with given code (codes are stored in metadata) and assign it. If no tax class is found, it would be created and assigned.
   */
  readonly taxCode?: InputMaybe<Scalars['String']['input']>;
  /** Weight of the Product. */
  readonly weight?: InputMaybe<Scalars['WeightScalar']['input']>;
};

/** Event sent when new product is created. */
export type ProductCreated = Event & {
  /** The category of the product. */
  readonly category?: Maybe<Category>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The product the event relates to. */
  readonly product?: Maybe<Product>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when new product is created. */
export type ProductCreatedProductArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Deletes a product.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductDelete = {
  readonly errors: ReadonlyArray<ProductError>;
  readonly product?: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

/** Event sent when product is deleted. */
export type ProductDeleted = Event & {
  /** The category of the product. */
  readonly category?: Maybe<Category>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The product the event relates to. */
  readonly product?: Maybe<Product>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when product is deleted. */
export type ProductDeletedProductArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

export type ProductError = {
  /** List of attributes IDs which causes the error. */
  readonly attributes?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error code. */
  readonly code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of attribute values IDs which causes the error. */
  readonly values?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

export type ProductErrorCode =
  | 'ALREADY_EXISTS'
  | 'ATTRIBUTE_ALREADY_ASSIGNED'
  | 'ATTRIBUTE_CANNOT_BE_ASSIGNED'
  | 'ATTRIBUTE_VARIANTS_DISABLED'
  | 'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_PRICE'
  | 'MEDIA_ALREADY_ASSIGNED'
  | 'NOT_FOUND'
  | 'NOT_PRODUCTS_IMAGE'
  | 'NOT_PRODUCTS_VARIANT'
  | 'PREORDER_VARIANT_CANNOT_BE_DEACTIVATED'
  | 'PRODUCT_NOT_ASSIGNED_TO_CHANNEL'
  | 'PRODUCT_WITHOUT_CATEGORY'
  | 'REQUIRED'
  | 'UNIQUE'
  | 'UNSUPPORTED_MEDIA_PROVIDER'
  | 'VARIANT_NO_DIGITAL_CONTENT';

/** Event sent when product export is completed. */
export type ProductExportCompleted = Event & {
  /** The export file for products. */
  readonly export?: Maybe<ExportFile>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type ProductFieldEnum =
  | 'CATEGORY'
  | 'CHARGE_TAXES'
  | 'COLLECTIONS'
  | 'DESCRIPTION'
  | 'NAME'
  | 'PRODUCT_MEDIA'
  | 'PRODUCT_TYPE'
  | 'PRODUCT_WEIGHT'
  | 'VARIANT_ID'
  | 'VARIANT_MEDIA'
  | 'VARIANT_SKU'
  | 'VARIANT_WEIGHT';

export type ProductFilterInput = {
  readonly attributes?: InputMaybe<ReadonlyArray<AttributeInput>>;
  /** Filter by the date of availability for purchase. */
  readonly availableFrom?: InputMaybe<Scalars['DateTime']['input']>;
  readonly categories?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /**
   * Specifies the channel by which the data should be filtered.
   * @deprecated Use root-level channel argument instead.
   */
  readonly channel?: InputMaybe<Scalars['String']['input']>;
  readonly collections?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Filter on whether product is a gift card or not. */
  readonly giftCard?: InputMaybe<Scalars['Boolean']['input']>;
  readonly hasCategory?: InputMaybe<Scalars['Boolean']['input']>;
  readonly hasPreorderedVariants?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Filter by availability for purchase. */
  readonly isAvailable?: InputMaybe<Scalars['Boolean']['input']>;
  readonly isPublished?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by visibility in product listings. */
  readonly isVisibleInListing?: InputMaybe<Scalars['Boolean']['input']>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  /** Filter by the lowest variant price after discounts. */
  readonly minimalPrice?: InputMaybe<PriceRangeInput>;
  readonly price?: InputMaybe<PriceRangeInput>;
  readonly productTypes?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Filter by the publication date. */
  readonly publishedFrom?: InputMaybe<Scalars['DateTime']['input']>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly slugs?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** Filter by variants having specific stock status. */
  readonly stockAvailability?: InputMaybe<StockAvailability>;
  readonly stocks?: InputMaybe<ProductStockFilterInput>;
  /** Filter by when was the most recent update. */
  readonly updatedAt?: InputMaybe<DateTimeRangeInput>;
};

/** Represents a product image. */
export type ProductImage = {
  /** The alt text of the image. */
  readonly alt?: Maybe<Scalars['String']['output']>;
  /** The ID of the image. */
  readonly id: Scalars['ID']['output'];
  /** The new relative sorting position of the item (from -inf to +inf). 1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged. */
  readonly sortOrder?: Maybe<Scalars['Int']['output']>;
  /** The URL of the image. */
  readonly url: Scalars['String']['output'];
};


/** Represents a product image. */
export type ProductImageUrlArgs = {
  format?: InputMaybe<ThumbnailFormatEnum>;
  size?: InputMaybe<Scalars['Int']['input']>;
};

export type ProductInput = {
  /** List of attributes. */
  readonly attributes?: InputMaybe<ReadonlyArray<AttributeValueInput>>;
  /** ID of the product's category. */
  readonly category?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Determine if taxes are being charged for the product.
   * @deprecated Use `Channel.taxConfiguration` to configure whether tax collection is enabled.
   */
  readonly chargeTaxes?: InputMaybe<Scalars['Boolean']['input']>;
  /** List of IDs of collections that the product belongs to. */
  readonly collections?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /**
   * Product description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: InputMaybe<Scalars['JSONString']['input']>;
  /** External ID of this product. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the product metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Product name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the product private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Defines the product rating value. */
  readonly rating?: InputMaybe<Scalars['Float']['input']>;
  /** Search engine optimization fields. */
  readonly seo?: InputMaybe<SeoInput>;
  /** Product slug. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
  /** ID of a tax class to assign to this product. If not provided, product will use the tax class which is assigned to the product type. */
  readonly taxClass?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Tax rate for enabled tax gateway.
   * @deprecated Use tax classes to control the tax calculation for a product. If taxCode is provided, Saleor will try to find a tax class with given code (codes are stored in metadata) and assign it. If no tax class is found, it would be created and assigned.
   */
  readonly taxCode?: InputMaybe<Scalars['String']['input']>;
  /** Weight of the Product. */
  readonly weight?: InputMaybe<Scalars['WeightScalar']['input']>;
};

/** Represents a product media. */
export type ProductMedia = Node & ObjectWithMetadata & {
  /** The alt text of the media. */
  readonly alt: Scalars['String']['output'];
  /** The unique ID of the product media. */
  readonly id: Scalars['ID']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** The oEmbed data of the media. */
  readonly oembedData: Scalars['JSONString']['output'];
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Product id the media refers to. */
  readonly productId?: Maybe<Scalars['ID']['output']>;
  /** The sort order of the media. */
  readonly sortOrder?: Maybe<Scalars['Int']['output']>;
  /** The type of the media. */
  readonly type: ProductMediaType;
  /** The URL of the media. */
  readonly url: Scalars['String']['output'];
};


/** Represents a product media. */
export type ProductMediaMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a product media. */
export type ProductMediaMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a product media. */
export type ProductMediaPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a product media. */
export type ProductMediaPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a product media. */
export type ProductMediaUrlArgs = {
  format?: InputMaybe<ThumbnailFormatEnum>;
  size?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * Deletes product media.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductMediaBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

/**
 * Create a media object (image or video URL) associated with product. For image, this mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductMediaCreate = {
  readonly errors: ReadonlyArray<ProductError>;
  readonly media?: Maybe<ProductMedia>;
  readonly product?: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

export type ProductMediaCreateInput = {
  /** Alt text for a product media. */
  readonly alt?: InputMaybe<Scalars['String']['input']>;
  /** Represents an image file in a multipart request. */
  readonly image?: InputMaybe<Scalars['Upload']['input']>;
  /** Represents an URL to an external media. */
  readonly mediaUrl?: InputMaybe<Scalars['String']['input']>;
  /** ID of an product. */
  readonly product: Scalars['ID']['input'];
};

/** Event sent when new product media is created. */
export type ProductMediaCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The product media the event relates to. */
  readonly productMedia?: Maybe<ProductMedia>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Deletes a product media.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductMediaDelete = {
  readonly errors: ReadonlyArray<ProductError>;
  readonly media?: Maybe<ProductMedia>;
  readonly product?: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

/** Event sent when product media is deleted. */
export type ProductMediaDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The product media the event relates to. */
  readonly productMedia?: Maybe<ProductMedia>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Changes ordering of the product media.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductMediaReorder = {
  readonly errors: ReadonlyArray<ProductError>;
  readonly media?: Maybe<ReadonlyArray<ProductMedia>>;
  readonly product?: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

export type ProductMediaType =
  | 'IMAGE'
  | 'VIDEO';

/**
 * Updates a product media.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductMediaUpdate = {
  readonly errors: ReadonlyArray<ProductError>;
  readonly media?: Maybe<ProductMedia>;
  readonly product?: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

export type ProductMediaUpdateInput = {
  /** Alt text for a product media. */
  readonly alt?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when product media is updated. */
export type ProductMediaUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The product media the event relates to. */
  readonly productMedia?: Maybe<ProductMedia>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Event sent when product metadata is updated. */
export type ProductMetadataUpdated = Event & {
  /** The category of the product. */
  readonly category?: Maybe<Category>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The product the event relates to. */
  readonly product?: Maybe<Product>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when product metadata is updated. */
export type ProductMetadataUpdatedProductArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

export type ProductOrder = {
  /**
   * Sort product by the selected attribute's values.
   * Note: this doesn't take translations into account yet.
   */
  readonly attributeId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Specifies the channel in which to sort the data.
   * @deprecated Use root-level channel argument instead.
   */
  readonly channel?: InputMaybe<Scalars['String']['input']>;
  /** Specifies the direction in which to sort products. */
  readonly direction: OrderDirection;
  /** Sort products by the selected field. */
  readonly field?: InputMaybe<ProductOrderField>;
};

export type ProductOrderField =
  /**
   * Sort products by collection. Note: This option is available only for the `Collection.products` query.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'COLLECTION'
  /** Sort products by creation date. */
  | 'CREATED_AT'
  /** Sort products by update date. */
  | 'DATE'
  /** Sort products by update date. */
  | 'LAST_MODIFIED'
  /** Sort products by update date. */
  | 'LAST_MODIFIED_AT'
  /**
   * Sort products by a minimal price of a product's variant.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'MINIMAL_PRICE'
  /** Sort products by name. */
  | 'NAME'
  /**
   * Sort products by price.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'PRICE'
  /**
   * Sort products by publication date.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'PUBLICATION_DATE'
  /**
   * Sort products by publication status.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'PUBLISHED'
  /**
   * Sort products by publication date.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'PUBLISHED_AT'
  /** Sort products by rank. Note: This option is available only with the `search` filter. */
  | 'RANK'
  /** Sort products by rating. */
  | 'RATING'
  /** Sort products by type. */
  | 'TYPE';

/** Represents availability of a product in the storefront. */
export type ProductPricingInfo = {
  /** The discount amount if in sale (null otherwise). */
  readonly discount?: Maybe<TaxedMoney>;
  /**
   * The discount amount in the local currency.
   * @deprecated Always returns `null`.
   */
  readonly discountLocalCurrency?: Maybe<TaxedMoney>;
  /**
   * The discount amount compared to prior price. Null if product is not on sale or prior price was not provided in VariantChannelListing
   *
   * Added in Saleor 3.21.
   */
  readonly discountPrior?: Maybe<TaxedMoney>;
  /** Determines whether displayed prices should include taxes. */
  readonly displayGrossPrices: Scalars['Boolean']['output'];
  /** Whether it is in sale or not. */
  readonly onSale?: Maybe<Scalars['Boolean']['output']>;
  /** The discounted price range of the product variants. */
  readonly priceRange?: Maybe<TaxedMoneyRange>;
  /**
   * The discounted price range of the product variants in the local currency.
   * @deprecated Always returns `null`.
   */
  readonly priceRangeLocalCurrency?: Maybe<TaxedMoneyRange>;
  /**
   * The prior price range of the product variants.
   *
   * Added in Saleor 3.21.
   */
  readonly priceRangePrior?: Maybe<TaxedMoneyRange>;
  /** The undiscounted price range of the product variants. */
  readonly priceRangeUndiscounted?: Maybe<TaxedMoneyRange>;
};

/**
 * Reorder product attribute values.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductReorderAttributeValues = {
  readonly errors: ReadonlyArray<ProductError>;
  /** Product from which attribute values are reordered. */
  readonly product?: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

export type ProductStockFilterInput = {
  readonly quantity?: InputMaybe<IntRangeInput>;
  readonly warehouseIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/** Represents product's original translatable fields and related translations. */
export type ProductTranslatableContent = Node & {
  /** List of product attribute values that can be translated. */
  readonly attributeValues: ReadonlyArray<AttributeValueTranslatableContent>;
  /**
   * Product's description to translate.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /**
   * Description of the product.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  readonly descriptionJson?: Maybe<Scalars['JSONString']['output']>;
  /** The ID of the product translatable content. */
  readonly id: Scalars['ID']['output'];
  /** Product's name to translate. */
  readonly name: Scalars['String']['output'];
  /**
   * Represents an individual item for sale in the storefront.
   * @deprecated Get model fields from the root level queries.
   */
  readonly product?: Maybe<Product>;
  /** The ID of the product to translate. */
  readonly productId: Scalars['ID']['output'];
  /** SEO description to translate. */
  readonly seoDescription?: Maybe<Scalars['String']['output']>;
  /** SEO title to translate. */
  readonly seoTitle?: Maybe<Scalars['String']['output']>;
  /**
   * Slug to translate.
   *
   * Added in Saleor 3.21.
   */
  readonly slug?: Maybe<Scalars['String']['output']>;
  /** Returns translated product fields for the given language code. */
  readonly translation?: Maybe<ProductTranslation>;
};


/** Represents product's original translatable fields and related translations. */
export type ProductTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a product.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type ProductTranslate = {
  readonly errors: ReadonlyArray<TranslationError>;
  readonly product?: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  readonly translationErrors: ReadonlyArray<TranslationError>;
};

export type ProductTranslateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

/** Represents product translations. */
export type ProductTranslation = Node & {
  /**
   * Translated description of the product.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /**
   * Translated description of the product.
   *
   * Rich text format. For reference see https://editorjs.io/
   * @deprecated Use the `description` field instead.
   */
  readonly descriptionJson?: Maybe<Scalars['JSONString']['output']>;
  /** The ID of the product translation. */
  readonly id: Scalars['ID']['output'];
  /** Translation language. */
  readonly language: LanguageDisplay;
  /** Translated product name. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Translated SEO description. */
  readonly seoDescription?: Maybe<Scalars['String']['output']>;
  /** Translated SEO title. */
  readonly seoTitle?: Maybe<Scalars['String']['output']>;
  /**
   * Translated product slug.
   *
   * Added in Saleor 3.21.
   */
  readonly slug?: Maybe<Scalars['String']['output']>;
  /** Represents the product fields to translate. */
  readonly translatableContent?: Maybe<ProductTranslatableContent>;
};

/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductType = Node & ObjectWithMetadata & {
  /** Variant attributes of that product type with attached variant selection. */
  readonly assignedVariantAttributes?: Maybe<ReadonlyArray<AssignedVariantAttribute>>;
  /**
   * List of attributes which can be assigned to this product type.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly availableAttributes?: Maybe<AttributeCountableConnection>;
  /** Whether the product type has variants. */
  readonly hasVariants: Scalars['Boolean']['output'];
  /** The ID of the product type. */
  readonly id: Scalars['ID']['output'];
  /** Whether the product type is digital. */
  readonly isDigital: Scalars['Boolean']['output'];
  /** Whether shipping is required for this product type. */
  readonly isShippingRequired: Scalars['Boolean']['output'];
  /** The product type kind. */
  readonly kind: ProductTypeKindEnum;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Name of the product type. */
  readonly name: Scalars['String']['output'];
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Product attributes of that product type. */
  readonly productAttributes?: Maybe<ReadonlyArray<Attribute>>;
  /**
   * List of products of this type.
   * @deprecated Use the top-level `products` query with the `productTypes` filter.
   */
  readonly products?: Maybe<ProductCountableConnection>;
  /** Slug of the product type. */
  readonly slug: Scalars['String']['output'];
  /**
   * Tax class assigned to this product type. All products of this product type use this tax class, unless it's overridden in the `Product` type.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly taxClass?: Maybe<TaxClass>;
  /**
   * A type of tax. Assigned by enabled tax gateway
   * @deprecated Use `taxClass` field instead.
   */
  readonly taxType?: Maybe<TaxType>;
  /**
   * Variant attributes of that product type.
   * @deprecated Use `assignedVariantAttributes` instead.
   */
  readonly variantAttributes?: Maybe<ReadonlyArray<Attribute>>;
  /** Weight of the product type. */
  readonly weight?: Maybe<Weight>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeAssignedVariantAttributesArgs = {
  variantSelection?: InputMaybe<VariantAttributeScope>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeAvailableAttributesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AttributeFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  where?: InputMaybe<AttributeWhereInput>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypePrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypePrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeVariantAttributesArgs = {
  variantSelection?: InputMaybe<VariantAttributeScope>;
};

/**
 * Deletes product types.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductTypeBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

export type ProductTypeConfigurable =
  | 'CONFIGURABLE'
  | 'SIMPLE';

export type ProductTypeCountableConnection = {
  readonly edges: ReadonlyArray<ProductTypeCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type ProductTypeCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: ProductType;
};

/**
 * Creates a new product type.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductTypeCreate = {
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  readonly productType?: Maybe<ProductType>;
};

/**
 * Deletes a product type.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductTypeDelete = {
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  readonly productType?: Maybe<ProductType>;
};

export type ProductTypeEnum =
  | 'DIGITAL'
  | 'SHIPPABLE';

export type ProductTypeFilterInput = {
  readonly configurable?: InputMaybe<ProductTypeConfigurable>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly kind?: InputMaybe<ProductTypeKindEnum>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly productType?: InputMaybe<ProductTypeEnum>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly slugs?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

export type ProductTypeInput = {
  /** Determines if product of this type has multiple variants. This option mainly simplifies product management in the dashboard. There is always at least one variant created under the hood. */
  readonly hasVariants?: InputMaybe<Scalars['Boolean']['input']>;
  /** Determines if products are digital. */
  readonly isDigital?: InputMaybe<Scalars['Boolean']['input']>;
  /** Determines if shipping is required for products of this variant. */
  readonly isShippingRequired?: InputMaybe<Scalars['Boolean']['input']>;
  /** The product type kind. */
  readonly kind?: InputMaybe<ProductTypeKindEnum>;
  /** Name of the product type. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** List of attributes shared among all product variants. */
  readonly productAttributes?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Product type slug. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
  /** ID of a tax class to assign to this product type. All products of this product type would use this tax class, unless it's overridden in the `Product` type. */
  readonly taxClass?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Tax rate for enabled tax gateway.
   * @deprecated Use tax classes to control the tax calculation for a product type. If taxCode is provided, Saleor will try to find a tax class with given code (codes are stored in metadata) and assign it. If no tax class is found, it would be created and assigned.
   */
  readonly taxCode?: InputMaybe<Scalars['String']['input']>;
  /** List of attributes used to distinguish between different variants of a product. */
  readonly variantAttributes?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Weight of the ProductType items. */
  readonly weight?: InputMaybe<Scalars['WeightScalar']['input']>;
};

export type ProductTypeKindEnum =
  | 'GIFT_CARD'
  | 'NORMAL';

/**
 * Reorder the attributes of a product type.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductTypeReorderAttributes = {
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  /** Product type from which attributes are reordered. */
  readonly productType?: Maybe<ProductType>;
};

export type ProductTypeSortField =
  /** Sort products by type. */
  | 'DIGITAL'
  /** Sort products by name. */
  | 'NAME'
  /** Sort products by shipping. */
  | 'SHIPPING_REQUIRED';

export type ProductTypeSortingInput = {
  /** Specifies the direction in which to sort product types. */
  readonly direction: OrderDirection;
  /** Sort product types by the selected field. */
  readonly field: ProductTypeSortField;
};

/**
 * Updates an existing product type.
 *
 * Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.
 */
export type ProductTypeUpdate = {
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  readonly productType?: Maybe<ProductType>;
};

/**
 * Updates an existing product.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductUpdate = {
  readonly errors: ReadonlyArray<ProductError>;
  readonly product?: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

/** Event sent when product is updated. */
export type ProductUpdated = Event & {
  /** The category of the product. */
  readonly category?: Maybe<Category>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The product the event relates to. */
  readonly product?: Maybe<Product>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when product is updated. */
export type ProductUpdatedProductArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/** Represents a version of a product such as different size or color. */
export type ProductVariant = Node & ObjectWithAttributes & ObjectWithMetadata & {
  /**
   * Get a single attribute attached to product by attribute slug.
   *
   * Added in Saleor 3.22.
   */
  readonly assignedAttribute?: Maybe<AssignedAttribute>;
  /**
   * List of attributes assigned to this variant.
   *
   * Added in Saleor 3.22.
   */
  readonly assignedAttributes: ReadonlyArray<AssignedAttribute>;
  /**
   * List of attributes assigned to this variant.
   * @deprecated Use the `assignedAttributes` field instead.
   */
  readonly attributes: ReadonlyArray<SelectedAttribute>;
  /** Channel given to retrieve this product variant. Also used by federation gateway to resolve this object in a federated query. */
  readonly channel?: Maybe<Scalars['String']['output']>;
  /**
   * List of price information in channels for the product.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  readonly channelListings?: Maybe<ReadonlyArray<ProductVariantChannelListing>>;
  /** The date and time when the product variant was created. */
  readonly created: Scalars['DateTime']['output'];
  /**
   * Digital content for the product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly digitalContent?: Maybe<DigitalContent>;
  /** External ID of this product. */
  readonly externalReference?: Maybe<Scalars['String']['output']>;
  /** The ID of the product variant. */
  readonly id: Scalars['ID']['output'];
  /**
   * List of images for the product variant.
   * @deprecated Use the `media` field instead.
   */
  readonly images?: Maybe<ReadonlyArray<ProductImage>>;
  /** Gross margin percentage value. */
  readonly margin?: Maybe<Scalars['Int']['output']>;
  /** List of media for the product variant. */
  readonly media?: Maybe<ReadonlyArray<ProductMedia>>;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** The name of the product variant. */
  readonly name: Scalars['String']['output'];
  /** Preorder data for product variant. */
  readonly preorder?: Maybe<PreorderData>;
  /** Lists the storefront variant's pricing, the current price and discounts, only meant for displaying. */
  readonly pricing?: Maybe<VariantPricingInfo>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** The product to which the variant belongs. */
  readonly product: Product;
  /** Quantity of a product available for sale in one checkout. Field value will be `null` when no `limitQuantityPerCheckout` in global settings has been set, and `productVariant` stocks are not tracked. */
  readonly quantityAvailable?: Maybe<Scalars['Int']['output']>;
  /** The maximum quantity of this variant that a customer can purchase. */
  readonly quantityLimitPerCustomer?: Maybe<Scalars['Int']['output']>;
  /**
   * Total quantity ordered.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly quantityOrdered?: Maybe<Scalars['Int']['output']>;
  /**
   * Total revenue generated by a variant in given period of time. Note: this field should be queried using `reportProductSales` query as it uses optimizations suitable for such calculations.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly revenue?: Maybe<TaxedMoney>;
  /** The SKU (stock keeping unit) of the product variant. */
  readonly sku?: Maybe<Scalars['String']['output']>;
  /**
   * Stocks for the product variant.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  readonly stocks?: Maybe<ReadonlyArray<Stock>>;
  /** Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item. If the field is not provided, `Shop.trackInventoryByDefault` will be used. */
  readonly trackInventory: Scalars['Boolean']['output'];
  /** Returns translated product variant fields for the given language code. */
  readonly translation?: Maybe<ProductVariantTranslation>;
  /** The date and time when the product variant was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The weight of the product variant. */
  readonly weight?: Maybe<Weight>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantAssignedAttributeArgs = {
  slug: Scalars['String']['input'];
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantAssignedAttributesArgs = {
  limit?: InputMaybe<Scalars['PositiveInt']['input']>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantAttributesArgs = {
  variantSelection?: InputMaybe<VariantAttributeScope>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantPricingArgs = {
  address?: InputMaybe<AddressInput>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantQuantityAvailableArgs = {
  address?: InputMaybe<AddressInput>;
  countryCode?: InputMaybe<CountryCode>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantRevenueArgs = {
  period?: InputMaybe<ReportingPeriod>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantStocksArgs = {
  address?: InputMaybe<AddressInput>;
  countryCode?: InputMaybe<CountryCode>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Event sent when product variant is back in stock. */
export type ProductVariantBackInStock = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The product variant the event relates to. */
  readonly productVariant?: Maybe<ProductVariant>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
  /** Look up a warehouse. */
  readonly warehouse?: Maybe<Warehouse>;
};


/** Event sent when product variant is back in stock. */
export type ProductVariantBackInStockProductVariantArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Creates product variants for a given product.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantBulkCreate = {
  /** @deprecated Use `errors` field instead. */
  readonly bulkProductErrors: ReadonlyArray<BulkProductError>;
  /** Returns how many objects were created. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<BulkProductError>;
  /** List of the created variants. */
  readonly productVariants: ReadonlyArray<ProductVariant>;
  /** List of the created variants. */
  readonly results: ReadonlyArray<ProductVariantBulkResult>;
};

export type ProductVariantBulkCreateInput = {
  /** List of attributes specific to this variant. */
  readonly attributes: ReadonlyArray<BulkAttributeValueInput>;
  /** List of prices assigned to channels. */
  readonly channelListings?: InputMaybe<ReadonlyArray<ProductVariantChannelListingAddInput>>;
  /** External ID of this product variant. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the product variant metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Variant name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Determines if variant is in preorder. */
  readonly preorder?: InputMaybe<PreorderSettingsInput>;
  /**
   * Fields required to update the product variant private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Determines maximum quantity of `ProductVariant`,that can be bought in a single checkout. */
  readonly quantityLimitPerCustomer?: InputMaybe<Scalars['Int']['input']>;
  /** Stock keeping unit. */
  readonly sku?: InputMaybe<Scalars['String']['input']>;
  /** Stocks of a product available for sale. */
  readonly stocks?: InputMaybe<ReadonlyArray<StockInput>>;
  /** Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item. If the field is not provided, `Shop.trackInventoryByDefault` will be used. */
  readonly trackInventory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Weight of the Product Variant. */
  readonly weight?: InputMaybe<Scalars['WeightScalar']['input']>;
};

/**
 * Deletes product variants.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

export type ProductVariantBulkError = {
  /** List of attributes IDs which causes the error. */
  readonly attributes?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** List of channel listings IDs which causes the error. */
  readonly channelListings?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** List of channel IDs which causes the error. */
  readonly channels?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error code. */
  readonly code: ProductVariantBulkErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly path?: Maybe<Scalars['String']['output']>;
  /** List of stocks IDs which causes the error. */
  readonly stocks?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** List of attribute values IDs which causes the error. */
  readonly values?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** List of warehouse IDs which causes the error. */
  readonly warehouses?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

export type ProductVariantBulkErrorCode =
  | 'ATTRIBUTE_ALREADY_ASSIGNED'
  | 'ATTRIBUTE_CANNOT_BE_ASSIGNED'
  | 'ATTRIBUTE_VARIANTS_DISABLED'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_PRICE'
  | 'NOT_FOUND'
  | 'NOT_PRODUCTS_VARIANT'
  | 'PRODUCT_NOT_ASSIGNED_TO_CHANNEL'
  | 'REQUIRED'
  | 'STOCK_ALREADY_EXISTS'
  | 'UNIQUE';

export type ProductVariantBulkResult = {
  /** List of errors occurred on create attempt. */
  readonly errors?: Maybe<ReadonlyArray<ProductVariantBulkError>>;
  /** Product variant data. */
  readonly productVariant?: Maybe<ProductVariant>;
};

/**
 * Creates/updates translations for product variants.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 *
 * Triggers the following webhook events:
 * - TRANSLATION_CREATED (async): A translation was created.
 * - TRANSLATION_UPDATED (async): A translation was updated.
 */
export type ProductVariantBulkTranslate = {
  /** Returns how many translations were created/updated. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<ProductVariantBulkTranslateError>;
  /** List of the translations. */
  readonly results: ReadonlyArray<ProductVariantBulkTranslateResult>;
};

export type ProductVariantBulkTranslateError = {
  /** The error code. */
  readonly code: ProductVariantTranslateErrorCode;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly path?: Maybe<Scalars['String']['output']>;
};

export type ProductVariantBulkTranslateInput = {
  /** External reference of a product variant. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** Product variant ID. */
  readonly id?: InputMaybe<Scalars['ID']['input']>;
  /** Translation language code. */
  readonly languageCode: LanguageCodeEnum;
  /** Translation fields. */
  readonly translationFields: NameTranslationInput;
};

export type ProductVariantBulkTranslateResult = {
  /** List of errors occurred on translation attempt. */
  readonly errors?: Maybe<ReadonlyArray<ProductVariantBulkTranslateError>>;
  /** Product variant translation data. */
  readonly translation?: Maybe<ProductVariantTranslation>;
};

/**
 * Updates multiple product variants.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantBulkUpdate = {
  /** Returns how many objects were updated. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<ProductVariantBulkError>;
  /** List of the updated variants. */
  readonly results: ReadonlyArray<ProductVariantBulkResult>;
};

/** Input fields to update product variants. */
export type ProductVariantBulkUpdateInput = {
  /** List of attributes specific to this variant. */
  readonly attributes?: InputMaybe<ReadonlyArray<BulkAttributeValueInput>>;
  /** Channel listings input. */
  readonly channelListings?: InputMaybe<ProductVariantChannelListingUpdateInput>;
  /** External ID of this product variant. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** ID of the product variant to update. */
  readonly id: Scalars['ID']['input'];
  /**
   * Fields required to update the product variant metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Variant name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Determines if variant is in preorder. */
  readonly preorder?: InputMaybe<PreorderSettingsInput>;
  /**
   * Fields required to update the product variant private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Determines maximum quantity of `ProductVariant`,that can be bought in a single checkout. */
  readonly quantityLimitPerCustomer?: InputMaybe<Scalars['Int']['input']>;
  /** Stock keeping unit. */
  readonly sku?: InputMaybe<Scalars['String']['input']>;
  /** Stocks input. */
  readonly stocks?: InputMaybe<ProductVariantStocksUpdateInput>;
  /** Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item. If the field is not provided, `Shop.trackInventoryByDefault` will be used. */
  readonly trackInventory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Weight of the Product Variant. */
  readonly weight?: InputMaybe<Scalars['WeightScalar']['input']>;
};

/** Represents product variant channel listing. */
export type ProductVariantChannelListing = Node & {
  /** The channel to which the variant listing belongs. */
  readonly channel: Channel;
  /** Cost price of the variant. */
  readonly costPrice?: Maybe<Money>;
  /** The ID of the variant channel listing. */
  readonly id: Scalars['ID']['output'];
  /**
   * Gross margin percentage value.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly margin?: Maybe<Scalars['Int']['output']>;
  /** Preorder variant data. */
  readonly preorderThreshold?: Maybe<PreorderThreshold>;
  /** The price of the variant. */
  readonly price?: Maybe<Money>;
  /**
   * Prior price of the variant used for discount calculations.
   *
   * Added in Saleor 3.21.
   */
  readonly priorPrice?: Maybe<Money>;
};

export type ProductVariantChannelListingAddInput = {
  /** ID of a channel. */
  readonly channelId: Scalars['ID']['input'];
  /** Cost price of the variant in channel. */
  readonly costPrice?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** The threshold for preorder variant in channel. */
  readonly preorderThreshold?: InputMaybe<Scalars['Int']['input']>;
  /** Price of the particular variant in channel. */
  readonly price: Scalars['PositiveDecimal']['input'];
  /**
   * Previous price of the variant in channel. Useful for providing promotion information required by customer protection laws such as EU Omnibus directive.
   *
   * Added in Saleor 3.21.
   */
  readonly priorPrice?: InputMaybe<Scalars['PositiveDecimal']['input']>;
};

/**
 * Manage product variant prices in channels.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantChannelListingUpdate = {
  readonly errors: ReadonlyArray<ProductChannelListingError>;
  /** @deprecated Use `errors` field instead. */
  readonly productChannelListingErrors: ReadonlyArray<ProductChannelListingError>;
  /** An updated product variant instance. */
  readonly variant?: Maybe<ProductVariant>;
};

export type ProductVariantChannelListingUpdateInput = {
  /** List of channels to create variant channel listings. */
  readonly create?: InputMaybe<ReadonlyArray<ProductVariantChannelListingAddInput>>;
  /** List of channel listings to remove. */
  readonly remove?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of channel listings to update. */
  readonly update?: InputMaybe<ReadonlyArray<ChannelListingUpdateInput>>;
};

export type ProductVariantCountableConnection = {
  readonly edges: ReadonlyArray<ProductVariantCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type ProductVariantCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: ProductVariant;
};

/**
 * Creates a new variant for a product.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantCreate = {
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  readonly productVariant?: Maybe<ProductVariant>;
};

export type ProductVariantCreateInput = {
  /** List of attributes specific to this variant. */
  readonly attributes: ReadonlyArray<AttributeValueInput>;
  /** External ID of this product variant. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the product variant metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Variant name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Determines if variant is in preorder. */
  readonly preorder?: InputMaybe<PreorderSettingsInput>;
  /**
   * Fields required to update the product variant private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Product ID of which type is the variant. */
  readonly product: Scalars['ID']['input'];
  /** Determines maximum quantity of `ProductVariant`,that can be bought in a single checkout. */
  readonly quantityLimitPerCustomer?: InputMaybe<Scalars['Int']['input']>;
  /** Stock keeping unit. */
  readonly sku?: InputMaybe<Scalars['String']['input']>;
  /** Stocks of a product available for sale. */
  readonly stocks?: InputMaybe<ReadonlyArray<StockInput>>;
  /** Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item. If the field is not provided, `Shop.trackInventoryByDefault` will be used. */
  readonly trackInventory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Weight of the Product Variant. */
  readonly weight?: InputMaybe<Scalars['WeightScalar']['input']>;
};

/** Event sent when new product variant is created. */
export type ProductVariantCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The product variant the event relates to. */
  readonly productVariant?: Maybe<ProductVariant>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when new product variant is created. */
export type ProductVariantCreatedProductVariantArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Deletes a product variant.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantDelete = {
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  readonly productVariant?: Maybe<ProductVariant>;
};

/** Event sent when product variant is deleted. */
export type ProductVariantDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The product variant the event relates to. */
  readonly productVariant?: Maybe<ProductVariant>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when product variant is deleted. */
export type ProductVariantDeletedProductVariantArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

export type ProductVariantFilterInput = {
  readonly isPreorder?: InputMaybe<Scalars['Boolean']['input']>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly sku?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly updatedAt?: InputMaybe<DateTimeRangeInput>;
};

export type ProductVariantInput = {
  /** List of attributes specific to this variant. */
  readonly attributes?: InputMaybe<ReadonlyArray<AttributeValueInput>>;
  /** External ID of this product variant. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the product variant metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Variant name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Determines if variant is in preorder. */
  readonly preorder?: InputMaybe<PreorderSettingsInput>;
  /**
   * Fields required to update the product variant private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Determines maximum quantity of `ProductVariant`,that can be bought in a single checkout. */
  readonly quantityLimitPerCustomer?: InputMaybe<Scalars['Int']['input']>;
  /** Stock keeping unit. */
  readonly sku?: InputMaybe<Scalars['String']['input']>;
  /** Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item. If the field is not provided, `Shop.trackInventoryByDefault` will be used. */
  readonly trackInventory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Weight of the Product Variant. */
  readonly weight?: InputMaybe<Scalars['WeightScalar']['input']>;
};

/** Event sent when product variant metadata is updated. */
export type ProductVariantMetadataUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The product variant the event relates to. */
  readonly productVariant?: Maybe<ProductVariant>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when product variant metadata is updated. */
export type ProductVariantMetadataUpdatedProductVariantArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when product variant is out of stock. */
export type ProductVariantOutOfStock = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The product variant the event relates to. */
  readonly productVariant?: Maybe<ProductVariant>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
  /** Look up a warehouse. */
  readonly warehouse?: Maybe<Warehouse>;
};


/** Event sent when product variant is out of stock. */
export type ProductVariantOutOfStockProductVariantArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Deactivates product variant preorder. It changes all preorder allocation into regular allocation.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantPreorderDeactivate = {
  readonly errors: ReadonlyArray<ProductError>;
  /** Product variant with ended preorder. */
  readonly productVariant?: Maybe<ProductVariant>;
};

/**
 * Reorder the variants of a product. Mutation updates updated_at on product and triggers PRODUCT_UPDATED webhook.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantReorder = {
  readonly errors: ReadonlyArray<ProductError>;
  readonly product?: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

/**
 * Reorder product variant attribute values.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantReorderAttributeValues = {
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  /** Product variant from which attribute values are reordered. */
  readonly productVariant?: Maybe<ProductVariant>;
};

/**
 * Set default variant for a product. Mutation triggers PRODUCT_UPDATED webhook.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantSetDefault = {
  readonly errors: ReadonlyArray<ProductError>;
  readonly product?: Maybe<Product>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
};

export type ProductVariantSortField =
  /** Sort product variants by last modification date. */
  | 'LAST_MODIFIED_AT';

export type ProductVariantSortingInput = {
  /** Specifies the direction in which to sort productVariants. */
  readonly direction: OrderDirection;
  /** Sort productVariants by the selected field. */
  readonly field: ProductVariantSortField;
};

/** Event sent when product variant stock is updated. */
export type ProductVariantStockUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The product variant the event relates to. */
  readonly productVariant?: Maybe<ProductVariant>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
  /** Look up a warehouse. */
  readonly warehouse?: Maybe<Warehouse>;
};


/** Event sent when product variant stock is updated. */
export type ProductVariantStockUpdatedProductVariantArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Creates stocks for product variant.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantStocksCreate = {
  /** @deprecated Use `errors` field instead. */
  readonly bulkStockErrors: ReadonlyArray<BulkStockError>;
  readonly errors: ReadonlyArray<BulkStockError>;
  /** Updated product variant. */
  readonly productVariant?: Maybe<ProductVariant>;
};

/**
 * Deletes stocks from product variant.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantStocksDelete = {
  readonly errors: ReadonlyArray<StockError>;
  /** Updated product variant. */
  readonly productVariant?: Maybe<ProductVariant>;
  /** @deprecated Use `errors` field instead. */
  readonly stockErrors: ReadonlyArray<StockError>;
};

/**
 * Updates stocks for product variant.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantStocksUpdate = {
  /** @deprecated Use `errors` field instead. */
  readonly bulkStockErrors: ReadonlyArray<BulkStockError>;
  readonly errors: ReadonlyArray<BulkStockError>;
  /** Updated product variant. */
  readonly productVariant?: Maybe<ProductVariant>;
};

export type ProductVariantStocksUpdateInput = {
  /** List of warehouses to create stocks. */
  readonly create?: InputMaybe<ReadonlyArray<StockInput>>;
  /** List of stocks to remove. */
  readonly remove?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of stocks to update. */
  readonly update?: InputMaybe<ReadonlyArray<StockUpdateInput>>;
};

/** Represents product variant's original translatable fields and related translations. */
export type ProductVariantTranslatableContent = Node & {
  /** List of product variant attribute values that can be translated. */
  readonly attributeValues: ReadonlyArray<AttributeValueTranslatableContent>;
  /** The ID of the product variant translatable content. */
  readonly id: Scalars['ID']['output'];
  /** Name of the product variant to translate. */
  readonly name: Scalars['String']['output'];
  /**
   * Represents a version of a product such as different size or color.
   * @deprecated Get model fields from the root level queries.
   */
  readonly productVariant?: Maybe<ProductVariant>;
  /** The ID of the product variant to translate. */
  readonly productVariantId: Scalars['ID']['output'];
  /** Returns translated product variant fields for the given language code. */
  readonly translation?: Maybe<ProductVariantTranslation>;
};


/** Represents product variant's original translatable fields and related translations. */
export type ProductVariantTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a product variant.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type ProductVariantTranslate = {
  readonly errors: ReadonlyArray<TranslationError>;
  readonly productVariant?: Maybe<ProductVariant>;
  /** @deprecated Use `errors` field instead. */
  readonly translationErrors: ReadonlyArray<TranslationError>;
};

export type ProductVariantTranslateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

/** Represents product variant translations. */
export type ProductVariantTranslation = Node & {
  /** The ID of the product variant translation. */
  readonly id: Scalars['ID']['output'];
  /** Translation language. */
  readonly language: LanguageDisplay;
  /** Translated product variant name. */
  readonly name: Scalars['String']['output'];
  /** Represents the product variant fields to translate. */
  readonly translatableContent?: Maybe<ProductVariantTranslatableContent>;
};

/**
 * Updates an existing variant for product.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type ProductVariantUpdate = {
  readonly errors: ReadonlyArray<ProductError>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  readonly productVariant?: Maybe<ProductVariant>;
};

/** Event sent when product variant is updated. */
export type ProductVariantUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The product variant the event relates to. */
  readonly productVariant?: Maybe<ProductVariant>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when product variant is updated. */
export type ProductVariantUpdatedProductVariantArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

export type ProductVariantWhereInput = {
  /** List of conditions that must be met. */
  readonly AND?: InputMaybe<ReadonlyArray<ProductVariantWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  readonly OR?: InputMaybe<ReadonlyArray<ProductVariantWhereInput>>;
  /**
   * Filter by attributes associated with the variant.
   *
   * Added in Saleor 3.22.
   */
  readonly attributes?: InputMaybe<ReadonlyArray<AssignedAttributeWhereInput>>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  /** Filter by product SKU. */
  readonly sku?: InputMaybe<StringFilterInput>;
  /** Filter by when was the most recent update. */
  readonly updatedAt?: InputMaybe<DateTimeRangeInput>;
};

export type ProductWhereInput = {
  /** List of conditions that must be met. */
  readonly AND?: InputMaybe<ReadonlyArray<ProductWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  readonly OR?: InputMaybe<ReadonlyArray<ProductWhereInput>>;
  /** Filter by attributes associated with the product. */
  readonly attributes?: InputMaybe<ReadonlyArray<AttributeInput>>;
  /** Filter by the date of availability for purchase. */
  readonly availableFrom?: InputMaybe<Scalars['DateTime']['input']>;
  /** Filter by product category. */
  readonly category?: InputMaybe<GlobalIdFilterInput>;
  /** Filter by collection. */
  readonly collection?: InputMaybe<GlobalIdFilterInput>;
  /** Filter on whether product is a gift card or not. */
  readonly giftCard?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by product with category assigned. */
  readonly hasCategory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by product with preordered variants. */
  readonly hasPreorderedVariants?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Filter by availability for purchase. */
  readonly isAvailable?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by public visibility. */
  readonly isPublished?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by visibility on the channel. */
  readonly isVisibleInListing?: InputMaybe<Scalars['Boolean']['input']>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  /** Filter by the lowest variant price after discounts. */
  readonly minimalPrice?: InputMaybe<DecimalFilterInput>;
  /** Filter by product name. */
  readonly name?: InputMaybe<StringFilterInput>;
  /** Filter by product variant price. */
  readonly price?: InputMaybe<DecimalFilterInput>;
  /** Filter by product type. */
  readonly productType?: InputMaybe<GlobalIdFilterInput>;
  /** Filter by the publication date. */
  readonly publishedFrom?: InputMaybe<Scalars['DateTime']['input']>;
  /** Filter by product slug. */
  readonly slug?: InputMaybe<StringFilterInput>;
  /** Filter by variants having specific stock status. */
  readonly stockAvailability?: InputMaybe<StockAvailability>;
  /** Filter by stock of the product variant. */
  readonly stocks?: InputMaybe<ProductStockFilterInput>;
  /** Filter by when was the most recent update. */
  readonly updatedAt?: InputMaybe<DateTimeFilterInput>;
};

/** Represents the promotion that allow creating discounts based on given conditions, and is visible to all the customers. */
export type Promotion = Node & ObjectWithMetadata & {
  /** Date time of promotion creation. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Description of the promotion. */
  readonly description?: Maybe<Scalars['JSON']['output']>;
  /** End date of the promotion. */
  readonly endDate?: Maybe<Scalars['DateTime']['output']>;
  /** The list of events associated with the promotion. */
  readonly events?: Maybe<ReadonlyArray<PromotionEvent>>;
  readonly id: Scalars['ID']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Name of the promotion. */
  readonly name: Scalars['String']['output'];
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** The list of promotion rules. */
  readonly rules?: Maybe<ReadonlyArray<PromotionRule>>;
  /** Start date of the promotion. */
  readonly startDate: Scalars['DateTime']['output'];
  /** Returns translated promotion fields for the given language code. */
  readonly translation?: Maybe<PromotionTranslation>;
  /**
   * The type of the promotion. Implicate if the discount is applied on catalogue or order level.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly type?: Maybe<PromotionTypeEnum>;
  /** Date time of last update of promotion. */
  readonly updatedAt: Scalars['DateTime']['output'];
};


/** Represents the promotion that allow creating discounts based on given conditions, and is visible to all the customers. */
export type PromotionMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents the promotion that allow creating discounts based on given conditions, and is visible to all the customers. */
export type PromotionMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents the promotion that allow creating discounts based on given conditions, and is visible to all the customers. */
export type PromotionPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents the promotion that allow creating discounts based on given conditions, and is visible to all the customers. */
export type PromotionPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents the promotion that allow creating discounts based on given conditions, and is visible to all the customers. */
export type PromotionTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Deletes promotions.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - PROMOTION_DELETED (async): A promotion was deleted.
 */
export type PromotionBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<DiscountError>;
};

export type PromotionCountableConnection = {
  readonly edges: ReadonlyArray<PromotionCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type PromotionCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Promotion;
};

/**
 * Creates a new promotion.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - PROMOTION_CREATED (async): A promotion was created.
 * - PROMOTION_STARTED (async): Optionally called if promotion was started.
 */
export type PromotionCreate = {
  readonly errors: ReadonlyArray<PromotionCreateError>;
  readonly promotion?: Maybe<Promotion>;
};

export type PromotionCreateError = {
  /** The error code. */
  readonly code: PromotionCreateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** Limit of gifts assigned to promotion rule. */
  readonly giftsLimit?: Maybe<Scalars['Int']['output']>;
  /** Number of gifts defined for this promotion rule exceeding the limit. */
  readonly giftsLimitExceedBy?: Maybe<Scalars['Int']['output']>;
  /** Index of an input list item that caused the error. */
  readonly index?: Maybe<Scalars['Int']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Limit of rules with orderPredicate defined. */
  readonly rulesLimit?: Maybe<Scalars['Int']['output']>;
  /** Number of rules with orderPredicate defined exceeding the limit. */
  readonly rulesLimitExceedBy?: Maybe<Scalars['Int']['output']>;
};

export type PromotionCreateErrorCode =
  | 'GIFTS_NUMBER_LIMIT'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_GIFT_TYPE'
  | 'INVALID_PRECISION'
  | 'MISSING_CHANNELS'
  | 'MULTIPLE_CURRENCIES_NOT_ALLOWED'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'RULES_NUMBER_LIMIT';

export type PromotionCreateInput = {
  /** Promotion description. */
  readonly description?: InputMaybe<Scalars['JSON']['input']>;
  /** The end date of the promotion in ISO 8601 format. */
  readonly endDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Promotion name. */
  readonly name: Scalars['String']['input'];
  /** List of promotion rules. */
  readonly rules?: InputMaybe<ReadonlyArray<PromotionRuleInput>>;
  /** The start date of the promotion in ISO 8601 format. */
  readonly startDate?: InputMaybe<Scalars['DateTime']['input']>;
  /**
   * Defines the promotion type. Implicate the required promotion rules predicate type and whether the promotion rules will give the catalogue or order discount.
   *
   * Added in Saleor 3.19.
   */
  readonly type: PromotionTypeEnum;
};

/** Event sent when new promotion is created. */
export type PromotionCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The promotion the event relates to. */
  readonly promotion?: Maybe<Promotion>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** History log of the promotion created event. */
export type PromotionCreatedEvent = Node & PromotionEventInterface & {
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  readonly createdBy?: Maybe<UserOrApp>;
  /** Date when event happened. */
  readonly date: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Promotion event type. */
  readonly type: PromotionEventsEnum;
};

/**
 * Deletes a promotion.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - PROMOTION_DELETED (async): A promotion was deleted.
 */
export type PromotionDelete = {
  readonly errors: ReadonlyArray<PromotionDeleteError>;
  readonly promotion?: Maybe<Promotion>;
};

export type PromotionDeleteError = {
  /** The error code. */
  readonly code: PromotionDeleteErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type PromotionDeleteErrorCode =
  | 'GRAPHQL_ERROR'
  | 'NOT_FOUND';

/** Event sent when promotion is deleted. */
export type PromotionDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The promotion the event relates to. */
  readonly promotion?: Maybe<Promotion>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** The event informs about the end of the promotion. */
export type PromotionEnded = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The promotion the event relates to. */
  readonly promotion?: Maybe<Promotion>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** History log of the promotion ended event. */
export type PromotionEndedEvent = Node & PromotionEventInterface & {
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  readonly createdBy?: Maybe<UserOrApp>;
  /** Date when event happened. */
  readonly date: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Promotion event type. */
  readonly type: PromotionEventsEnum;
};

export type PromotionEvent = PromotionCreatedEvent | PromotionEndedEvent | PromotionRuleCreatedEvent | PromotionRuleDeletedEvent | PromotionRuleUpdatedEvent | PromotionStartedEvent | PromotionUpdatedEvent;

export type PromotionEventInterface = {
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  readonly createdBy?: Maybe<UserOrApp>;
  /** Date when event happened. */
  readonly date: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Promotion event type. */
  readonly type: PromotionEventsEnum;
};

export type PromotionEventsEnum =
  | 'PROMOTION_CREATED'
  | 'PROMOTION_ENDED'
  | 'PROMOTION_STARTED'
  | 'PROMOTION_UPDATED'
  | 'RULE_CREATED'
  | 'RULE_DELETED'
  | 'RULE_UPDATED';

/** Represents the promotion rule that specifies the conditions that must be met to apply the promotion discount. */
export type PromotionRule = Node & {
  /** The catalogue predicate that must be met to apply the rule reward. */
  readonly cataloguePredicate?: Maybe<Scalars['JSON']['output']>;
  /**
   * List of channels where the rule applies.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  readonly channels?: Maybe<ReadonlyArray<Channel>>;
  /** Description of the promotion rule. */
  readonly description?: Maybe<Scalars['JSON']['output']>;
  /**
   * Product variant IDs available as a gift to choose.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly giftIds?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /**
   * Defines the maximum number of gifts to choose from the gifts list.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly giftsLimit?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Name of the promotion rule. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /**
   * The checkout/order predicate that must be met to apply the rule reward.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderPredicate?: Maybe<Scalars['JSON']['output']>;
  /**
   * The type of the predicate that must be met to apply the reward.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly predicateType?: Maybe<PromotionTypeEnum>;
  /** Promotion to which the rule belongs. */
  readonly promotion?: Maybe<Promotion>;
  /**
   * The reward type of the promotion rule.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly rewardType?: Maybe<RewardTypeEnum>;
  /**
   * The reward value of the promotion rule. Defines the discount value applied when the rule conditions are met.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly rewardValue?: Maybe<Scalars['PositiveDecimal']['output']>;
  /** The type of reward value of the promotion rule. */
  readonly rewardValueType?: Maybe<RewardValueTypeEnum>;
  /** Returns translated promotion rule fields for the given language code. */
  readonly translation?: Maybe<PromotionRuleTranslation>;
};


/** Represents the promotion rule that specifies the conditions that must be met to apply the promotion discount. */
export type PromotionRuleTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates a new promotion rule.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - PROMOTION_RULE_CREATED (async): A promotion rule was created.
 */
export type PromotionRuleCreate = {
  readonly errors: ReadonlyArray<PromotionRuleCreateError>;
  readonly promotionRule?: Maybe<PromotionRule>;
};

export type PromotionRuleCreateError = {
  /** The error code. */
  readonly code: PromotionRuleCreateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** Limit of gifts assigned to promotion rule. */
  readonly giftsLimit?: Maybe<Scalars['Int']['output']>;
  /** Number of gifts defined for this promotion rule exceeding the limit. */
  readonly giftsLimitExceedBy?: Maybe<Scalars['Int']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Limit of rules with orderPredicate defined. */
  readonly rulesLimit?: Maybe<Scalars['Int']['output']>;
  /** Number of rules with orderPredicate defined exceeding the limit. */
  readonly rulesLimitExceedBy?: Maybe<Scalars['Int']['output']>;
};

export type PromotionRuleCreateErrorCode =
  | 'GIFTS_NUMBER_LIMIT'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_GIFT_TYPE'
  | 'INVALID_PRECISION'
  | 'MISSING_CHANNELS'
  | 'MULTIPLE_CURRENCIES_NOT_ALLOWED'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'RULES_NUMBER_LIMIT';

export type PromotionRuleCreateInput = {
  /** Defines the conditions on the catalogue level that must be met for the reward to be applied. */
  readonly cataloguePredicate?: InputMaybe<CataloguePredicateInput>;
  /** List of channel ids to which the rule should apply to. */
  readonly channels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Promotion rule description. */
  readonly description?: InputMaybe<Scalars['JSON']['input']>;
  /**
   * Product variant IDs available as a gift to choose.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly gifts?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Promotion rule name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Defines the conditions on the checkout/draft order level that must be met for the reward to be applied.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderPredicate?: InputMaybe<OrderPredicateInput>;
  /** The ID of the promotion that rule belongs to. */
  readonly promotion: Scalars['ID']['input'];
  /**
   * Defines the reward type of the promotion rule.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly rewardType?: InputMaybe<RewardTypeEnum>;
  /** Defines the discount value. Required when catalogue predicate is provided. */
  readonly rewardValue?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** Defines the promotion rule reward value type. Must be provided together with reward value. */
  readonly rewardValueType?: InputMaybe<RewardValueTypeEnum>;
};

/** Event sent when new promotion rule is created. */
export type PromotionRuleCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The promotion rule the event relates to. */
  readonly promotionRule?: Maybe<PromotionRule>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** History log of the promotion rule created event. */
export type PromotionRuleCreatedEvent = Node & PromotionEventInterface & PromotionRuleEventInterface & {
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  readonly createdBy?: Maybe<UserOrApp>;
  /** Date when event happened. */
  readonly date: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The rule ID associated with the promotion event. */
  readonly ruleId?: Maybe<Scalars['String']['output']>;
  /** Promotion event type. */
  readonly type: PromotionEventsEnum;
};

/**
 * Deletes a promotion rule.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - PROMOTION_RULE_DELETED (async): A promotion rule was deleted.
 */
export type PromotionRuleDelete = {
  readonly errors: ReadonlyArray<PromotionRuleDeleteError>;
  readonly promotionRule?: Maybe<PromotionRule>;
};

export type PromotionRuleDeleteError = {
  /** The error code. */
  readonly code: PromotionRuleDeleteErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type PromotionRuleDeleteErrorCode =
  | 'GRAPHQL_ERROR'
  | 'NOT_FOUND';

/** Event sent when new promotion rule is deleted. */
export type PromotionRuleDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The promotion rule the event relates to. */
  readonly promotionRule?: Maybe<PromotionRule>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** History log of the promotion rule created event. */
export type PromotionRuleDeletedEvent = Node & PromotionEventInterface & PromotionRuleEventInterface & {
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  readonly createdBy?: Maybe<UserOrApp>;
  /** Date when event happened. */
  readonly date: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The rule ID associated with the promotion event. */
  readonly ruleId?: Maybe<Scalars['String']['output']>;
  /** Promotion event type. */
  readonly type: PromotionEventsEnum;
};

/** History log of the promotion event related to rule. */
export type PromotionRuleEventInterface = {
  /** The rule ID associated with the promotion event. */
  readonly ruleId?: Maybe<Scalars['String']['output']>;
};

export type PromotionRuleInput = {
  /** Defines the conditions on the catalogue level that must be met for the reward to be applied. */
  readonly cataloguePredicate?: InputMaybe<CataloguePredicateInput>;
  /** List of channel ids to which the rule should apply to. */
  readonly channels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Promotion rule description. */
  readonly description?: InputMaybe<Scalars['JSON']['input']>;
  /**
   * Product variant IDs available as a gift to choose.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly gifts?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Promotion rule name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Defines the conditions on the checkout/draft order level that must be met for the reward to be applied.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderPredicate?: InputMaybe<OrderPredicateInput>;
  /**
   * Defines the reward type of the promotion rule.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly rewardType?: InputMaybe<RewardTypeEnum>;
  /** Defines the discount value. Required when catalogue predicate is provided. */
  readonly rewardValue?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** Defines the promotion rule reward value type. Must be provided together with reward value. */
  readonly rewardValueType?: InputMaybe<RewardValueTypeEnum>;
};

/** Represents promotion rule's original translatable fields and related translations. */
export type PromotionRuleTranslatableContent = Node & {
  /**
   * Description of the promotion rule.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /** ID of the promotion rule translatable content. */
  readonly id: Scalars['ID']['output'];
  /** Name of the promotion rule. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** ID of the promotion rule to translate. */
  readonly promotionRuleId: Scalars['ID']['output'];
  /** Returns translated promotion rule fields for the given language code. */
  readonly translation?: Maybe<PromotionRuleTranslation>;
};


/** Represents promotion rule's original translatable fields and related translations. */
export type PromotionRuleTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a promotion rule.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type PromotionRuleTranslate = {
  readonly errors: ReadonlyArray<TranslationError>;
  readonly promotionRule?: Maybe<PromotionRule>;
};

/** Represents promotion rule translations. */
export type PromotionRuleTranslation = Node & {
  /**
   * Translated description of the promotion rule.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /** ID of the promotion rule translation. */
  readonly id: Scalars['ID']['output'];
  /** Translation language. */
  readonly language: LanguageDisplay;
  /** Translated name of the promotion rule. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Represents the promotion rule fields to translate. */
  readonly translatableContent?: Maybe<PromotionRuleTranslatableContent>;
};

export type PromotionRuleTranslationInput = {
  /**
   * Translated promotion description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: InputMaybe<Scalars['JSON']['input']>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Updates an existing promotion rule.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - PROMOTION_RULE_UPDATED (async): A promotion rule was updated.
 */
export type PromotionRuleUpdate = {
  readonly errors: ReadonlyArray<PromotionRuleUpdateError>;
  readonly promotionRule?: Maybe<PromotionRule>;
};

export type PromotionRuleUpdateError = {
  /** List of channel IDs which causes the error. */
  readonly channels?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error code. */
  readonly code: PromotionRuleUpdateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** Limit of gifts assigned to promotion rule. */
  readonly giftsLimit?: Maybe<Scalars['Int']['output']>;
  /** Number of gifts defined for this promotion rule exceeding the limit. */
  readonly giftsLimitExceedBy?: Maybe<Scalars['Int']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type PromotionRuleUpdateErrorCode =
  | 'DUPLICATED_INPUT_ITEM'
  | 'GIFTS_NUMBER_LIMIT'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_GIFT_TYPE'
  | 'INVALID_PRECISION'
  | 'MISSING_CHANNELS'
  | 'MULTIPLE_CURRENCIES_NOT_ALLOWED'
  | 'NOT_FOUND'
  | 'REQUIRED';

export type PromotionRuleUpdateInput = {
  /** List of channel ids to add. */
  readonly addChannels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /**
   * List of variant IDs available as a gift to add.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly addGifts?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Defines the conditions on the catalogue level that must be met for the reward to be applied. */
  readonly cataloguePredicate?: InputMaybe<CataloguePredicateInput>;
  /** Promotion rule description. */
  readonly description?: InputMaybe<Scalars['JSON']['input']>;
  /** Promotion rule name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Defines the conditions on the checkout/draft order level that must be met for the reward to be applied.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderPredicate?: InputMaybe<OrderPredicateInput>;
  /** List of channel ids to remove. */
  readonly removeChannels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /**
   * List of variant IDs available as a gift to remove.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly removeGifts?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /**
   * Defines the reward type of the promotion rule.
   *
   * Added in Saleor 3.19.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly rewardType?: InputMaybe<RewardTypeEnum>;
  /** Defines the discount value. Required when catalogue predicate is provided. */
  readonly rewardValue?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** Defines the promotion rule reward value type. Must be provided together with reward value. */
  readonly rewardValueType?: InputMaybe<RewardValueTypeEnum>;
};

/** Event sent when new promotion rule is updated. */
export type PromotionRuleUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The promotion rule the event relates to. */
  readonly promotionRule?: Maybe<PromotionRule>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** History log of the promotion rule created event. */
export type PromotionRuleUpdatedEvent = Node & PromotionEventInterface & PromotionRuleEventInterface & {
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  readonly createdBy?: Maybe<UserOrApp>;
  /** Date when event happened. */
  readonly date: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The rule ID associated with the promotion event. */
  readonly ruleId?: Maybe<Scalars['String']['output']>;
  /** Promotion event type. */
  readonly type: PromotionEventsEnum;
};

export type PromotionSortField =
  /** Sort promotions by creation date. */
  | 'CREATED_AT'
  /** Sort promotions by end date. */
  | 'END_DATE'
  /** Sort promotions by name. */
  | 'NAME'
  /** Sort promotions by start date. */
  | 'START_DATE';

export type PromotionSortingInput = {
  /** Specifies the direction in which to sort promotions. */
  readonly direction: OrderDirection;
  /** Sort promotions by the selected field. */
  readonly field: PromotionSortField;
};

/** The event informs about the start of the promotion. */
export type PromotionStarted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The promotion the event relates to. */
  readonly promotion?: Maybe<Promotion>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** History log of the promotion started event. */
export type PromotionStartedEvent = Node & PromotionEventInterface & {
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  readonly createdBy?: Maybe<UserOrApp>;
  /** Date when event happened. */
  readonly date: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Promotion event type. */
  readonly type: PromotionEventsEnum;
};

/** Represents promotion's original translatable fields and related translations. */
export type PromotionTranslatableContent = Node & {
  /**
   * Description of the promotion.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /** ID of the promotion translatable content. */
  readonly id: Scalars['ID']['output'];
  /** Name of the promotion. */
  readonly name: Scalars['String']['output'];
  /** ID of the promotion to translate. */
  readonly promotionId: Scalars['ID']['output'];
  /** Returns translated promotion fields for the given language code. */
  readonly translation?: Maybe<PromotionTranslation>;
};


/** Represents promotion's original translatable fields and related translations. */
export type PromotionTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a promotion.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type PromotionTranslate = {
  readonly errors: ReadonlyArray<TranslationError>;
  readonly promotion?: Maybe<Promotion>;
};

/** Represents promotion translations. */
export type PromotionTranslation = Node & {
  /**
   * Translated description of the promotion.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /** ID of the promotion translation. */
  readonly id: Scalars['ID']['output'];
  /** Translation language. */
  readonly language: LanguageDisplay;
  /** Translated name of the promotion. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Represents the promotion fields to translate. */
  readonly translatableContent?: Maybe<PromotionTranslatableContent>;
};

export type PromotionTranslationInput = {
  /**
   * Translated promotion description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: InputMaybe<Scalars['JSON']['input']>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
};

export type PromotionTypeEnum =
  | 'CATALOGUE'
  | 'ORDER';

export type PromotionTypeEnumFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<PromotionTypeEnum>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<PromotionTypeEnum>>;
};

/**
 * Updates an existing promotion.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - PROMOTION_UPDATED (async): A promotion was updated.
 * - PROMOTION_STARTED (async): Optionally called if promotion was started.
 * - PROMOTION_ENDED (async): Optionally called if promotion was ended.
 */
export type PromotionUpdate = {
  readonly errors: ReadonlyArray<PromotionUpdateError>;
  readonly promotion?: Maybe<Promotion>;
};

export type PromotionUpdateError = {
  /** The error code. */
  readonly code: PromotionUpdateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type PromotionUpdateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

export type PromotionUpdateInput = {
  /** Promotion description. */
  readonly description?: InputMaybe<Scalars['JSON']['input']>;
  /** The end date of the promotion in ISO 8601 format. */
  readonly endDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Promotion name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** The start date of the promotion in ISO 8601 format. */
  readonly startDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Event sent when promotion is updated. */
export type PromotionUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The promotion the event relates to. */
  readonly promotion?: Maybe<Promotion>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** History log of the promotion updated event. */
export type PromotionUpdatedEvent = Node & PromotionEventInterface & {
  /**
   * User or App that created the promotion event.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_APPS, OWNER.
   */
  readonly createdBy?: Maybe<UserOrApp>;
  /** Date when event happened. */
  readonly date: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Promotion event type. */
  readonly type: PromotionEventsEnum;
};

export type PromotionWhereInput = {
  /** List of conditions that must be met. */
  readonly AND?: InputMaybe<ReadonlyArray<PromotionWhereInput>>;
  /** A list of conditions of which at least one must be met. */
  readonly OR?: InputMaybe<ReadonlyArray<PromotionWhereInput>>;
  /** Filter promotions by end date. */
  readonly endDate?: InputMaybe<DateTimeFilterInput>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly isOldSale?: InputMaybe<Scalars['Boolean']['input']>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  /** Filter by promotion name. */
  readonly name?: InputMaybe<StringFilterInput>;
  /** Filter promotions by start date. */
  readonly startDate?: InputMaybe<DateTimeFilterInput>;
  readonly type?: InputMaybe<PromotionTypeEnumFilterInput>;
};

export type PublishableChannelListingInput = {
  /** ID of a channel. */
  readonly channelId: Scalars['ID']['input'];
  /** Determines if object is visible to customers. */
  readonly isPublished?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Publication date. ISO 8601 standard.
   * @deprecated Use `publishedAt` field instead.
   */
  readonly publicationDate?: InputMaybe<Scalars['Date']['input']>;
  /** Publication date time. ISO 8601 standard. */
  readonly publishedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type Query = {
  readonly _entities?: Maybe<ReadonlyArray<Maybe<_Entity>>>;
  readonly _service?: Maybe<_Service>;
  /**
   * Look up an address by ID.
   *
   * Requires one of the following permissions: MANAGE_USERS, OWNER.
   */
  readonly address?: Maybe<Address>;
  /** Returns address validation rules. */
  readonly addressValidationRules?: Maybe<AddressValidationData>;
  /**
   * Look up an app by ID. If ID is not provided, return the currently authenticated app.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER AUTHENTICATED_APP. The authenticated app has access to its resources. Fetching different apps requires MANAGE_APPS permission.
   */
  readonly app?: Maybe<App>;
  /**
   * Look up an app extension by ID.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly appExtension?: Maybe<AppExtension>;
  /**
   * List of all extensions.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly appExtensions?: Maybe<AppExtensionCountableConnection>;
  /**
   * List of the apps.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, MANAGE_APPS.
   */
  readonly apps?: Maybe<AppCountableConnection>;
  /**
   * List of all apps installations
   *
   * Requires one of the following permissions: MANAGE_APPS.
   */
  readonly appsInstallations: ReadonlyArray<AppInstallation>;
  /** Look up an attribute by ID, slug or external reference. */
  readonly attribute?: Maybe<Attribute>;
  /** List of the shop's attributes. */
  readonly attributes?: Maybe<AttributeCountableConnection>;
  /** List of the shop's categories. */
  readonly categories?: Maybe<CategoryCountableConnection>;
  /** Look up a category by ID or slug. */
  readonly category?: Maybe<Category>;
  /** Look up a channel by ID or slug. */
  readonly channel?: Maybe<Channel>;
  /**
   * List of all channels.
   *
   * Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER.
   */
  readonly channels?: Maybe<ReadonlyArray<Channel>>;
  /**
   * Look up a checkout by id.
   *
   * Requires one of the following permissions to query a checkout, if a checkout is in inactive channel: MANAGE_CHECKOUTS, IMPERSONATE_USER, HANDLE_PAYMENTS.
   */
  readonly checkout?: Maybe<Checkout>;
  /**
   * List of checkout lines. The query will not initiate any external requests, including fetching external shipping methods, filtering available shipping methods, or performing external tax calculations.
   *
   * Requires one of the following permissions: MANAGE_CHECKOUTS.
   */
  readonly checkoutLines?: Maybe<CheckoutLineCountableConnection>;
  /**
   * List of checkouts. The query will not initiate any external requests, including fetching external shipping methods, filtering available shipping methods, or performing external tax calculations.
   *
   * Requires one of the following permissions: MANAGE_CHECKOUTS, HANDLE_PAYMENTS.
   */
  readonly checkouts?: Maybe<CheckoutCountableConnection>;
  /** Look up a collection by ID or slug. If slugLanguageCode is provided, category will be fetched by slug translation. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  readonly collection?: Maybe<Collection>;
  /** List of the shop's collections. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  readonly collections?: Maybe<CollectionCountableConnection>;
  /**
   * List of the shop's customers. This list includes all users who registered through the accountRegister mutation. Additionally, staff users who have placed an order using their account will also appear in this list.
   *
   * Requires one of the following permissions: MANAGE_ORDERS, MANAGE_USERS.
   */
  readonly customers?: Maybe<UserCountableConnection>;
  /**
   * Look up digital content by ID.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly digitalContent?: Maybe<DigitalContent>;
  /**
   * List of digital content.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly digitalContents?: Maybe<DigitalContentCountableConnection>;
  /**
   * List of draft orders. The query will not initiate any external requests, including filtering available shipping methods, or performing external tax calculations.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly draftOrders?: Maybe<OrderCountableConnection>;
  /**
   * Look up a export file by ID.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly exportFile?: Maybe<ExportFile>;
  /**
   * List of export files.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly exportFiles?: Maybe<ExportFileCountableConnection>;
  /**
   * Look up a gift card by ID.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  readonly giftCard?: Maybe<GiftCard>;
  /**
   * List of gift card currencies.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  readonly giftCardCurrencies: ReadonlyArray<Scalars['String']['output']>;
  /**
   * Gift card related settings from site settings.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  readonly giftCardSettings: GiftCardSettings;
  /**
   * List of gift card tags.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  readonly giftCardTags?: Maybe<GiftCardTagCountableConnection>;
  /**
   * List of gift cards.
   *
   * Requires one of the following permissions: MANAGE_GIFT_CARD.
   */
  readonly giftCards?: Maybe<GiftCardCountableConnection>;
  /**
   * List of activity events to display on homepage (at the moment it only contains order-events).
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   * @deprecated Field no longer supported
   */
  readonly homepageEvents?: Maybe<OrderEventCountableConnection>;
  /** Return the currently authenticated user. */
  readonly me?: Maybe<User>;
  /** Look up a navigation menu by ID or name. */
  readonly menu?: Maybe<Menu>;
  /** Look up a menu item by ID. */
  readonly menuItem?: Maybe<MenuItem>;
  /** List of the storefronts's menu items. */
  readonly menuItems?: Maybe<MenuItemCountableConnection>;
  /** List of the storefront's menus. */
  readonly menus?: Maybe<MenuCountableConnection>;
  /** Look up an order by ID or external reference. */
  readonly order?: Maybe<Order>;
  /**
   * Look up an order by token.
   * @deprecated Field no longer supported
   */
  readonly orderByToken?: Maybe<Order>;
  /**
   * Order related settings from site settings. Returns `orderSettings` for the first `channel` in alphabetical order.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   * @deprecated Use the `channel` query to fetch the `orderSettings` field instead.
   */
  readonly orderSettings?: Maybe<OrderSettings>;
  /**
   * List of orders. The query will not initiate any external requests, including filtering available shipping methods, or performing external tax calculations.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly orders?: Maybe<OrderCountableConnection>;
  /**
   * Return the total sales amount from a specific period.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   * @deprecated Field no longer supported
   */
  readonly ordersTotal?: Maybe<TaxedMoney>;
  /** Look up a page by ID or slug. */
  readonly page?: Maybe<Page>;
  /** Look up a page type by ID. */
  readonly pageType?: Maybe<PageType>;
  /** List of the page types. */
  readonly pageTypes?: Maybe<PageTypeCountableConnection>;
  /** List of the shop's pages. */
  readonly pages?: Maybe<PageCountableConnection>;
  /**
   * Look up a payment by ID.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly payment?: Maybe<Payment>;
  /**
   * List of payments.
   *
   * Requires one of the following permissions: MANAGE_ORDERS.
   */
  readonly payments?: Maybe<PaymentCountableConnection>;
  /**
   * Look up permission group by ID.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   */
  readonly permissionGroup?: Maybe<Group>;
  /**
   * List of permission groups.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   */
  readonly permissionGroups?: Maybe<GroupCountableConnection>;
  /**
   * Look up a plugin by ID.
   *
   * Requires one of the following permissions: MANAGE_PLUGINS.
   */
  readonly plugin?: Maybe<Plugin>;
  /**
   * List of plugins.
   *
   * Requires one of the following permissions: MANAGE_PLUGINS.
   */
  readonly plugins?: Maybe<PluginCountableConnection>;
  /** Look up a product by ID. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  readonly product?: Maybe<Product>;
  /** Look up a product type by ID. */
  readonly productType?: Maybe<ProductType>;
  /** List of the shop's product types. */
  readonly productTypes?: Maybe<ProductTypeCountableConnection>;
  /** Look up a product variant by ID or SKU. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  readonly productVariant?: Maybe<ProductVariant>;
  /** List of product variants. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  readonly productVariants?: Maybe<ProductVariantCountableConnection>;
  /** List of the shop's products. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  readonly products?: Maybe<ProductCountableConnection>;
  /**
   * Look up a promotion by ID.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  readonly promotion?: Maybe<Promotion>;
  /**
   * List of the promotions.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  readonly promotions?: Maybe<PromotionCountableConnection>;
  /** Refunds related settings. Returns `RefundSettings` configuration, global for the entire shop. */
  readonly refundSettings: RefundSettings;
  /**
   * List of top selling products.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   * @deprecated Field no longer supported
   */
  readonly reportProductSales?: Maybe<ProductVariantCountableConnection>;
  /**
   * Look up a sale by ID.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   * @deprecated Use the `promotion` query instead.
   */
  readonly sale?: Maybe<Sale>;
  /**
   * List of the shop's sales.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   * @deprecated Use the `promotions` query instead.
   */
  readonly sales?: Maybe<SaleCountableConnection>;
  /**
   * Look up a shipping zone by ID.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly shippingZone?: Maybe<ShippingZone>;
  /**
   * List of the shop's shipping zones.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly shippingZones?: Maybe<ShippingZoneCountableConnection>;
  /** Return information about the shop. */
  readonly shop: Shop;
  /**
   * List of the shop's staff users.
   *
   * Requires one of the following permissions: MANAGE_STAFF.
   */
  readonly staffUsers?: Maybe<UserCountableConnection>;
  /**
   * Look up a stock by ID
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly stock?: Maybe<Stock>;
  /**
   * List of stocks.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS.
   */
  readonly stocks?: Maybe<StockCountableConnection>;
  /**
   * Look up a tax class.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly taxClass?: Maybe<TaxClass>;
  /**
   * List of tax classes.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly taxClasses?: Maybe<TaxClassCountableConnection>;
  /**
   * Look up a tax configuration.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly taxConfiguration?: Maybe<TaxConfiguration>;
  /**
   * List of tax configurations.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly taxConfigurations?: Maybe<TaxConfigurationCountableConnection>;
  /**
   * Tax class rates grouped by country.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly taxCountryConfiguration?: Maybe<TaxCountryConfiguration>;
  /** \n\nRequires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP. */
  readonly taxCountryConfigurations?: Maybe<ReadonlyArray<TaxCountryConfiguration>>;
  /**
   * List of all tax rates available from tax gateway.
   * @deprecated Use `taxClasses` field instead.
   */
  readonly taxTypes?: Maybe<ReadonlyArray<TaxType>>;
  /**
   * Look up a transaction by ID.
   *
   * Requires one of the following permissions: HANDLE_PAYMENTS.
   */
  readonly transaction?: Maybe<TransactionItem>;
  /**
   * Lookup a translatable item by ID.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly translation?: Maybe<TranslatableItem>;
  /**
   * Returns a list of all translatable items of a given kind.
   *
   * Requires one of the following permissions: MANAGE_TRANSLATIONS.
   */
  readonly translations?: Maybe<TranslatableItemConnection>;
  /**
   * Look up a user by ID or email address.
   *
   * Requires one of the following permissions: MANAGE_STAFF, MANAGE_USERS, MANAGE_ORDERS.
   */
  readonly user?: Maybe<User>;
  /**
   * Look up a voucher by ID.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  readonly voucher?: Maybe<Voucher>;
  /**
   * List of the shop's vouchers.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  readonly vouchers?: Maybe<VoucherCountableConnection>;
  /**
   * Look up a warehouse by ID.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS, MANAGE_SHIPPING.
   */
  readonly warehouse?: Maybe<Warehouse>;
  /**
   * List of warehouses.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS, MANAGE_SHIPPING.
   */
  readonly warehouses?: Maybe<WarehouseCountableConnection>;
  /** Look up a webhook by ID. Requires one of the following permissions: MANAGE_APPS, OWNER. */
  readonly webhook?: Maybe<Webhook>;
  /**
   * List of all available webhook events.
   *
   * Requires one of the following permissions: MANAGE_APPS.
   * @deprecated Use `WebhookEventTypeAsyncEnum` and `WebhookEventTypeSyncEnum` to get available event types.
   */
  readonly webhookEvents?: Maybe<ReadonlyArray<WebhookEvent>>;
  /** Retrieve a sample payload for a given webhook event based on real data. It can be useful for some integrations where sample payload is required. */
  readonly webhookSamplePayload?: Maybe<Scalars['JSONString']['output']>;
};


export type Query_EntitiesArgs = {
  representations?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['_Any']['input']>>>;
};


export type QueryAddressArgs = {
  id: Scalars['ID']['input'];
};


export type QueryAddressValidationRulesArgs = {
  city?: InputMaybe<Scalars['String']['input']>;
  cityArea?: InputMaybe<Scalars['String']['input']>;
  countryArea?: InputMaybe<Scalars['String']['input']>;
  countryCode: CountryCode;
};


export type QueryAppArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryAppExtensionArgs = {
  id: Scalars['ID']['input'];
};


export type QueryAppExtensionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AppExtensionFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryAppsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AppFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<AppSortingInput>;
};


export type QueryAttributeArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAttributesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AttributeFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<AttributeSortingInput>;
  where?: InputMaybe<AttributeWhereInput>;
};


export type QueryCategoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<CategoryFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<CategorySortingInput>;
  where?: InputMaybe<CategoryWhereInput>;
};


export type QueryCategoryArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
  slugLanguageCode?: InputMaybe<LanguageCodeEnum>;
};


export type QueryChannelArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCheckoutArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type QueryCheckoutLinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryCheckoutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<CheckoutFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<CheckoutSortingInput>;
};


export type QueryCollectionArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
  slugLanguageCode?: InputMaybe<LanguageCodeEnum>;
};


export type QueryCollectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<CollectionFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<CollectionSortingInput>;
  where?: InputMaybe<CollectionWhereInput>;
};


export type QueryCustomersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<CustomerFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<UserSortingInput>;
  where?: InputMaybe<CustomerWhereInput>;
};


export type QueryDigitalContentArgs = {
  id: Scalars['ID']['input'];
};


export type QueryDigitalContentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryDraftOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<OrderDraftFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<OrderSortingInput>;
  where?: InputMaybe<DraftOrderWhereInput>;
};


export type QueryExportFileArgs = {
  id: Scalars['ID']['input'];
};


export type QueryExportFilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ExportFileFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<ExportFileSortingInput>;
};


export type QueryGiftCardArgs = {
  id: Scalars['ID']['input'];
};


export type QueryGiftCardTagsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<GiftCardTagFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryGiftCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<GiftCardFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<GiftCardSortingInput>;
};


export type QueryHomepageEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryMenuArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};


export type QueryMenuItemArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};


export type QueryMenuItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<MenuItemFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<MenuItemSortingInput>;
};


export type QueryMenusArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<MenuFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<MenuSortingInput>;
};


export type QueryOrderArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryOrderByTokenArgs = {
  token: Scalars['UUID']['input'];
};


export type QueryOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<OrderFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<OrderSortingInput>;
  where?: InputMaybe<OrderWhereInput>;
};


export type QueryOrdersTotalArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  period?: InputMaybe<ReportingPeriod>;
};


export type QueryPageArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
  slugLanguageCode?: InputMaybe<LanguageCodeEnum>;
};


export type QueryPageTypeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPageTypesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PageTypeFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<PageTypeSortingInput>;
};


export type QueryPagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PageFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<PageSortingInput>;
  where?: InputMaybe<PageWhereInput>;
};


export type QueryPaymentArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPaymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PaymentFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryPermissionGroupArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPermissionGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PermissionGroupFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<PermissionGroupSortingInput>;
};


export type QueryPluginArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPluginsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PluginFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<PluginSortingInput>;
};


export type QueryProductArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
  slugLanguageCode?: InputMaybe<LanguageCodeEnum>;
};


export type QueryProductTypeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryProductTypesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ProductTypeFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<ProductTypeSortingInput>;
};


export type QueryProductVariantArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
};


export type QueryProductVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ProductVariantFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<ProductVariantSortingInput>;
  where?: InputMaybe<ProductVariantWhereInput>;
};


export type QueryProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ProductFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<ProductOrder>;
  where?: InputMaybe<ProductWhereInput>;
};


export type QueryPromotionArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPromotionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<PromotionSortingInput>;
  where?: InputMaybe<PromotionWhereInput>;
};


export type QueryReportProductSalesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  period: ReportingPeriod;
};


export type QuerySaleArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};


export type QuerySalesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<SaleFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<SaleSortingInput>;
};


export type QueryShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};


export type QueryShippingZonesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ShippingZoneFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryStaffUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<StaffUserInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<UserSortingInput>;
};


export type QueryStockArgs = {
  id: Scalars['ID']['input'];
};


export type QueryStocksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<StockFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryTaxClassArgs = {
  id: Scalars['ID']['input'];
};


export type QueryTaxClassesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<TaxClassFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<TaxClassSortingInput>;
};


export type QueryTaxConfigurationArgs = {
  id: Scalars['ID']['input'];
};


export type QueryTaxConfigurationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<TaxConfigurationFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryTaxCountryConfigurationArgs = {
  countryCode: CountryCode;
};


export type QueryTransactionArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['UUID']['input']>;
};


export type QueryTranslationArgs = {
  id: Scalars['ID']['input'];
  kind: TranslatableKinds;
};


export type QueryTranslationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  kind: TranslatableKinds;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryUserArgs = {
  email?: InputMaybe<Scalars['String']['input']>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryVoucherArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};


export type QueryVouchersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<VoucherFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<VoucherSortingInput>;
};


export type QueryWarehouseArgs = {
  externalReference?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryWarehousesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<WarehouseFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<WarehouseSortingInput>;
};


export type QueryWebhookArgs = {
  id: Scalars['ID']['input'];
};


export type QueryWebhookSamplePayloadArgs = {
  eventType: WebhookSampleEventTypeEnum;
};

/** Represents a reduced VAT rate for a particular type of goods. */
export type ReducedRate = {
  /** Reduced VAT rate in percent. */
  readonly rate: Scalars['Float']['output'];
  /** A type of goods. */
  readonly rateType: Scalars['String']['output'];
};

/**
 * The reference types (product or page type) that are used to narrow down the choices of reference objects.
 * ProductType applicable for reference attribute with `PRODUCT` or `PRODUCT_VARIANT` entity type.
 * PageType applicable for reference attribute with `PAGE` entity type.
 */
export type ReferenceType = PageType | ProductType;

/** Refresh JWT token. Mutation tries to take refreshToken from the input. If it fails it will try to take `refreshToken` from the http-only cookie `refreshToken`. `csrfToken` is required when `refreshToken` is provided as a cookie. */
export type RefreshToken = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  /** JWT token, required to authenticate. */
  readonly token?: Maybe<Scalars['String']['output']>;
  /** A user instance. */
  readonly user?: Maybe<User>;
};

/**
 * Updates RefundSettings. The `Page` (Model) Type will be cleared from `reasonReferenceType`. When it's cleared, passing reason reference to refund mutations is no longer accepted and will raise error.
 *
 * Added in Saleor 3.22.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type RefundReasonReferenceTypeClear = {
  readonly errors: ReadonlyArray<RefundReasonReferenceTypeClearError>;
  /** Refund settings. */
  readonly refundSettings: RefundSettings;
  /** @deprecated Use `errors` field instead. */
  readonly refundSettingsErrors: ReadonlyArray<RefundReasonReferenceTypeClearError>;
};

export type RefundReasonReferenceTypeClearError = {
  /** Failed to clear refund reason reference type */
  readonly code: RefundSettingsErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/**
 * Refund related settings from site settings.
 *
 * Added in Saleor 3.22.
 */
export type RefundSettings = {
  /** Model type used for refund reasons. */
  readonly reasonReferenceType?: Maybe<PageType>;
};

export type RefundSettingsErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'REQUIRED';

/**
 * Update refund settings across all channels.
 *
 * Added in Saleor 3.22.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type RefundSettingsUpdate = {
  readonly errors: ReadonlyArray<RefundSettingsUpdateError>;
  /** Refund settings. */
  readonly refundSettings: RefundSettings;
  /** @deprecated Use `errors` field instead. */
  readonly refundSettingsErrors: ReadonlyArray<RefundSettingsUpdateError>;
};

export type RefundSettingsUpdateError = {
  /** Failed to update Refund Settings */
  readonly code: RefundSettingsErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type RefundSettingsUpdateInput = {
  /**
   * The ID of a model type, that will be used to reference refund reasons. All models with of this type will be accepted as refund reasons.
   *
   * Added in Saleor 3.22.
   */
  readonly refundReasonReferenceType: Scalars['ID']['input'];
};

export type ReorderInput = {
  /** The ID of the item to move. */
  readonly id: Scalars['ID']['input'];
  /** The new relative sorting position of the item (from -inf to +inf). 1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged. */
  readonly sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

export type ReportingPeriod =
  | 'THIS_MONTH'
  | 'TODAY';

/**
 * Request email change of the logged in user.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - NOTIFY_USER (async): A notification for account email change.
 * - ACCOUNT_CHANGE_EMAIL_REQUESTED (async): An account email change was requested.
 */
export type RequestEmailChange = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  /** A user instance. */
  readonly user?: Maybe<User>;
};

/**
 * Sends an email with the account password modification link.
 *
 * Triggers the following webhook events:
 * - NOTIFY_USER (async): A notification for password reset.
 * - ACCOUNT_SET_PASSWORD_REQUESTED (async): Setting a new password for the account is requested.
 * - STAFF_SET_PASSWORD_REQUESTED (async): Setting a new password for the staff account is requested.
 */
export type RequestPasswordReset = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
};

export type RewardTypeEnum =
  | 'GIFT'
  | 'SUBTOTAL_DISCOUNT';

export type RewardValueTypeEnum =
  | 'FIXED'
  | 'PERCENTAGE';

/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type Sale = Node & ObjectWithMetadata & {
  /** List of categories this sale applies to. */
  readonly categories?: Maybe<CategoryCountableConnection>;
  /**
   * List of channels available for the sale.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  readonly channelListings?: Maybe<ReadonlyArray<SaleChannelListing>>;
  /**
   * List of collections this sale applies to.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  readonly collections?: Maybe<CollectionCountableConnection>;
  /** The date and time when the sale was created. */
  readonly created: Scalars['DateTime']['output'];
  /** Currency code for sale. */
  readonly currency?: Maybe<Scalars['String']['output']>;
  /** Sale value. */
  readonly discountValue?: Maybe<Scalars['Float']['output']>;
  /** The end date and time of the sale. */
  readonly endDate?: Maybe<Scalars['DateTime']['output']>;
  /** The ID of the sale. */
  readonly id: Scalars['ID']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** The name of the sale. */
  readonly name: Scalars['String']['output'];
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /**
   * List of products this sale applies to.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  readonly products?: Maybe<ProductCountableConnection>;
  /** The start date and time of the sale. */
  readonly startDate: Scalars['DateTime']['output'];
  /** Returns translated sale fields for the given language code. */
  readonly translation?: Maybe<SaleTranslation>;
  /** Type of the sale, fixed or percentage. */
  readonly type: SaleType;
  /** The date and time when the sale was updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /**
   * List of product variants this sale applies to.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  readonly variants?: Maybe<ProductVariantCountableConnection>;
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SaleCategoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SaleCollectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SaleMetafieldArgs = {
  key: Scalars['String']['input'];
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SaleMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SalePrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SalePrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SaleProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SaleTranslationArgs = {
  languageCode: LanguageCodeEnum;
};


/**
 * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
 *
 * DEPRECATED: this type will be removed. Use `Promotion` type instead.
 */
export type SaleVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * Adds products, categories, collections to a sale.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - SALE_UPDATED (async): A sale was updated.
 */
export type SaleAddCatalogues = {
  /** @deprecated Use `errors` field instead. */
  readonly discountErrors: ReadonlyArray<DiscountError>;
  readonly errors: ReadonlyArray<DiscountError>;
  /** Sale of which catalogue IDs will be modified. */
  readonly sale?: Maybe<Sale>;
};

/**
 * Deletes sales.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - SALE_DELETED (async): A sale was deleted.
 */
export type SaleBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  /** @deprecated Use `errors` field instead. */
  readonly discountErrors: ReadonlyArray<DiscountError>;
  readonly errors: ReadonlyArray<DiscountError>;
};

/**
 * Represents sale channel listing.
 *
 * DEPRECATED: this type will be removed. Use `PromotionRule` type instead.
 */
export type SaleChannelListing = Node & {
  /** The channel in which the sale is available. */
  readonly channel: Channel;
  /** The currency in which the discount value is specified. */
  readonly currency: Scalars['String']['output'];
  /** The value of the discount applied to the sale in the channel. */
  readonly discountValue: Scalars['Float']['output'];
  /** The ID of the channel listing. */
  readonly id: Scalars['ID']['output'];
};

export type SaleChannelListingAddInput = {
  /** ID of a channel. */
  readonly channelId: Scalars['ID']['input'];
  /** The value of the discount. */
  readonly discountValue: Scalars['PositiveDecimal']['input'];
};

export type SaleChannelListingInput = {
  /** List of channels to which the sale should be assigned. */
  readonly addChannels?: InputMaybe<ReadonlyArray<SaleChannelListingAddInput>>;
  /** List of channels from which the sale should be unassigned. */
  readonly removeChannels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/**
 * Manage sale's availability in channels.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 */
export type SaleChannelListingUpdate = {
  /** @deprecated Use `errors` field instead. */
  readonly discountErrors: ReadonlyArray<DiscountError>;
  readonly errors: ReadonlyArray<DiscountError>;
  /** An updated sale instance. */
  readonly sale?: Maybe<Sale>;
};

export type SaleCountableConnection = {
  readonly edges: ReadonlyArray<SaleCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type SaleCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Sale;
};

/**
 * Creates a new sale.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - SALE_CREATED (async): A sale was created.
 */
export type SaleCreate = {
  /** @deprecated Use `errors` field instead. */
  readonly discountErrors: ReadonlyArray<DiscountError>;
  readonly errors: ReadonlyArray<DiscountError>;
  readonly sale?: Maybe<Sale>;
};

/**
 * Event sent when new sale is created.
 *
 * DEPRECATED: this event will be removed. Use `PromotionCreated` event instead.
 */
export type SaleCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The sale the event relates to. */
  readonly sale?: Maybe<Sale>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/**
 * Event sent when new sale is created.
 *
 * DEPRECATED: this event will be removed. Use `PromotionCreated` event instead.
 */
export type SaleCreatedSaleArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Deletes a sale.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - SALE_DELETED (async): A sale was deleted.
 */
export type SaleDelete = {
  /** @deprecated Use `errors` field instead. */
  readonly discountErrors: ReadonlyArray<DiscountError>;
  readonly errors: ReadonlyArray<DiscountError>;
  readonly sale?: Maybe<Sale>;
};

/**
 * Event sent when sale is deleted.
 *
 * DEPRECATED: this event will be removed. Use `PromotionDeleted` event instead.
 */
export type SaleDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The sale the event relates to. */
  readonly sale?: Maybe<Sale>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/**
 * Event sent when sale is deleted.
 *
 * DEPRECATED: this event will be removed. Use `PromotionDeleted` event instead.
 */
export type SaleDeletedSaleArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

export type SaleFilterInput = {
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly saleType?: InputMaybe<DiscountValueTypeEnum>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly started?: InputMaybe<DateTimeRangeInput>;
  readonly status?: InputMaybe<ReadonlyArray<DiscountStatusEnum>>;
  readonly updatedAt?: InputMaybe<DateTimeRangeInput>;
};

export type SaleInput = {
  /** Categories related to the discount. */
  readonly categories?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Collections related to the discount. */
  readonly collections?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** End date of the voucher in ISO 8601 format. */
  readonly endDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Voucher name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Products related to the discount. */
  readonly products?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Start date of the voucher in ISO 8601 format. */
  readonly startDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Fixed or percentage. */
  readonly type?: InputMaybe<DiscountValueTypeEnum>;
  /** Value of the voucher. */
  readonly value?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  readonly variants?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/**
 * Removes products, categories, collections from a sale.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - SALE_UPDATED (async): A sale was updated.
 */
export type SaleRemoveCatalogues = {
  /** @deprecated Use `errors` field instead. */
  readonly discountErrors: ReadonlyArray<DiscountError>;
  readonly errors: ReadonlyArray<DiscountError>;
  /** Sale of which catalogue IDs will be modified. */
  readonly sale?: Maybe<Sale>;
};

export type SaleSortField =
  /** Sort sales by creation date. */
  | 'CREATED_AT'
  /** Sort sales by end date. */
  | 'END_DATE'
  /** Sort sales by last modification date. */
  | 'LAST_MODIFIED_AT'
  /** Sort sales by name. */
  | 'NAME'
  /** Sort sales by start date. */
  | 'START_DATE'
  /** Sort sales by type. */
  | 'TYPE'
  /**
   * Sort sales by value.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'VALUE';

export type SaleSortingInput = {
  /**
   * Specifies the channel in which to sort the data.
   * @deprecated Use root-level channel argument instead.
   */
  readonly channel?: InputMaybe<Scalars['String']['input']>;
  /** Specifies the direction in which to sort sales. */
  readonly direction: OrderDirection;
  /** Sort sales by the selected field. */
  readonly field: SaleSortField;
};

/**
 * The event informs about the start or end of the sale.
 *
 * DEPRECATED: this event will be removed. Use `PromotionStarted` and `PromotionEnded` events instead.
 */
export type SaleToggle = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The sale the event relates to. */
  readonly sale?: Maybe<Sale>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/**
 * The event informs about the start or end of the sale.
 *
 * DEPRECATED: this event will be removed. Use `PromotionStarted` and `PromotionEnded` events instead.
 */
export type SaleToggleSaleArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Represents sale's original translatable fields and related translations.
 *
 * DEPRECATED: this type will be removed. Use `PromotionTranslatableContent` instead.
 */
export type SaleTranslatableContent = Node & {
  /** The ID of the sale translatable content. */
  readonly id: Scalars['ID']['output'];
  /** Name of the sale to translate. */
  readonly name: Scalars['String']['output'];
  /**
   * Sales allow creating discounts for categories, collections or products and are visible to all the customers.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   * @deprecated Get model fields from the root level queries.
   */
  readonly sale?: Maybe<Sale>;
  /** The ID of the sale to translate. */
  readonly saleId: Scalars['ID']['output'];
  /** Returns translated sale fields for the given language code. */
  readonly translation?: Maybe<SaleTranslation>;
};


/**
 * Represents sale's original translatable fields and related translations.
 *
 * DEPRECATED: this type will be removed. Use `PromotionTranslatableContent` instead.
 */
export type SaleTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a sale.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type SaleTranslate = {
  readonly errors: ReadonlyArray<TranslationError>;
  readonly sale?: Maybe<Sale>;
  /** @deprecated Use `errors` field instead. */
  readonly translationErrors: ReadonlyArray<TranslationError>;
};

/**
 * Represents sale translations.
 *
 * DEPRECATED: this type will be removed. Use `PromotionTranslation` instead.
 */
export type SaleTranslation = Node & {
  /** The ID of the sale translation. */
  readonly id: Scalars['ID']['output'];
  /** Translation language. */
  readonly language: LanguageDisplay;
  /** Translated name of sale. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Represents the sale fields to translate. */
  readonly translatableContent?: Maybe<SaleTranslatableContent>;
};

export type SaleType =
  | 'FIXED'
  | 'PERCENTAGE';

/**
 * Updates a sale.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - SALE_UPDATED (async): A sale was updated.
 * - SALE_TOGGLE (async): Optionally triggered when a sale is started or stopped.
 */
export type SaleUpdate = {
  /** @deprecated Use `errors` field instead. */
  readonly discountErrors: ReadonlyArray<DiscountError>;
  readonly errors: ReadonlyArray<DiscountError>;
  readonly sale?: Maybe<Sale>;
};

/**
 * Event sent when sale is updated.
 *
 * DEPRECATED: this event will be removed. Use `PromotionUpdated` event instead.
 */
export type SaleUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The sale the event relates to. */
  readonly sale?: Maybe<Sale>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/**
 * Event sent when sale is updated.
 *
 * DEPRECATED: this event will be removed. Use `PromotionUpdated` event instead.
 */
export type SaleUpdatedSaleArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an assigned attribute to an object. */
export type SelectedAttribute = {
  /** Name of an attribute displayed in the interface. */
  readonly attribute: Attribute;
  /** Values of an attribute. */
  readonly values: ReadonlyArray<AttributeValue>;
};

/**
 * Sends a notification confirmation.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - NOTIFY_USER (async): A notification for account confirmation.
 * - ACCOUNT_CONFIRMATION_REQUESTED (async): An account confirmation was requested. This event is always sent regardless of settings.
 */
export type SendConfirmationEmail = {
  readonly errors: ReadonlyArray<SendConfirmationEmailError>;
};

export type SendConfirmationEmailError = {
  /** The error code. */
  readonly code: SendConfirmationEmailErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type SendConfirmationEmailErrorCode =
  | 'ACCOUNT_CONFIRMED'
  | 'CONFIRMATION_ALREADY_REQUESTED'
  | 'INVALID'
  | 'MISSING_CHANNEL_SLUG';

export type SeoInput = {
  /** SEO description. */
  readonly description?: InputMaybe<Scalars['String']['input']>;
  /** SEO title. */
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

/** Sets the user's password from the token sent by email using the RequestPasswordReset mutation. */
export type SetPassword = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  /** CSRF token required to re-generate access token. */
  readonly csrfToken?: Maybe<Scalars['String']['output']>;
  readonly errors: ReadonlyArray<AccountError>;
  /** JWT refresh token, required to re-generate access token. */
  readonly refreshToken?: Maybe<Scalars['String']['output']>;
  /** JWT token, required to authenticate. */
  readonly token?: Maybe<Scalars['String']['output']>;
  /** A user instance. */
  readonly user?: Maybe<User>;
};

export type ShippingError = {
  /** List of channels IDs which causes the error. */
  readonly channels?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error code. */
  readonly code: ShippingErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of warehouse IDs which causes the error. */
  readonly warehouses?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

export type ShippingErrorCode =
  | 'ALREADY_EXISTS'
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'MAX_LESS_THAN_MIN'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

/** List shipping methods for checkout. */
export type ShippingListMethodsForCheckout = Event & {
  /** The checkout the event relates to. */
  readonly checkout?: Maybe<Checkout>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Shipping methods that can be used with this checkout. */
  readonly shippingMethods?: Maybe<ReadonlyArray<ShippingMethod>>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethod = Node & ObjectWithMetadata & {
  /** Describes if this shipping method is active and can be selected. */
  readonly active: Scalars['Boolean']['output'];
  /**
   * Shipping method description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /** Unique ID of ShippingMethod available for Order. */
  readonly id: Scalars['ID']['output'];
  /** Maximum delivery days for this shipping method. */
  readonly maximumDeliveryDays?: Maybe<Scalars['Int']['output']>;
  /** Maximum order price for this shipping method. */
  readonly maximumOrderPrice?: Maybe<Money>;
  /**
   * Maximum order weight for this shipping method.
   * @deprecated Field no longer supported
   */
  readonly maximumOrderWeight?: Maybe<Weight>;
  /** Message connected to this shipping method. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Minimum delivery days for this shipping method. */
  readonly minimumDeliveryDays?: Maybe<Scalars['Int']['output']>;
  /** Minimal order price for this shipping method. */
  readonly minimumOrderPrice?: Maybe<Money>;
  /**
   * Minimum order weight for this shipping method.
   * @deprecated Field no longer supported
   */
  readonly minimumOrderWeight?: Maybe<Weight>;
  /** Shipping method name. */
  readonly name: Scalars['String']['output'];
  /** The price of selected shipping method. */
  readonly price: Money;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Returns translated shipping method fields for the given language code. */
  readonly translation?: Maybe<ShippingMethodTranslation>;
  /**
   * Type of the shipping method.
   * @deprecated Field no longer supported
   */
  readonly type?: Maybe<ShippingMethodTypeEnum>;
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Represents shipping method channel listing. */
export type ShippingMethodChannelListing = Node & {
  /** The channel associated with the shipping method channel listing. */
  readonly channel: Channel;
  /** The ID of shipping method channel listing. */
  readonly id: Scalars['ID']['output'];
  /** Maximum order price. */
  readonly maximumOrderPrice?: Maybe<Money>;
  /** Minimum order price. */
  readonly minimumOrderPrice?: Maybe<Money>;
  /** Price of the shipping method in the associated channel. */
  readonly price?: Maybe<Money>;
};

export type ShippingMethodChannelListingAddInput = {
  /** ID of a channel. */
  readonly channelId: Scalars['ID']['input'];
  /** Maximum order price to use this shipping method. */
  readonly maximumOrderPrice?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** Minimum order price to use this shipping method. */
  readonly minimumOrderPrice?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** Shipping price of the shipping method in this channel. */
  readonly price?: InputMaybe<Scalars['PositiveDecimal']['input']>;
};

export type ShippingMethodChannelListingInput = {
  /** List of channels to which the shipping method should be assigned. */
  readonly addChannels?: InputMaybe<ReadonlyArray<ShippingMethodChannelListingAddInput>>;
  /** List of channels from which the shipping method should be unassigned. */
  readonly removeChannels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/**
 * Manage shipping method's availability in channels.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingMethodChannelListingUpdate = {
  readonly errors: ReadonlyArray<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  readonly shippingErrors: ReadonlyArray<ShippingError>;
  /** An updated shipping method instance. */
  readonly shippingMethod?: Maybe<ShippingMethodType>;
};

/** Represents shipping method postal code rule. */
export type ShippingMethodPostalCodeRule = Node & {
  /** End address range. */
  readonly end?: Maybe<Scalars['String']['output']>;
  /** The ID of the object. */
  readonly id: Scalars['ID']['output'];
  /** Inclusion type of the postal code rule. */
  readonly inclusionType?: Maybe<PostalCodeRuleInclusionTypeEnum>;
  /** Start address range. */
  readonly start?: Maybe<Scalars['String']['output']>;
};

/** Represents shipping method's original translatable fields and related translations. */
export type ShippingMethodTranslatableContent = Node & {
  /**
   * Shipping method description to translate.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /** The ID of the shipping method translatable content. */
  readonly id: Scalars['ID']['output'];
  /** Shipping method name to translate. */
  readonly name: Scalars['String']['output'];
  /**
   * Shipping method are the methods you'll use to get customer's orders  to them. They are directly exposed to the customers.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   * @deprecated Get model fields from the root level queries.
   */
  readonly shippingMethod?: Maybe<ShippingMethodType>;
  /** The ID of the shipping method to translate. */
  readonly shippingMethodId: Scalars['ID']['output'];
  /** Returns translated shipping method fields for the given language code. */
  readonly translation?: Maybe<ShippingMethodTranslation>;
};


/** Represents shipping method's original translatable fields and related translations. */
export type ShippingMethodTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Represents shipping method translations. */
export type ShippingMethodTranslation = Node & {
  /**
   * Translated description of the shipping method.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /** The ID of the shipping method translation. */
  readonly id: Scalars['ID']['output'];
  /** Translation language. */
  readonly language: LanguageDisplay;
  /** Translated shipping method name. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Represents the shipping method fields to translate. */
  readonly translatableContent?: Maybe<ShippingMethodTranslatableContent>;
};

/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodType = Node & ObjectWithMetadata & {
  /**
   * List of channels available for the method.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly channelListings?: Maybe<ReadonlyArray<ShippingMethodChannelListing>>;
  /**
   * Shipping method description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: Maybe<Scalars['JSONString']['output']>;
  /**
   * List of excluded products for the shipping method.
   *
   * Requires one of the following permissions: MANAGE_SHIPPING.
   */
  readonly excludedProducts?: Maybe<ProductCountableConnection>;
  /** Shipping method ID. */
  readonly id: Scalars['ID']['output'];
  /** Maximum number of days for delivery. */
  readonly maximumDeliveryDays?: Maybe<Scalars['Int']['output']>;
  /** The price of the cheapest variant (including discounts). */
  readonly maximumOrderPrice?: Maybe<Money>;
  /** Maximum order weight to use this shipping method. */
  readonly maximumOrderWeight?: Maybe<Weight>;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Minimal number of days for delivery. */
  readonly minimumDeliveryDays?: Maybe<Scalars['Int']['output']>;
  /** The price of the cheapest variant (including discounts). */
  readonly minimumOrderPrice?: Maybe<Money>;
  /** Minimum order weight to use this shipping method. */
  readonly minimumOrderWeight?: Maybe<Weight>;
  /** Shipping method name. */
  readonly name: Scalars['String']['output'];
  /** Postal code ranges rule of exclusion or inclusion of the shipping method. */
  readonly postalCodeRules?: Maybe<ReadonlyArray<ShippingMethodPostalCodeRule>>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /**
   * Tax class assigned to this shipping method.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly taxClass?: Maybe<TaxClass>;
  /** Returns translated shipping method fields for the given language code. */
  readonly translation?: Maybe<ShippingMethodTranslation>;
  /** Type of the shipping method. */
  readonly type?: Maybe<ShippingMethodTypeEnum>;
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypeExcludedProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypeMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypeMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypePrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypePrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypeTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

export type ShippingMethodTypeEnum =
  | 'PRICE'
  | 'WEIGHT';

/** List of shipping methods available for the country. */
export type ShippingMethodsPerCountry = {
  /** The country code. */
  readonly countryCode: CountryCode;
  /** List of available shipping methods. */
  readonly shippingMethods?: Maybe<ReadonlyArray<ShippingMethod>>;
};

export type ShippingPostalCodeRulesCreateInputRange = {
  /** End range of the postal code. */
  readonly end?: InputMaybe<Scalars['String']['input']>;
  /** Start range of the postal code. */
  readonly start: Scalars['String']['input'];
};

/**
 * Deletes shipping prices.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingPriceBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  readonly shippingErrors: ReadonlyArray<ShippingError>;
};

/**
 * Creates a new shipping price.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingPriceCreate = {
  readonly errors: ReadonlyArray<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  readonly shippingErrors: ReadonlyArray<ShippingError>;
  readonly shippingMethod?: Maybe<ShippingMethodType>;
  /** A shipping zone to which the shipping method belongs. */
  readonly shippingZone?: Maybe<ShippingZone>;
};

/** Event sent when new shipping price is created. */
export type ShippingPriceCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The shipping method the event relates to. */
  readonly shippingMethod?: Maybe<ShippingMethodType>;
  /** The shipping zone the shipping method belongs to. */
  readonly shippingZone?: Maybe<ShippingZone>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when new shipping price is created. */
export type ShippingPriceCreatedShippingMethodArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};


/** Event sent when new shipping price is created. */
export type ShippingPriceCreatedShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Deletes a shipping price.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingPriceDelete = {
  readonly errors: ReadonlyArray<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  readonly shippingErrors: ReadonlyArray<ShippingError>;
  /** A shipping method to delete. */
  readonly shippingMethod?: Maybe<ShippingMethodType>;
  /** A shipping zone to which the shipping method belongs. */
  readonly shippingZone?: Maybe<ShippingZone>;
};

/** Event sent when shipping price is deleted. */
export type ShippingPriceDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The shipping method the event relates to. */
  readonly shippingMethod?: Maybe<ShippingMethodType>;
  /** The shipping zone the shipping method belongs to. */
  readonly shippingZone?: Maybe<ShippingZone>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when shipping price is deleted. */
export type ShippingPriceDeletedShippingMethodArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};


/** Event sent when shipping price is deleted. */
export type ShippingPriceDeletedShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Exclude products from shipping price.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingPriceExcludeProducts = {
  readonly errors: ReadonlyArray<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  readonly shippingErrors: ReadonlyArray<ShippingError>;
  /** A shipping method with new list of excluded products. */
  readonly shippingMethod?: Maybe<ShippingMethodType>;
};

export type ShippingPriceExcludeProductsInput = {
  /** List of products which will be excluded. */
  readonly products: ReadonlyArray<Scalars['ID']['input']>;
};

export type ShippingPriceInput = {
  /** Postal code rules to add. */
  readonly addPostalCodeRules?: InputMaybe<ReadonlyArray<ShippingPostalCodeRulesCreateInputRange>>;
  /** Postal code rules to delete. */
  readonly deletePostalCodeRules?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Shipping method description. */
  readonly description?: InputMaybe<Scalars['JSONString']['input']>;
  /** Inclusion type for currently assigned postal code rules. */
  readonly inclusionType?: InputMaybe<PostalCodeRuleInclusionTypeEnum>;
  /** Maximum number of days for delivery. */
  readonly maximumDeliveryDays?: InputMaybe<Scalars['Int']['input']>;
  /** Maximum order weight to use this shipping method. */
  readonly maximumOrderWeight?: InputMaybe<Scalars['WeightScalar']['input']>;
  /** Minimal number of days for delivery. */
  readonly minimumDeliveryDays?: InputMaybe<Scalars['Int']['input']>;
  /** Minimum order weight to use this shipping method. */
  readonly minimumOrderWeight?: InputMaybe<Scalars['WeightScalar']['input']>;
  /** Name of the shipping method. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Shipping zone this method belongs to. */
  readonly shippingZone?: InputMaybe<Scalars['ID']['input']>;
  /** ID of a tax class to assign to this shipping method. If not provided, the default tax class will be used. */
  readonly taxClass?: InputMaybe<Scalars['ID']['input']>;
  /** Shipping type: price or weight based. */
  readonly type?: InputMaybe<ShippingMethodTypeEnum>;
};

/**
 * Remove product from excluded list for shipping price.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingPriceRemoveProductFromExclude = {
  readonly errors: ReadonlyArray<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  readonly shippingErrors: ReadonlyArray<ShippingError>;
  /** A shipping method with new list of excluded products. */
  readonly shippingMethod?: Maybe<ShippingMethodType>;
};

/**
 * Creates/updates translations for a shipping method.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type ShippingPriceTranslate = {
  readonly errors: ReadonlyArray<TranslationError>;
  readonly shippingMethod?: Maybe<ShippingMethodType>;
  /** @deprecated Use `errors` field instead. */
  readonly translationErrors: ReadonlyArray<TranslationError>;
};

export type ShippingPriceTranslationInput = {
  /**
   * Translated shipping method description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: InputMaybe<Scalars['JSONString']['input']>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Updates a new shipping price.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingPriceUpdate = {
  readonly errors: ReadonlyArray<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  readonly shippingErrors: ReadonlyArray<ShippingError>;
  readonly shippingMethod?: Maybe<ShippingMethodType>;
  /** A shipping zone to which the shipping method belongs. */
  readonly shippingZone?: Maybe<ShippingZone>;
};

/** Event sent when shipping price is updated. */
export type ShippingPriceUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The shipping method the event relates to. */
  readonly shippingMethod?: Maybe<ShippingMethodType>;
  /** The shipping zone the shipping method belongs to. */
  readonly shippingZone?: Maybe<ShippingZone>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when shipping price is updated. */
export type ShippingPriceUpdatedShippingMethodArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};


/** Event sent when shipping price is updated. */
export type ShippingPriceUpdatedShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZone = Node & ObjectWithMetadata & {
  /** List of channels for shipping zone. */
  readonly channels: ReadonlyArray<Channel>;
  /** List of countries available for the method. */
  readonly countries: ReadonlyArray<CountryDisplay>;
  /** Indicates if the shipping zone is default one. */
  readonly default: Scalars['Boolean']['output'];
  /** Description of a shipping zone. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** The ID of shipping zone. */
  readonly id: Scalars['ID']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Shipping zone name. */
  readonly name: Scalars['String']['output'];
  /** Lowest and highest prices for the shipping. */
  readonly priceRange?: Maybe<MoneyRange>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** List of shipping methods available for orders shipped to countries within this shipping zone. */
  readonly shippingMethods?: Maybe<ReadonlyArray<ShippingMethodType>>;
  /** List of warehouses for shipping zone. */
  readonly warehouses: ReadonlyArray<Warehouse>;
};


/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZoneMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZoneMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZonePrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZonePrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/**
 * Deletes shipping zones.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingZoneBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  readonly shippingErrors: ReadonlyArray<ShippingError>;
};

export type ShippingZoneCountableConnection = {
  readonly edges: ReadonlyArray<ShippingZoneCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type ShippingZoneCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: ShippingZone;
};

/**
 * Creates a new shipping zone.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingZoneCreate = {
  readonly errors: ReadonlyArray<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  readonly shippingErrors: ReadonlyArray<ShippingError>;
  readonly shippingZone?: Maybe<ShippingZone>;
};

export type ShippingZoneCreateInput = {
  /** List of channels to assign to the shipping zone. */
  readonly addChannels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of warehouses to assign to a shipping zone */
  readonly addWarehouses?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of countries in this shipping zone. */
  readonly countries?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** Default shipping zone will be used for countries not covered by other zones. */
  readonly default?: InputMaybe<Scalars['Boolean']['input']>;
  /** Description of the shipping zone. */
  readonly description?: InputMaybe<Scalars['String']['input']>;
  /** Shipping zone's name. Visible only to the staff. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when new shipping zone is created. */
export type ShippingZoneCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The shipping zone the event relates to. */
  readonly shippingZone?: Maybe<ShippingZone>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when new shipping zone is created. */
export type ShippingZoneCreatedShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Deletes a shipping zone.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingZoneDelete = {
  readonly errors: ReadonlyArray<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  readonly shippingErrors: ReadonlyArray<ShippingError>;
  readonly shippingZone?: Maybe<ShippingZone>;
};

/** Event sent when shipping zone is deleted. */
export type ShippingZoneDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The shipping zone the event relates to. */
  readonly shippingZone?: Maybe<ShippingZone>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when shipping zone is deleted. */
export type ShippingZoneDeletedShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

export type ShippingZoneFilterInput = {
  readonly channels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when shipping zone metadata is updated. */
export type ShippingZoneMetadataUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The shipping zone the event relates to. */
  readonly shippingZone?: Maybe<ShippingZone>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when shipping zone metadata is updated. */
export type ShippingZoneMetadataUpdatedShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Updates a new shipping zone.
 *
 * Requires one of the following permissions: MANAGE_SHIPPING.
 */
export type ShippingZoneUpdate = {
  readonly errors: ReadonlyArray<ShippingError>;
  /** @deprecated Use `errors` field instead. */
  readonly shippingErrors: ReadonlyArray<ShippingError>;
  readonly shippingZone?: Maybe<ShippingZone>;
};

export type ShippingZoneUpdateInput = {
  /** List of channels to assign to the shipping zone. */
  readonly addChannels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of warehouses to assign to a shipping zone */
  readonly addWarehouses?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of countries in this shipping zone. */
  readonly countries?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** Default shipping zone will be used for countries not covered by other zones. */
  readonly default?: InputMaybe<Scalars['Boolean']['input']>;
  /** Description of the shipping zone. */
  readonly description?: InputMaybe<Scalars['String']['input']>;
  /** Shipping zone's name. Visible only to the staff. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** List of channels to unassign from the shipping zone. */
  readonly removeChannels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** List of warehouses to unassign from a shipping zone */
  readonly removeWarehouses?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/** Event sent when shipping zone is updated. */
export type ShippingZoneUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The shipping zone the event relates to. */
  readonly shippingZone?: Maybe<ShippingZone>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};


/** Event sent when shipping zone is updated. */
export type ShippingZoneUpdatedShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/** Represents a shop resource containing general shop data and configuration. */
export type Shop = ObjectWithMetadata & {
  /**
   * Determines if user can login without confirmation when `enableAccountConfirmation` is enabled.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly allowLoginWithoutConfirmation?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Enable automatic fulfillment for all digital products.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly automaticFulfillmentDigitalProducts?: Maybe<Scalars['Boolean']['output']>;
  /** List of available external authentications. */
  readonly availableExternalAuthentications: ReadonlyArray<ExternalAuthentication>;
  /** List of available payment gateways. */
  readonly availablePaymentGateways: ReadonlyArray<PaymentGateway>;
  /** Shipping methods that are available for the shop. */
  readonly availableShippingMethods?: Maybe<ReadonlyArray<ShippingMethod>>;
  /**
   * List of tax apps that can be assigned to the channel. The list will be calculated by Saleor based on the apps that are subscribed to webhooks related to tax calculations: CHECKOUT_CALCULATE_TAXES
   *
   * Added in Saleor 3.19.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, MANAGE_APPS.
   */
  readonly availableTaxApps: ReadonlyArray<App>;
  /**
   * List of all currencies supported by shop's channels.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly channelCurrencies: ReadonlyArray<Scalars['String']['output']>;
  /**
   * Charge taxes on shipping.
   * @deprecated Use `ShippingMethodType.taxClass` to determine whether taxes are calculated for shipping methods; if a tax class is set, the taxes will be calculated, otherwise no tax rate will be applied.
   */
  readonly chargeTaxesOnShipping: Scalars['Boolean']['output'];
  /** Company address. */
  readonly companyAddress?: Maybe<Address>;
  /** List of countries available in the shop. */
  readonly countries: ReadonlyArray<CountryDisplay>;
  /** URL of a view where customers can set their password. */
  readonly customerSetPasswordUrl?: Maybe<Scalars['String']['output']>;
  /** Shop's default country. */
  readonly defaultCountry?: Maybe<CountryDisplay>;
  /**
   * Default number of max downloads per digital content URL.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly defaultDigitalMaxDownloads?: Maybe<Scalars['Int']['output']>;
  /**
   * Default number of days which digital content URL will be valid.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly defaultDigitalUrlValidDays?: Maybe<Scalars['Int']['output']>;
  /**
   * Default shop's email sender's address.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly defaultMailSenderAddress?: Maybe<Scalars['String']['output']>;
  /**
   * Default shop's email sender's name.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly defaultMailSenderName?: Maybe<Scalars['String']['output']>;
  /** Default weight unit. */
  readonly defaultWeightUnit?: Maybe<WeightUnitsEnum>;
  /** Shop's description. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /**
   * Display prices with tax in store.
   * @deprecated Use `Channel.taxConfiguration` to determine whether to display gross or net prices.
   */
  readonly displayGrossPrices: Scalars['Boolean']['output'];
  /** Shop's domain data. */
  readonly domain: Domain;
  /**
   * Determines if account confirmation by email is enabled.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly enableAccountConfirmationByEmail?: Maybe<Scalars['Boolean']['output']>;
  /** Allow to approve fulfillments which are unpaid. */
  readonly fulfillmentAllowUnpaid: Scalars['Boolean']['output'];
  /** Automatically approve all new fulfillments. */
  readonly fulfillmentAutoApprove: Scalars['Boolean']['output'];
  /** Header text. */
  readonly headerText?: Maybe<Scalars['String']['output']>;
  /** ID of the shop. */
  readonly id: Scalars['ID']['output'];
  /**
   * Include taxes in prices.
   * @deprecated Use `Channel.taxConfiguration.pricesEnteredWithTax` to determine whether prices are entered with tax.
   */
  readonly includeTaxesInPrices: Scalars['Boolean']['output'];
  /** List of the shops's supported languages. */
  readonly languages: ReadonlyArray<LanguageDisplay>;
  /**
   * Default number of maximum line quantity in single checkout (per single checkout line).
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly limitQuantityPerCheckout?: Maybe<Scalars['Int']['output']>;
  /**
   * Resource limitations and current usage if any set for a shop
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
   * @deprecated Field no longer supported
   */
  readonly limits: LimitInfo;
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Shop's name. */
  readonly name: Scalars['String']['output'];
  /** List of available permissions. */
  readonly permissions: ReadonlyArray<Permission>;
  /** List of possible phone prefixes. */
  readonly phonePrefixes: ReadonlyArray<Scalars['String']['output']>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /**
   * Default number of minutes stock will be reserved for anonymous checkout or null when stock reservation is disabled.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly reserveStockDurationAnonymousUser?: Maybe<Scalars['Int']['output']>;
  /**
   * Default number of minutes stock will be reserved for authenticated checkout or null when stock reservation is disabled.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly reserveStockDurationAuthenticatedUser?: Maybe<Scalars['Int']['output']>;
  /** Minor Saleor API version. */
  readonly schemaVersion: Scalars['String']['output'];
  /**
   * List of staff notification recipients.
   *
   * Requires one of the following permissions: MANAGE_SETTINGS.
   */
  readonly staffNotificationRecipients?: Maybe<ReadonlyArray<StaffNotificationRecipient>>;
  /** This field is used as a default value for `ProductVariant.trackInventory`. */
  readonly trackInventoryByDefault?: Maybe<Scalars['Boolean']['output']>;
  /** Returns translated shop fields for the given language code. */
  readonly translation?: Maybe<ShopTranslation>;
  /**
   * Saleor API version.
   *
   * Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP.
   */
  readonly version: Scalars['String']['output'];
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopAvailablePaymentGatewaysArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopAvailableShippingMethodsArgs = {
  address?: InputMaybe<AddressInput>;
  channel: Scalars['String']['input'];
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopCountriesArgs = {
  filter?: InputMaybe<CountryFilterInput>;
  languageCode?: InputMaybe<LanguageCodeEnum>;
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Update the shop's address. If the `null` value is passed, the currently selected address will be deleted.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type ShopAddressUpdate = {
  readonly errors: ReadonlyArray<ShopError>;
  /** Updated shop. */
  readonly shop?: Maybe<Shop>;
  /** @deprecated Use `errors` field instead. */
  readonly shopErrors: ReadonlyArray<ShopError>;
};

/**
 * Updates site domain of the shop.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type ShopDomainUpdate = {
  readonly errors: ReadonlyArray<ShopError>;
  /** Updated shop. */
  readonly shop?: Maybe<Shop>;
  /** @deprecated Use `errors` field instead. */
  readonly shopErrors: ReadonlyArray<ShopError>;
};

export type ShopError = {
  /** The error code. */
  readonly code: ShopErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type ShopErrorCode =
  | 'ALREADY_EXISTS'
  | 'CANNOT_FETCH_TAX_RATES'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

/**
 * Fetch tax rates.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type ShopFetchTaxRates = {
  readonly errors: ReadonlyArray<ShopError>;
  /** Updated shop. */
  readonly shop?: Maybe<Shop>;
  /** @deprecated Use `errors` field instead. */
  readonly shopErrors: ReadonlyArray<ShopError>;
};

/** Event sent when shop metadata is updated. */
export type ShopMetadataUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Shop data. */
  readonly shop?: Maybe<Shop>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type ShopSettingsInput = {
  /** Enable possibility to login without account confirmation. */
  readonly allowLoginWithoutConfirmation?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enable automatic fulfillment for all digital products. */
  readonly automaticFulfillmentDigitalProducts?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Charge taxes on shipping.
   * @deprecated To enable taxes for a shipping method, assign a tax class to the shipping method with `shippingPriceCreate` or `shippingPriceUpdate` mutations.
   */
  readonly chargeTaxesOnShipping?: InputMaybe<Scalars['Boolean']['input']>;
  /** URL of a view where customers can set their password. */
  readonly customerSetPasswordUrl?: InputMaybe<Scalars['String']['input']>;
  /** Default number of max downloads per digital content URL. */
  readonly defaultDigitalMaxDownloads?: InputMaybe<Scalars['Int']['input']>;
  /** Default number of days which digital content URL will be valid. */
  readonly defaultDigitalUrlValidDays?: InputMaybe<Scalars['Int']['input']>;
  /** Default email sender's address. */
  readonly defaultMailSenderAddress?: InputMaybe<Scalars['String']['input']>;
  /** Default email sender's name. */
  readonly defaultMailSenderName?: InputMaybe<Scalars['String']['input']>;
  /** Default weight unit. */
  readonly defaultWeightUnit?: InputMaybe<WeightUnitsEnum>;
  /** SEO description. */
  readonly description?: InputMaybe<Scalars['String']['input']>;
  /**
   * Display prices with tax in store.
   * @deprecated Use `taxConfigurationUpdate` mutation to configure this setting per channel or country.
   */
  readonly displayGrossPrices?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enable automatic account confirmation by email. */
  readonly enableAccountConfirmationByEmail?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enable ability to approve fulfillments which are unpaid. */
  readonly fulfillmentAllowUnpaid?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enable automatic approval of all new fulfillments. */
  readonly fulfillmentAutoApprove?: InputMaybe<Scalars['Boolean']['input']>;
  /** Header text. */
  readonly headerText?: InputMaybe<Scalars['String']['input']>;
  /**
   * Include taxes in prices.
   * @deprecated Use `taxConfigurationUpdate` mutation to configure this setting per channel or country.
   */
  readonly includeTaxesInPrices?: InputMaybe<Scalars['Boolean']['input']>;
  /** Default number of maximum line quantity in single checkout. Minimum possible value is 1, default value is 50. */
  readonly limitQuantityPerCheckout?: InputMaybe<Scalars['Int']['input']>;
  /**
   * Shop public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /**
   * Shop private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Default number of minutes stock will be reserved for anonymous checkout. Enter 0 or null to disable. */
  readonly reserveStockDurationAnonymousUser?: InputMaybe<Scalars['Int']['input']>;
  /** Default number of minutes stock will be reserved for authenticated checkout. Enter 0 or null to disable. */
  readonly reserveStockDurationAuthenticatedUser?: InputMaybe<Scalars['Int']['input']>;
  /** This field is used as a default value for `ProductVariant.trackInventory`. */
  readonly trackInventoryByDefault?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * Creates/updates translations for shop settings.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type ShopSettingsTranslate = {
  readonly errors: ReadonlyArray<TranslationError>;
  /** Updated shop settings. */
  readonly shop?: Maybe<Shop>;
  /** @deprecated Use `errors` field instead. */
  readonly translationErrors: ReadonlyArray<TranslationError>;
};

export type ShopSettingsTranslationInput = {
  readonly description?: InputMaybe<Scalars['String']['input']>;
  readonly headerText?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Updates shop settings.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 *
 * Triggers the following webhook events:
 * - SHOP_METADATA_UPDATED (async): Optionally triggered when public or private metadata is updated.
 */
export type ShopSettingsUpdate = {
  readonly errors: ReadonlyArray<ShopError>;
  /** Updated shop. */
  readonly shop?: Maybe<Shop>;
  /** @deprecated Use `errors` field instead. */
  readonly shopErrors: ReadonlyArray<ShopError>;
};

/** Represents shop translations. */
export type ShopTranslation = Node & {
  /** Translated description of sale. */
  readonly description: Scalars['String']['output'];
  /** Translated header text of sale. */
  readonly headerText: Scalars['String']['output'];
  /** The ID of the shop translation. */
  readonly id: Scalars['ID']['output'];
  /** Translation language. */
  readonly language: LanguageDisplay;
};

export type SiteDomainInput = {
  /** Domain name for shop. */
  readonly domain?: InputMaybe<Scalars['String']['input']>;
  /** Shop site name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Deletes staff users. Apps are not allowed to perform this mutation.
 *
 * Requires one of the following permissions: MANAGE_STAFF.
 *
 * Triggers the following webhook events:
 * - STAFF_DELETED (async): A staff account was deleted.
 */
export type StaffBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<StaffError>;
  /** @deprecated Use `errors` field instead. */
  readonly staffErrors: ReadonlyArray<StaffError>;
};

/**
 * Creates a new staff user. Apps are not allowed to perform this mutation.
 *
 * Requires one of the following permissions: MANAGE_STAFF.
 *
 * Triggers the following webhook events:
 * - STAFF_CREATED (async): A new staff account was created.
 * - NOTIFY_USER (async): A notification for setting the password.
 * - STAFF_SET_PASSWORD_REQUESTED (async): Setting a new password for the staff account is requested.
 */
export type StaffCreate = {
  readonly errors: ReadonlyArray<StaffError>;
  /** @deprecated Use `errors` field instead. */
  readonly staffErrors: ReadonlyArray<StaffError>;
  readonly user?: Maybe<User>;
};

/** Fields required to create a staff user. */
export type StaffCreateInput = {
  /** List of permission group IDs to which user should be assigned. */
  readonly addGroups?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The unique email address of the user. */
  readonly email?: InputMaybe<Scalars['String']['input']>;
  /** Given name. */
  readonly firstName?: InputMaybe<Scalars['String']['input']>;
  /** User account is active. */
  readonly isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Family name. */
  readonly lastName?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the user metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** A note about the user. */
  readonly note?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the user private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** URL of a view where users should be redirected to set the password. URL in RFC 1808 format. */
  readonly redirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when new staff user is created. */
export type StaffCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The user the event relates to. */
  readonly user?: Maybe<User>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Deletes a staff user. Apps are not allowed to perform this mutation.
 *
 * Requires one of the following permissions: MANAGE_STAFF.
 *
 * Triggers the following webhook events:
 * - STAFF_DELETED (async): A staff account was deleted.
 */
export type StaffDelete = {
  readonly errors: ReadonlyArray<StaffError>;
  /** @deprecated Use `errors` field instead. */
  readonly staffErrors: ReadonlyArray<StaffError>;
  readonly user?: Maybe<User>;
};

/** Event sent when staff user is deleted. */
export type StaffDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The user the event relates to. */
  readonly user?: Maybe<User>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StaffError = {
  /** A type of address that causes the error. */
  readonly addressType?: Maybe<AddressTypeEnum>;
  /** The error code. */
  readonly code: AccountErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** List of permission group IDs which cause the error. */
  readonly groups?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of permissions which causes the error. */
  readonly permissions?: Maybe<ReadonlyArray<PermissionEnum>>;
  /** List of user IDs which causes the error. */
  readonly users?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

/** Represents status of a staff account. */
export type StaffMemberStatus =
  /** User account has been activated. */
  | 'ACTIVE'
  /** User account has not been activated yet. */
  | 'DEACTIVATED';

/** Represents a recipient of email notifications send by Saleor, such as notifications about new orders. Notifications can be assigned to staff users or arbitrary email addresses. */
export type StaffNotificationRecipient = Node & {
  /** Determines if a notification active. */
  readonly active?: Maybe<Scalars['Boolean']['output']>;
  /** Returns email address of a user subscribed to email notifications. */
  readonly email?: Maybe<Scalars['String']['output']>;
  /** The ID of the staff notification recipient. */
  readonly id: Scalars['ID']['output'];
  /** Returns a user subscribed to email notifications. */
  readonly user?: Maybe<User>;
};

/**
 * Creates a new staff notification recipient.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type StaffNotificationRecipientCreate = {
  readonly errors: ReadonlyArray<ShopError>;
  /** @deprecated Use `errors` field instead. */
  readonly shopErrors: ReadonlyArray<ShopError>;
  readonly staffNotificationRecipient?: Maybe<StaffNotificationRecipient>;
};

/**
 * Deletes staff notification recipient.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type StaffNotificationRecipientDelete = {
  readonly errors: ReadonlyArray<ShopError>;
  /** @deprecated Use `errors` field instead. */
  readonly shopErrors: ReadonlyArray<ShopError>;
  readonly staffNotificationRecipient?: Maybe<StaffNotificationRecipient>;
};

export type StaffNotificationRecipientInput = {
  /** Determines if a notification active. */
  readonly active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Email address of a user subscribed to email notifications. */
  readonly email?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the user subscribed to email notifications.. */
  readonly user?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * Updates a staff notification recipient.
 *
 * Requires one of the following permissions: MANAGE_SETTINGS.
 */
export type StaffNotificationRecipientUpdate = {
  readonly errors: ReadonlyArray<ShopError>;
  /** @deprecated Use `errors` field instead. */
  readonly shopErrors: ReadonlyArray<ShopError>;
  readonly staffNotificationRecipient?: Maybe<StaffNotificationRecipient>;
};

/** Event sent when setting a new password for staff is requested. */
export type StaffSetPasswordRequested = Event & {
  /** The channel data. */
  readonly channel?: Maybe<Channel>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The URL to redirect the user after he accepts the request. */
  readonly redirectUrl?: Maybe<Scalars['String']['output']>;
  /** Shop data. */
  readonly shop?: Maybe<Shop>;
  /** The token required to confirm request. */
  readonly token?: Maybe<Scalars['String']['output']>;
  /** The user the event relates to. */
  readonly user?: Maybe<User>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Updates an existing staff user. Apps are not allowed to perform this mutation.
 *
 * Requires one of the following permissions: MANAGE_STAFF.
 *
 * Triggers the following webhook events:
 * - STAFF_UPDATED (async): A staff account was updated.
 */
export type StaffUpdate = {
  readonly errors: ReadonlyArray<StaffError>;
  /** @deprecated Use `errors` field instead. */
  readonly staffErrors: ReadonlyArray<StaffError>;
  readonly user?: Maybe<User>;
};

/** Fields required to update a staff user. */
export type StaffUpdateInput = {
  /** List of permission group IDs to which user should be assigned. */
  readonly addGroups?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The unique email address of the user. */
  readonly email?: InputMaybe<Scalars['String']['input']>;
  /** Given name. */
  readonly firstName?: InputMaybe<Scalars['String']['input']>;
  /** User account is active. */
  readonly isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Family name. */
  readonly lastName?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the user metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** A note about the user. */
  readonly note?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the user private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** List of permission group IDs from which user should be unassigned. */
  readonly removeGroups?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/** Event sent when staff user is updated. */
export type StaffUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The user the event relates to. */
  readonly user?: Maybe<User>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StaffUserInput = {
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly status?: InputMaybe<StaffMemberStatus>;
};

/** Represents stock. */
export type Stock = Node & {
  /** The ID of stock. */
  readonly id: Scalars['ID']['output'];
  /** Information about the product variant. */
  readonly productVariant: ProductVariant;
  /**
   * Quantity of a product in the warehouse's possession, including the allocated stock that is waiting for shipment.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  readonly quantity: Scalars['Int']['output'];
  /**
   * Quantity allocated for orders.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  readonly quantityAllocated: Scalars['Int']['output'];
  /**
   * Quantity reserved for checkouts.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  readonly quantityReserved: Scalars['Int']['output'];
  /** The warehouse associated with the stock. */
  readonly warehouse: Warehouse;
};

export type StockAvailability =
  | 'IN_STOCK'
  | 'OUT_OF_STOCK';

export type StockBulkResult = {
  /** List of errors occurred on create or update attempt. */
  readonly errors?: Maybe<ReadonlyArray<StockBulkUpdateError>>;
  /** Stock data. */
  readonly stock?: Maybe<Stock>;
};

/**
 * Updates stocks for a given variant and warehouse. Variant and warehouse selectors have to be the same for all stock inputs. Is not allowed to use 'variantId' in one input and 'variantExternalReference' in another.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 *
 * Triggers the following webhook events:
 * - PRODUCT_VARIANT_STOCK_UPDATED (async): A product variant stock details were updated.
 */
export type StockBulkUpdate = {
  /** Returns how many objects were updated. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<StockBulkUpdateError>;
  /** List of the updated stocks. */
  readonly results: ReadonlyArray<StockBulkResult>;
};

export type StockBulkUpdateError = {
  /** The error code. */
  readonly code: StockBulkUpdateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type StockBulkUpdateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

export type StockBulkUpdateInput = {
  /** Quantity of items available for sell. */
  readonly quantity: Scalars['Int']['input'];
  /** Variant external reference. */
  readonly variantExternalReference?: InputMaybe<Scalars['String']['input']>;
  /** Variant ID. */
  readonly variantId?: InputMaybe<Scalars['ID']['input']>;
  /** Warehouse external reference. */
  readonly warehouseExternalReference?: InputMaybe<Scalars['String']['input']>;
  /** Warehouse ID. */
  readonly warehouseId?: InputMaybe<Scalars['ID']['input']>;
};

export type StockCountableConnection = {
  readonly edges: ReadonlyArray<StockCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type StockCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Stock;
};

export type StockError = {
  /** The error code. */
  readonly code: StockErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type StockErrorCode =
  | 'ALREADY_EXISTS'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type StockFilterInput = {
  readonly quantity?: InputMaybe<Scalars['Float']['input']>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
};

export type StockInput = {
  /** Quantity of items available for sell. */
  readonly quantity: Scalars['Int']['input'];
  /** Warehouse in which stock is located. */
  readonly warehouse: Scalars['ID']['input'];
};

/** Represents the channel stock settings. */
export type StockSettings = {
  /** Allocation strategy defines the preference of warehouses for allocations and reservations. */
  readonly allocationStrategy: AllocationStrategyEnum;
};

export type StockSettingsInput = {
  /** Allocation strategy options. Strategy defines the preference of warehouses for allocations and reservations. */
  readonly allocationStrategy: AllocationStrategyEnum;
};

export type StockUpdateInput = {
  /** Quantity of items available for sell. */
  readonly quantity: Scalars['Int']['input'];
  /** Stock. */
  readonly stock: Scalars['ID']['input'];
};

/**
 * Determine how stocks should be updated, while processing an order.
 *
 *     SKIP - stocks are not checked and not updated.
 *     UPDATE - only do update, if there is enough stock.
 *     FORCE - force update, if there is not enough stock.
 */
export type StockUpdatePolicyEnum =
  | 'FORCE'
  | 'SKIP'
  | 'UPDATE';

/** Enum representing the type of a payment storage in a gateway. */
export type StorePaymentMethodEnum =
  /** Storage is disabled. The payment is not stored. */
  | 'NONE'
  /** Off session storage type. The payment is stored to be reused even if the customer is absent. */
  | 'OFF_SESSION'
  /** On session storage type. The payment is stored only to be reused when the customer is present in the checkout flow. */
  | 'ON_SESSION';

/** Represents a payment method stored for user (tokenized) in payment gateway. */
export type StoredPaymentMethod = {
  /** Stored credit card details if available. */
  readonly creditCardInfo?: Maybe<CreditCard>;
  /** JSON data returned by Payment Provider app for this payment method. */
  readonly data?: Maybe<Scalars['JSON']['output']>;
  /** Payment gateway that stores this payment method. */
  readonly gateway: PaymentGateway;
  /** Stored payment method ID. */
  readonly id: Scalars['ID']['output'];
  /** Payment method name. Example: last 4 digits of credit card, obfuscated email, etc. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** ID of stored payment method used to make payment actions. Note: method ID is unique only within the payment gateway. */
  readonly paymentMethodId: Scalars['String']['output'];
  readonly supportedPaymentFlows?: Maybe<ReadonlyArray<TokenizedPaymentFlowEnum>>;
  /** Type of the payment method. Example: credit card, wallet, etc. */
  readonly type: Scalars['String']['output'];
};

/** Event sent when user requests to delete a payment method. */
export type StoredPaymentMethodDeleteRequested = Event & {
  /** Channel related to the requested delete action. */
  readonly channel: Channel;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The ID of the payment method that should be deleted by the payment gateway. */
  readonly paymentMethodId: Scalars['String']['output'];
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The user for which the app should proceed with payment method delete request. */
  readonly user: User;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Request to delete a stored payment method on payment provider side.
 *
 * Requires one of the following permissions: AUTHENTICATED_USER.
 *
 * Triggers the following webhook events:
 * - STORED_PAYMENT_METHOD_DELETE_REQUESTED (sync): The customer requested to delete a payment method.
 */
export type StoredPaymentMethodRequestDelete = {
  readonly errors: ReadonlyArray<PaymentMethodRequestDeleteError>;
  /** The result of deleting a stored payment method. */
  readonly result: StoredPaymentMethodRequestDeleteResult;
};

export type StoredPaymentMethodRequestDeleteErrorCode =
  | 'CHANNEL_INACTIVE'
  | 'GATEWAY_ERROR'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

/**
 * Result of deleting a stored payment method.
 *
 *     This enum is used to determine the result of deleting a stored payment method.
 *     SUCCESSFULLY_DELETED - The stored payment method was successfully deleted.
 *     FAILED_TO_DELETE - The stored payment method was not deleted.
 *     FAILED_TO_DELIVER - The request to delete the stored payment method was not
 *     delivered.
 */
export type StoredPaymentMethodRequestDeleteResult =
  | 'FAILED_TO_DELETE'
  | 'FAILED_TO_DELIVER'
  | 'SUCCESSFULLY_DELETED';

/** Define the filtering options for string fields. */
export type StringFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<Scalars['String']['input']>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

export type Subscription = {
  /**
   * Event sent when new checkout is created.
   *
   * Added in Saleor 3.21.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly checkoutCreated?: Maybe<CheckoutCreated>;
  /**
   * Event sent when checkout is fully authorized.
   *
   * Added in Saleor 3.21.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly checkoutFullyAuthorized?: Maybe<CheckoutFullyAuthorized>;
  /**
   * Event sent when checkout is fully-paid.
   *
   * Added in Saleor 3.21.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly checkoutFullyPaid?: Maybe<CheckoutFullyPaid>;
  /**
   * Event sent when checkout metadata is updated.
   *
   * Added in Saleor 3.21.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly checkoutMetadataUpdated?: Maybe<CheckoutMetadataUpdated>;
  /**
   * Event sent when checkout is updated.
   *
   * Added in Saleor 3.21.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly checkoutUpdated?: Maybe<CheckoutUpdated>;
  /**
   * Event sent when new draft order is created.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly draftOrderCreated?: Maybe<DraftOrderCreated>;
  /**
   * Event sent when draft order is deleted.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly draftOrderDeleted?: Maybe<DraftOrderDeleted>;
  /**
   * Event sent when draft order is updated.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly draftOrderUpdated?: Maybe<DraftOrderUpdated>;
  /** Look up subscription event. */
  readonly event?: Maybe<Event>;
  /**
   * Event sent when orders are imported.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderBulkCreated?: Maybe<OrderBulkCreated>;
  /**
   * Event sent when order is cancelled.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderCancelled?: Maybe<OrderCancelled>;
  /**
   * Event sent when order is confirmed.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderConfirmed?: Maybe<OrderConfirmed>;
  /**
   * Event sent when new order is created.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderCreated?: Maybe<OrderCreated>;
  /**
   * Event sent when order becomes expired.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderExpired?: Maybe<OrderExpired>;
  /**
   * Event sent when order is fulfilled.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderFulfilled?: Maybe<OrderFulfilled>;
  /**
   * Event sent when order is fully paid.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderFullyPaid?: Maybe<OrderFullyPaid>;
  /**
   * The order is fully refunded.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderFullyRefunded?: Maybe<OrderFullyRefunded>;
  /**
   * Event sent when order metadata is updated.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderMetadataUpdated?: Maybe<OrderMetadataUpdated>;
  /**
   * Payment has been made. The order may be partially or fully paid.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderPaid?: Maybe<OrderPaid>;
  /**
   * The order received a refund. The order may be partially or fully refunded.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderRefunded?: Maybe<OrderRefunded>;
  /**
   * Event sent when order is updated.
   *
   * Added in Saleor 3.20.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly orderUpdated?: Maybe<OrderUpdated>;
};


export type SubscriptionCheckoutCreatedArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionCheckoutFullyAuthorizedArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionCheckoutFullyPaidArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionCheckoutMetadataUpdatedArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionCheckoutUpdatedArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionDraftOrderCreatedArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionDraftOrderDeletedArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionDraftOrderUpdatedArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionOrderBulkCreatedArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionOrderCancelledArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionOrderConfirmedArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionOrderCreatedArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionOrderExpiredArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionOrderFulfilledArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionOrderFullyPaidArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionOrderFullyRefundedArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionOrderMetadataUpdatedArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionOrderPaidArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionOrderRefundedArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


export type SubscriptionOrderUpdatedArgs = {
  channels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

export type TaxCalculationStrategy =
  | 'FLAT_RATES'
  | 'TAX_APP';

/** Tax class is a named object used to define tax rates per country. Tax class can be assigned to product types, products and shipping methods to define their tax rates. */
export type TaxClass = Node & ObjectWithMetadata & {
  /** Country-specific tax rates for this tax class. */
  readonly countries: ReadonlyArray<TaxClassCountryRate>;
  /** The ID of the object. */
  readonly id: Scalars['ID']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Name of the tax class. */
  readonly name: Scalars['String']['output'];
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
};


/** Tax class is a named object used to define tax rates per country. Tax class can be assigned to product types, products and shipping methods to define their tax rates. */
export type TaxClassMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Tax class is a named object used to define tax rates per country. Tax class can be assigned to product types, products and shipping methods to define their tax rates. */
export type TaxClassMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Tax class is a named object used to define tax rates per country. Tax class can be assigned to product types, products and shipping methods to define their tax rates. */
export type TaxClassPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Tax class is a named object used to define tax rates per country. Tax class can be assigned to product types, products and shipping methods to define their tax rates. */
export type TaxClassPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

export type TaxClassCountableConnection = {
  readonly edges: ReadonlyArray<TaxClassCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TaxClassCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: TaxClass;
};

/** Tax rate for a country. When tax class is null, it represents the default tax rate for that country; otherwise it's a country tax rate specific to the given tax class. */
export type TaxClassCountryRate = {
  /** Country in which this tax rate applies. */
  readonly country: CountryDisplay;
  /** Tax rate value. */
  readonly rate: Scalars['Float']['output'];
  /** Related tax class. */
  readonly taxClass?: Maybe<TaxClass>;
};

/**
 * Creates a tax class.
 *
 * Requires one of the following permissions: MANAGE_TAXES.
 */
export type TaxClassCreate = {
  readonly errors: ReadonlyArray<TaxClassCreateError>;
  readonly taxClass?: Maybe<TaxClass>;
};

export type TaxClassCreateError = {
  /** The error code. */
  readonly code: TaxClassCreateErrorCode;
  /** List of country codes for which the configuration is invalid. */
  readonly countryCodes: ReadonlyArray<Scalars['String']['output']>;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type TaxClassCreateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

export type TaxClassCreateInput = {
  /** List of country-specific tax rates to create for this tax class. */
  readonly createCountryRates?: InputMaybe<ReadonlyArray<CountryRateInput>>;
  /** Name of the tax class. */
  readonly name: Scalars['String']['input'];
};

/**
 * Deletes a tax class. After deleting the tax class any products, product types or shipping methods using it are updated to use the default tax class.
 *
 * Requires one of the following permissions: MANAGE_TAXES.
 */
export type TaxClassDelete = {
  readonly errors: ReadonlyArray<TaxClassDeleteError>;
  readonly taxClass?: Maybe<TaxClass>;
};

export type TaxClassDeleteError = {
  /** The error code. */
  readonly code: TaxClassDeleteErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type TaxClassDeleteErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

export type TaxClassFilterInput = {
  readonly countries?: InputMaybe<ReadonlyArray<CountryCode>>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
};

export type TaxClassRateInput = {
  /** Tax rate value. */
  readonly rate?: InputMaybe<Scalars['Float']['input']>;
  /** ID of a tax class for which to update the tax rate */
  readonly taxClassId?: InputMaybe<Scalars['ID']['input']>;
};

export type TaxClassSortField =
  /** Sort tax classes by name. */
  | 'NAME';

export type TaxClassSortingInput = {
  /** Specifies the direction in which to sort tax classes. */
  readonly direction: OrderDirection;
  /** Sort tax classes by the selected field. */
  readonly field: TaxClassSortField;
};

/**
 * Updates a tax class.
 *
 * Requires one of the following permissions: MANAGE_TAXES.
 */
export type TaxClassUpdate = {
  readonly errors: ReadonlyArray<TaxClassUpdateError>;
  readonly taxClass?: Maybe<TaxClass>;
};

export type TaxClassUpdateError = {
  /** The error code. */
  readonly code: TaxClassUpdateErrorCode;
  /** List of country codes for which the configuration is invalid. */
  readonly countryCodes: ReadonlyArray<Scalars['String']['output']>;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type TaxClassUpdateErrorCode =
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

export type TaxClassUpdateInput = {
  /** Name of the tax class. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** List of country codes for which to remove the tax class rates. Note: It removes all rates for given country code. */
  readonly removeCountryRates?: InputMaybe<ReadonlyArray<CountryCode>>;
  /** List of country-specific tax rates to create or update for this tax class. */
  readonly updateCountryRates?: InputMaybe<ReadonlyArray<CountryRateUpdateInput>>;
};

/** Channel-specific tax configuration. */
export type TaxConfiguration = Node & ObjectWithMetadata & {
  /** A channel to which the tax configuration applies to. */
  readonly channel: Channel;
  /** Determines whether taxes are charged in the given channel. */
  readonly chargeTaxes: Scalars['Boolean']['output'];
  /** List of country-specific exceptions in tax configuration. */
  readonly countries: ReadonlyArray<TaxConfigurationPerCountry>;
  /** Determines whether displayed prices should include taxes. */
  readonly displayGrossPrices: Scalars['Boolean']['output'];
  /** The ID of the object. */
  readonly id: Scalars['ID']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Determines whether prices are entered with the tax included. */
  readonly pricesEnteredWithTax: Scalars['Boolean']['output'];
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /**
   * The tax app `App.identifier` that will be used to calculate the taxes for the given channel. Empty value for `TAX_APP` set as `taxCalculationStrategy` means that Saleor will iterate over all installed tax apps. If multiple tax apps exist with provided tax app id use the `App` with newest `created` date. Will become mandatory in 4.0 for `TAX_APP` `taxCalculationStrategy`.
   *
   * Added in Saleor 3.19.
   */
  readonly taxAppId?: Maybe<Scalars['String']['output']>;
  /** The default strategy to use for tax calculation in the given channel. Taxes can be calculated either using user-defined flat rates or with a tax app. Empty value means that no method is selected and taxes are not calculated. */
  readonly taxCalculationStrategy?: Maybe<TaxCalculationStrategy>;
  /**
   * Determines whether to use weighted tax for shipping. When set to true, the tax rate for shipping will be calculated based on the weighted average of tax rates from the order or checkout lines.
   *
   * Added in Saleor 3.21.
   */
  readonly useWeightedTaxForShipping?: Maybe<Scalars['Boolean']['output']>;
};


/** Channel-specific tax configuration. */
export type TaxConfigurationMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Channel-specific tax configuration. */
export type TaxConfigurationMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Channel-specific tax configuration. */
export type TaxConfigurationPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Channel-specific tax configuration. */
export type TaxConfigurationPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

export type TaxConfigurationCountableConnection = {
  readonly edges: ReadonlyArray<TaxConfigurationCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TaxConfigurationCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: TaxConfiguration;
};

export type TaxConfigurationFilterInput = {
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
};

/** Country-specific exceptions of a channel's tax configuration. */
export type TaxConfigurationPerCountry = {
  /** Determines whether taxes are charged in this country. */
  readonly chargeTaxes: Scalars['Boolean']['output'];
  /** Country in which this configuration applies. */
  readonly country: CountryDisplay;
  /** Determines whether displayed prices should include taxes for this country. */
  readonly displayGrossPrices: Scalars['Boolean']['output'];
  /**
   * The tax app `App.identifier` that will be used to calculate the taxes for the given channel and country. If not provided, use the value from the channel's tax configuration.
   *
   * Added in Saleor 3.19.
   */
  readonly taxAppId?: Maybe<Scalars['String']['output']>;
  /** A country-specific strategy to use for tax calculation. Taxes can be calculated either using user-defined flat rates or with a tax app. If not provided, use the value from the channel's tax configuration. */
  readonly taxCalculationStrategy?: Maybe<TaxCalculationStrategy>;
  /**
   * Determines whether to use weighted tax for shipping. When set to true, the tax rate for shipping will be calculated based on the weighted average of tax rates from the order or checkout lines.
   *
   * Added in Saleor 3.21.
   */
  readonly useWeightedTaxForShipping?: Maybe<Scalars['Boolean']['output']>;
};

export type TaxConfigurationPerCountryInput = {
  /** Determines whether taxes are charged in this country. */
  readonly chargeTaxes: Scalars['Boolean']['input'];
  /** Country in which this configuration applies. */
  readonly countryCode: CountryCode;
  /** Determines whether displayed prices should include taxes for this country. */
  readonly displayGrossPrices: Scalars['Boolean']['input'];
  /**
   * The tax app `App.identifier` that will be used to calculate the taxes for the given channel and country. If not provided, use the value from the channel's tax configuration.
   *
   * Added in Saleor 3.19.
   */
  readonly taxAppId?: InputMaybe<Scalars['String']['input']>;
  /** A country-specific strategy to use for tax calculation. Taxes can be calculated either using user-defined flat rates or with a tax app. If not provided, use the value from the channel's tax configuration. */
  readonly taxCalculationStrategy?: InputMaybe<TaxCalculationStrategy>;
  /**
   * Determines whether to use weighted tax for shipping. When set to true, the tax rate for shipping will be calculated based on the weighted average of tax rates from the order or checkout lines. Default value is `False`.Can be used only with `taxCalculationStrategy` set to `FLAT_RATES`.
   *
   * Added in Saleor 3.21.
   */
  readonly useWeightedTaxForShipping?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * Updates tax configuration for a channel.
 *
 * Requires one of the following permissions: MANAGE_TAXES.
 */
export type TaxConfigurationUpdate = {
  readonly errors: ReadonlyArray<TaxConfigurationUpdateError>;
  readonly taxConfiguration?: Maybe<TaxConfiguration>;
};

export type TaxConfigurationUpdateError = {
  /** The error code. */
  readonly code: TaxConfigurationUpdateErrorCode;
  /** List of country codes for which the configuration is invalid. */
  readonly countryCodes: ReadonlyArray<Scalars['String']['output']>;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type TaxConfigurationUpdateErrorCode =
  | 'DUPLICATED_INPUT_ITEM'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

export type TaxConfigurationUpdateInput = {
  /** Determines whether taxes are charged in the given channel. */
  readonly chargeTaxes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Determines whether displayed prices should include taxes. */
  readonly displayGrossPrices?: InputMaybe<Scalars['Boolean']['input']>;
  /** Determines whether prices are entered with the tax included. */
  readonly pricesEnteredWithTax?: InputMaybe<Scalars['Boolean']['input']>;
  /** List of country codes for which to remove the tax configuration. */
  readonly removeCountriesConfiguration?: InputMaybe<ReadonlyArray<CountryCode>>;
  /**
   * The tax app `App.identifier` that will be used to calculate the taxes for the given channel. Empty value for `TAX_APP` set as `taxCalculationStrategy` means that Saleor will iterate over all installed tax apps. If multiple tax apps exist with provided tax app id use the `App` with newest `created` date. It's possible to set plugin by using prefix `plugin:` with `PLUGIN_ID` e.g. with Avalara `plugin:mirumee.taxes.avalara`.Will become mandatory in 4.0 for `TAX_APP` `taxCalculationStrategy`.
   *
   * Added in Saleor 3.19.
   */
  readonly taxAppId?: InputMaybe<Scalars['String']['input']>;
  /** The default strategy to use for tax calculation in the given channel. Taxes can be calculated either using user-defined flat rates or with a tax app. Empty value means that no method is selected and taxes are not calculated. */
  readonly taxCalculationStrategy?: InputMaybe<TaxCalculationStrategy>;
  /** List of tax country configurations to create or update (identified by a country code). */
  readonly updateCountriesConfiguration?: InputMaybe<ReadonlyArray<TaxConfigurationPerCountryInput>>;
  /**
   * Determines whether to use weighted tax for shipping. When set to true, the tax rate for shipping will be calculated based on the weighted average of tax rates from the order or checkout lines. Default value is `False`.Can be used only with `taxCalculationStrategy` set to `FLAT_RATES`.
   *
   * Added in Saleor 3.21.
   */
  readonly useWeightedTaxForShipping?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Tax class rates grouped by country. */
export type TaxCountryConfiguration = {
  /** A country for which tax class rates are grouped. */
  readonly country: CountryDisplay;
  /** List of tax class rates. */
  readonly taxClassCountryRates: ReadonlyArray<TaxClassCountryRate>;
};

/**
 * Remove all tax class rates for a specific country.
 *
 * Requires one of the following permissions: MANAGE_TAXES.
 */
export type TaxCountryConfigurationDelete = {
  readonly errors: ReadonlyArray<TaxCountryConfigurationDeleteError>;
  /** Updated tax class rates grouped by a country. */
  readonly taxCountryConfiguration?: Maybe<TaxCountryConfiguration>;
};

export type TaxCountryConfigurationDeleteError = {
  /** The error code. */
  readonly code: TaxCountryConfigurationDeleteErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type TaxCountryConfigurationDeleteErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

/**
 * Updates tax class rates for a specific country.
 *
 * Requires one of the following permissions: MANAGE_TAXES.
 */
export type TaxCountryConfigurationUpdate = {
  readonly errors: ReadonlyArray<TaxCountryConfigurationUpdateError>;
  /** Updated tax class rates grouped by a country. */
  readonly taxCountryConfiguration?: Maybe<TaxCountryConfiguration>;
};

export type TaxCountryConfigurationUpdateError = {
  /** The error code. */
  readonly code: TaxCountryConfigurationUpdateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of tax class IDs for which the update failed. */
  readonly taxClassIds: ReadonlyArray<Scalars['String']['output']>;
};

export type TaxCountryConfigurationUpdateErrorCode =
  | 'CANNOT_CREATE_NEGATIVE_RATE'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'ONLY_ONE_DEFAULT_COUNTRY_RATE_ALLOWED';

/**
 * Exempt checkout or order from charging the taxes. When tax exemption is enabled, taxes won't be charged for the checkout or order. Taxes may still be calculated in cases when product prices are entered with the tax included and the net price needs to be known.
 *
 * Requires one of the following permissions: MANAGE_TAXES.
 */
export type TaxExemptionManage = {
  readonly errors: ReadonlyArray<TaxExemptionManageError>;
  readonly taxableObject?: Maybe<TaxSourceObject>;
};

export type TaxExemptionManageError = {
  /** The error code. */
  readonly code: TaxExemptionManageErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type TaxExemptionManageErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_EDITABLE_ORDER'
  | 'NOT_FOUND';

export type TaxSourceLine = CheckoutLine | OrderLine;

export type TaxSourceObject = Checkout | Order;

/** Representation of tax types fetched from tax gateway. */
export type TaxType = {
  /** Description of the tax type. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** External tax code used to identify given tax group. */
  readonly taxCode?: Maybe<Scalars['String']['output']>;
};

/** Taxable object. */
export type TaxableObject = {
  /** The address data. */
  readonly address?: Maybe<Address>;
  readonly channel: Channel;
  /** The currency of the object. */
  readonly currency: Scalars['String']['output'];
  /** List of discounts. */
  readonly discounts: ReadonlyArray<TaxableObjectDiscount>;
  /** List of lines assigned to the object. */
  readonly lines: ReadonlyArray<TaxableObjectLine>;
  /** Determines if prices contain entered tax.. */
  readonly pricesEnteredWithTax: Scalars['Boolean']['output'];
  /** The price of shipping method, includes shipping voucher discount if applied. */
  readonly shippingPrice: Money;
  /** The source object related to this tax object. */
  readonly sourceObject: TaxSourceObject;
};

/** Taxable object discount. */
export type TaxableObjectDiscount = {
  /** The amount of the discount. */
  readonly amount: Money;
  /** The name of the discount. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Indicates which part of the order the discount should affect: SUBTOTAL or SHIPPING. */
  readonly type: TaxableObjectDiscountTypeEnum;
};

/** Indicates which part of the order the discount should affect: SUBTOTAL or SHIPPING. */
export type TaxableObjectDiscountTypeEnum =
  | 'SHIPPING'
  | 'SUBTOTAL';

export type TaxableObjectLine = {
  /** Determines if taxes are being charged for the product. */
  readonly chargeTaxes: Scalars['Boolean']['output'];
  /** The product name. */
  readonly productName: Scalars['String']['output'];
  /** The product sku. */
  readonly productSku?: Maybe<Scalars['String']['output']>;
  /** Number of items. */
  readonly quantity: Scalars['Int']['output'];
  /** The source line related to this tax line. */
  readonly sourceLine: TaxSourceLine;
  /** Price of the order line. The price includes catalogue promotions, specific product and applied once per order voucher discounts. The price does not include the entire order discount. */
  readonly totalPrice: Money;
  /** Price of the single item in the order line. The price includes catalogue promotions, specific product and applied once per order voucher discounts. The price does not include the entire order discount. */
  readonly unitPrice: Money;
  /** The variant name. */
  readonly variantName: Scalars['String']['output'];
};

/** Represents a monetary value with taxes. In cases where taxes were not applied, net and gross values will be equal. */
export type TaxedMoney = {
  /** Currency code. */
  readonly currency: Scalars['String']['output'];
  /** Amount of money including taxes. */
  readonly gross: Money;
  /** Amount of money without taxes. */
  readonly net: Money;
  /** Amount of taxes. */
  readonly tax: Money;
};

export type TaxedMoneyInput = {
  /** Gross value of an item. */
  readonly gross: Scalars['PositiveDecimal']['input'];
  /** Net value of an item. */
  readonly net: Scalars['PositiveDecimal']['input'];
};

/** Represents a range of monetary values. */
export type TaxedMoneyRange = {
  /** Lower bound of a price range. */
  readonly start?: Maybe<TaxedMoney>;
  /** Upper bound of a price range. */
  readonly stop?: Maybe<TaxedMoney>;
};

/** Event sent when thumbnail is created. */
export type ThumbnailCreated = Event & {
  /** Thumbnail id. */
  readonly id?: Maybe<Scalars['ID']['output']>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** Original media url. */
  readonly mediaUrl?: Maybe<Scalars['String']['output']>;
  /** Object the thumbnail refers to. */
  readonly objectId?: Maybe<Scalars['ID']['output']>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Thumbnail url. */
  readonly url?: Maybe<Scalars['String']['output']>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type ThumbnailFormatEnum =
  | 'AVIF'
  | 'ORIGINAL'
  | 'WEBP';

export type TimePeriod = {
  /** The length of the period. */
  readonly amount: Scalars['Int']['output'];
  /** The type of the period. */
  readonly type: TimePeriodTypeEnum;
};

export type TimePeriodInputType = {
  /** The length of the period. */
  readonly amount: Scalars['Int']['input'];
  /** The type of the period. */
  readonly type: TimePeriodTypeEnum;
};

export type TimePeriodTypeEnum =
  | 'DAY'
  | 'MONTH'
  | 'WEEK'
  | 'YEAR';

/**
 * Represents possible tokenized payment flows that can be used to process payment.
 *
 *     The following flows are possible:
 *     INTERACTIVE - Payment method can be used for 1 click checkout - it's prefilled in
 *     checkout form (might require additional authentication from user)
 */
export type TokenizedPaymentFlowEnum =
  | 'INTERACTIVE';

/** An object representing a single payment. */
export type Transaction = Node & {
  /** Total amount of the transaction. */
  readonly amount?: Maybe<Money>;
  /** Date and time at which transaction was created. */
  readonly created: Scalars['DateTime']['output'];
  /** Error associated with transaction, if any. */
  readonly error?: Maybe<Scalars['String']['output']>;
  /**
   * Response returned by payment gateway.
   * @deprecated This field is a part of a legacy Payments API. Please use apps instead.
   */
  readonly gatewayResponse: Scalars['JSONString']['output'];
  /** ID of the transaction. */
  readonly id: Scalars['ID']['output'];
  /** Determines if the transaction was successful. */
  readonly isSuccess: Scalars['Boolean']['output'];
  /** Determines the type of transaction. */
  readonly kind: TransactionKind;
  /** Determines the payment associated with a transaction. */
  readonly payment: Payment;
  /** Unique token associated with a transaction. */
  readonly token: Scalars['String']['output'];
};

export type TransactionAction = {
  /** Determines the action type. */
  readonly actionType: TransactionActionEnum;
  /** Transaction request amount. */
  readonly amount: Scalars['PositiveDecimal']['output'];
  /** Currency code. */
  readonly currency: Scalars['String']['output'];
};

/**
 * Represents possible actions on payment transaction.
 *
 *     The following actions are possible:
 *     CHARGE - Represents the charge action.
 *     REFUND - Represents a refund action.
 *     CANCEL - Represents a cancel action. Added in Saleor 3.12.
 */
export type TransactionActionEnum =
  | 'CANCEL'
  | 'CHARGE'
  | 'REFUND';

/** Event sent when transaction cancelation is requested. */
export type TransactionCancelationRequested = Event & {
  /** Requested action data. */
  readonly action: TransactionAction;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Look up a transaction. */
  readonly transaction?: Maybe<TransactionItem>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Event sent when transaction charge is requested. */
export type TransactionChargeRequested = Event & {
  /** Requested action data. */
  readonly action: TransactionAction;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Look up a transaction. */
  readonly transaction?: Maybe<TransactionItem>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Creates transaction for checkout or order.
 *
 * Requires one of the following permissions: HANDLE_PAYMENTS.
 */
export type TransactionCreate = {
  readonly errors: ReadonlyArray<TransactionCreateError>;
  readonly transaction?: Maybe<TransactionItem>;
};

export type TransactionCreateError = {
  /** The error code. */
  readonly code: TransactionCreateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type TransactionCreateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INCORRECT_CURRENCY'
  | 'INVALID'
  | 'METADATA_KEY_REQUIRED'
  | 'NOT_FOUND'
  | 'UNIQUE';

export type TransactionCreateInput = {
  /** Amount authorized by this transaction. */
  readonly amountAuthorized?: InputMaybe<MoneyInput>;
  /** Amount canceled by this transaction. */
  readonly amountCanceled?: InputMaybe<MoneyInput>;
  /** Amount charged by this transaction. */
  readonly amountCharged?: InputMaybe<MoneyInput>;
  /** Amount refunded by this transaction. */
  readonly amountRefunded?: InputMaybe<MoneyInput>;
  /** List of all possible actions for the transaction */
  readonly availableActions?: InputMaybe<ReadonlyArray<TransactionActionEnum>>;
  /** The url that will allow to redirect user to payment provider page with transaction event details. */
  readonly externalUrl?: InputMaybe<Scalars['String']['input']>;
  /** The message of the transaction. */
  readonly message?: InputMaybe<Scalars['String']['input']>;
  /**
   * Payment public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Payment name of the transaction. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Details of the payment method used for the transaction.
   *
   * Added in Saleor 3.22.
   */
  readonly paymentMethodDetails?: InputMaybe<PaymentMethodDetailsInput>;
  /**
   * Payment private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** PSP Reference of the transaction. */
  readonly pspReference?: InputMaybe<Scalars['String']['input']>;
};

/** Represents transaction's event. */
export type TransactionEvent = Node & {
  /** The amount related to this event. */
  readonly amount: Money;
  /** Date and time at which a transaction event was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** User or App that created the transaction event. */
  readonly createdBy?: Maybe<UserOrApp>;
  /** The url that will allow to redirect user to payment provider page with transaction details. */
  readonly externalUrl: Scalars['String']['output'];
  /** The ID of the object. */
  readonly id: Scalars['ID']['output'];
  /** Idempotency key assigned to the event. */
  readonly idempotencyKey?: Maybe<Scalars['String']['output']>;
  /** Message related to the transaction's event. */
  readonly message: Scalars['String']['output'];
  /** PSP reference of transaction. */
  readonly pspReference: Scalars['String']['output'];
  /**
   * Reason model of the transaction refund.
   *
   * Added in Saleor 3.22.
   */
  readonly reasonReference?: Maybe<Page>;
  /** The type of action related to this event. */
  readonly type?: Maybe<TransactionEventTypeEnum>;
};

export type TransactionEventInput = {
  /** The message related to the event. */
  readonly message?: InputMaybe<Scalars['String']['input']>;
  /** PSP Reference related to this action. */
  readonly pspReference?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Report the event for the transaction.
 *
 * Requires the following permissions: OWNER and HANDLE_PAYMENTS for apps, HANDLE_PAYMENTS for staff users. Staff user cannot update a transaction that is owned by the app.
 *
 * Triggers the following webhook events:
 * - TRANSACTION_ITEM_METADATA_UPDATED (async): Optionally called when transaction's metadata was updated.
 * - CHECKOUT_FULLY_PAID (async): Optionally called when the checkout charge status changed to `FULL` or `OVERCHARGED`.
 * - ORDER_UPDATED (async): Optionally called when the transaction is related to the order and the order was updated.
 */
export type TransactionEventReport = {
  /** Defines if the reported event hasn't been processed earlier. */
  readonly alreadyProcessed?: Maybe<Scalars['Boolean']['output']>;
  readonly errors: ReadonlyArray<TransactionEventReportError>;
  /** The transaction related to the reported event. */
  readonly transaction?: Maybe<TransactionItem>;
  /** The event assigned to this report. if `alreadyProcessed` is set to `true`, the previously processed event will be returned. */
  readonly transactionEvent?: Maybe<TransactionEvent>;
};

export type TransactionEventReportError = {
  /** The error code. */
  readonly code: TransactionEventReportErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type TransactionEventReportErrorCode =
  | 'ALREADY_EXISTS'
  | 'GRAPHQL_ERROR'
  | 'INCORRECT_DETAILS'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED';

/**
 * Represents possible event types.
 *
 *     Added in Saleor 3.12.
 *
 *     The following types are possible:
 *     AUTHORIZATION_SUCCESS - represents success authorization.
 *     AUTHORIZATION_FAILURE - represents failure authorization.
 *     AUTHORIZATION_ADJUSTMENT - represents authorization adjustment.
 *     AUTHORIZATION_REQUEST - represents authorization request.
 *     AUTHORIZATION_ACTION_REQUIRED - represents authorization that needs
 *     additional actions from the customer.
 *     CHARGE_ACTION_REQUIRED - represents charge that needs
 *     additional actions from the customer.
 *     CHARGE_SUCCESS - represents success charge.
 *     CHARGE_FAILURE - represents failure charge.
 *     CHARGE_BACK - represents chargeback.
 *     CHARGE_REQUEST - represents charge request.
 *     REFUND_SUCCESS - represents success refund.
 *     REFUND_FAILURE - represents failure refund.
 *     REFUND_REVERSE - represents reverse refund.
 *     REFUND_REQUEST - represents refund request.
 *     CANCEL_SUCCESS - represents success cancel.
 *     CANCEL_FAILURE - represents failure cancel.
 *     CANCEL_REQUEST - represents cancel request.
 *     INFO - represents info event.
 */
export type TransactionEventTypeEnum =
  | 'AUTHORIZATION_ACTION_REQUIRED'
  | 'AUTHORIZATION_ADJUSTMENT'
  | 'AUTHORIZATION_FAILURE'
  | 'AUTHORIZATION_REQUEST'
  | 'AUTHORIZATION_SUCCESS'
  | 'CANCEL_FAILURE'
  | 'CANCEL_REQUEST'
  | 'CANCEL_SUCCESS'
  | 'CHARGE_ACTION_REQUIRED'
  | 'CHARGE_BACK'
  | 'CHARGE_FAILURE'
  | 'CHARGE_REQUEST'
  | 'CHARGE_SUCCESS'
  | 'INFO'
  | 'REFUND_FAILURE'
  | 'REFUND_REQUEST'
  | 'REFUND_REVERSE'
  | 'REFUND_SUCCESS';

/** Filter input for transactions. */
export type TransactionFilterInput = {
  /** Filter by metadata fields of transactions. */
  readonly metadata?: InputMaybe<MetadataFilterInput>;
  /** Filter by payment method details used to pay for the order. */
  readonly paymentMethodDetails?: InputMaybe<PaymentMethodDetailsFilterInput>;
};

/**
 * Determine the transaction flow strategy.
 *
 *     AUTHORIZATION - the processed transaction should be only authorized
 *     CHARGE - the processed transaction should be charged.
 */
export type TransactionFlowStrategyEnum =
  | 'AUTHORIZATION'
  | 'CHARGE';

/** Initializes a transaction session. It triggers the webhook `TRANSACTION_INITIALIZE_SESSION`, to the requested `paymentGateways`. There is a limit of 100 transaction items per checkout / order. */
export type TransactionInitialize = {
  /** The JSON data required to finalize the payment. */
  readonly data?: Maybe<Scalars['JSON']['output']>;
  readonly errors: ReadonlyArray<TransactionInitializeError>;
  /** The initialized transaction. */
  readonly transaction?: Maybe<TransactionItem>;
  /** The event created for the initialized transaction. */
  readonly transactionEvent?: Maybe<TransactionEvent>;
};

export type TransactionInitializeError = {
  /** The error code. */
  readonly code: TransactionInitializeErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type TransactionInitializeErrorCode =
  | 'CHECKOUT_COMPLETION_IN_PROGRESS'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'UNIQUE';

/** Event sent when user starts processing the payment. */
export type TransactionInitializeSession = Event & {
  /** Action to proceed for the transaction */
  readonly action: TransactionProcessAction;
  /** The customer's IP address. If not provided as a parameter in the mutation, Saleor will try to determine the customer's IP address on its own. */
  readonly customerIpAddress?: Maybe<Scalars['String']['output']>;
  /** Payment gateway data in JSON format, received from storefront. */
  readonly data?: Maybe<Scalars['JSON']['output']>;
  /** Idempotency key assigned to the transaction initialize. */
  readonly idempotencyKey: Scalars['String']['output'];
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** Merchant reference assigned to this payment. */
  readonly merchantReference: Scalars['String']['output'];
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Checkout or order */
  readonly sourceObject: OrderOrCheckout;
  /** Look up a transaction. */
  readonly transaction: TransactionItem;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Represents a payment transaction. */
export type TransactionItem = Node & ObjectWithMetadata & {
  /** List of actions that can be performed in the current state of a payment. */
  readonly actions: ReadonlyArray<TransactionActionEnum>;
  /** Total amount of ongoing authorization requests for the transaction. */
  readonly authorizePendingAmount: Money;
  /** Total amount authorized for this payment. */
  readonly authorizedAmount: Money;
  /** Total amount of ongoing cancel requests for the transaction. */
  readonly cancelPendingAmount: Money;
  /** Total amount canceled for this payment. */
  readonly canceledAmount: Money;
  /** Total amount of ongoing charge requests for the transaction. */
  readonly chargePendingAmount: Money;
  /** Total amount charged for this payment. */
  readonly chargedAmount: Money;
  /** The related checkout. */
  readonly checkout?: Maybe<Checkout>;
  /** Date and time at which payment transaction was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** User or App that created the transaction. */
  readonly createdBy?: Maybe<UserOrApp>;
  /** List of all transaction's events. */
  readonly events: ReadonlyArray<TransactionEvent>;
  /** The url that will allow to redirect user to payment provider page with transaction details. */
  readonly externalUrl: Scalars['String']['output'];
  /** The ID of the object. */
  readonly id: Scalars['ID']['output'];
  /** Message related to the transaction. */
  readonly message: Scalars['String']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Date and time at which payment transaction was modified. */
  readonly modifiedAt: Scalars['DateTime']['output'];
  /** Name of the transaction. */
  readonly name: Scalars['String']['output'];
  /** The related order. */
  readonly order?: Maybe<Order>;
  /**
   * The payment method used for this transaction.
   *
   * Added in Saleor 3.22.
   */
  readonly paymentMethodDetails?: Maybe<PaymentMethodDetails>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** PSP reference of transaction. */
  readonly pspReference: Scalars['String']['output'];
  /**
   * Reason of the refund.
   *
   * Added in Saleor 3.22.
   */
  readonly reason?: Maybe<Scalars['String']['output']>;
  /**
   * Reason `Page` (Model) for refund.
   *
   * Added in Saleor 3.22.
   */
  readonly reasonReference?: Maybe<Page>;
  /** Total amount of ongoing refund requests for the transaction. */
  readonly refundPendingAmount: Money;
  /** Total amount refunded for this payment. */
  readonly refundedAmount: Money;
  /** The transaction token. */
  readonly token: Scalars['UUID']['output'];
};


/** Represents a payment transaction. */
export type TransactionItemMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a payment transaction. */
export type TransactionItemMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents a payment transaction. */
export type TransactionItemPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents a payment transaction. */
export type TransactionItemPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** Event sent when transaction item metadata is updated. */
export type TransactionItemMetadataUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Look up a transaction. */
  readonly transaction?: Maybe<TransactionItem>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type TransactionKind =
  | 'ACTION_TO_CONFIRM'
  | 'AUTH'
  | 'CANCEL'
  | 'CAPTURE'
  | 'CONFIRM'
  | 'EXTERNAL'
  | 'PENDING'
  | 'REFUND'
  | 'REFUND_ONGOING'
  | 'VOID';

/** Processes a transaction session. It triggers the webhook `TRANSACTION_PROCESS_SESSION`, to the assigned `paymentGateways`. */
export type TransactionProcess = {
  /** The json data required to finalize the payment. */
  readonly data?: Maybe<Scalars['JSON']['output']>;
  readonly errors: ReadonlyArray<TransactionProcessError>;
  /** The processed transaction. */
  readonly transaction?: Maybe<TransactionItem>;
  /** The event created for the processed transaction. */
  readonly transactionEvent?: Maybe<TransactionEvent>;
};

export type TransactionProcessAction = {
  readonly actionType: TransactionFlowStrategyEnum;
  /** Transaction amount to process. */
  readonly amount: Scalars['PositiveDecimal']['output'];
  /** Currency of the amount. */
  readonly currency: Scalars['String']['output'];
};

export type TransactionProcessError = {
  /** The error code. */
  readonly code: TransactionProcessErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type TransactionProcessErrorCode =
  | 'CHECKOUT_COMPLETION_IN_PROGRESS'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'MISSING_PAYMENT_APP'
  | 'MISSING_PAYMENT_APP_RELATION'
  | 'NOT_FOUND'
  | 'TRANSACTION_ALREADY_PROCESSED';

/** Event sent when user has additional payment action to process. */
export type TransactionProcessSession = Event & {
  /** Action to proceed for the transaction */
  readonly action: TransactionProcessAction;
  /** The customer's IP address. If not provided as a parameter in the mutation, Saleor will try to determine the customer's IP address on its own. */
  readonly customerIpAddress?: Maybe<Scalars['String']['output']>;
  /** Payment gateway data in JSON format, received from storefront. */
  readonly data?: Maybe<Scalars['JSON']['output']>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** Merchant reference assigned to this payment. */
  readonly merchantReference: Scalars['String']['output'];
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Checkout or order */
  readonly sourceObject: OrderOrCheckout;
  /** Look up a transaction. */
  readonly transaction: TransactionItem;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Event sent when transaction refund is requested. */
export type TransactionRefundRequested = Event & {
  /** Requested action data. */
  readonly action: TransactionAction;
  /**
   * Granted refund related to refund request.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly grantedRefund?: Maybe<OrderGrantedRefund>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Look up a transaction. */
  readonly transaction?: Maybe<TransactionItem>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Request an action for payment transaction.
 *
 * Requires one of the following permissions: HANDLE_PAYMENTS.
 */
export type TransactionRequestAction = {
  readonly errors: ReadonlyArray<TransactionRequestActionError>;
  readonly transaction?: Maybe<TransactionItem>;
};

export type TransactionRequestActionError = {
  /** The error code. */
  readonly code: TransactionRequestActionErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type TransactionRequestActionErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'MISSING_TRANSACTION_ACTION_REQUEST_WEBHOOK'
  | 'NOT_FOUND'
  | 'REQUIRED';

/**
 * Request a refund for payment transaction based on granted refund.
 *
 * Requires one of the following permissions: HANDLE_PAYMENTS.
 */
export type TransactionRequestRefundForGrantedRefund = {
  readonly errors: ReadonlyArray<TransactionRequestRefundForGrantedRefundError>;
  readonly transaction?: Maybe<TransactionItem>;
};

export type TransactionRequestRefundForGrantedRefundError = {
  /** The error code. */
  readonly code: TransactionRequestRefundForGrantedRefundErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type TransactionRequestRefundForGrantedRefundErrorCode =
  | 'AMOUNT_GREATER_THAN_AVAILABLE'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'MISSING_TRANSACTION_ACTION_REQUEST_WEBHOOK'
  | 'NOT_FOUND'
  | 'REFUND_ALREADY_PROCESSED'
  | 'REFUND_IS_PENDING';

/**
 * Update transaction.
 *
 * Requires the following permissions: OWNER and HANDLE_PAYMENTS for apps, HANDLE_PAYMENTS for staff users. Staff user cannot update a transaction that is owned by the app.
 */
export type TransactionUpdate = {
  readonly errors: ReadonlyArray<TransactionUpdateError>;
  readonly transaction?: Maybe<TransactionItem>;
};

export type TransactionUpdateError = {
  /** The error code. */
  readonly code: TransactionUpdateErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type TransactionUpdateErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INCORRECT_CURRENCY'
  | 'INVALID'
  | 'METADATA_KEY_REQUIRED'
  | 'NOT_FOUND'
  | 'UNIQUE';

export type TransactionUpdateInput = {
  /** Amount authorized by this transaction. */
  readonly amountAuthorized?: InputMaybe<MoneyInput>;
  /** Amount canceled by this transaction. */
  readonly amountCanceled?: InputMaybe<MoneyInput>;
  /** Amount charged by this transaction. */
  readonly amountCharged?: InputMaybe<MoneyInput>;
  /** Amount refunded by this transaction. */
  readonly amountRefunded?: InputMaybe<MoneyInput>;
  /** List of all possible actions for the transaction */
  readonly availableActions?: InputMaybe<ReadonlyArray<TransactionActionEnum>>;
  /** The url that will allow to redirect user to payment provider page with transaction event details. */
  readonly externalUrl?: InputMaybe<Scalars['String']['input']>;
  /** The message of the transaction. */
  readonly message?: InputMaybe<Scalars['String']['input']>;
  /**
   * Payment public metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Payment name of the transaction. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Details of the payment method used for the transaction.
   *
   * Added in Saleor 3.22.
   */
  readonly paymentMethodDetails?: InputMaybe<PaymentMethodDetailsInput>;
  /**
   * Payment private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** PSP Reference of the transaction. */
  readonly pspReference?: InputMaybe<Scalars['String']['input']>;
};

export type TranslatableItem = AttributeTranslatableContent | AttributeValueTranslatableContent | CategoryTranslatableContent | CollectionTranslatableContent | MenuItemTranslatableContent | PageTranslatableContent | ProductTranslatableContent | ProductVariantTranslatableContent | PromotionRuleTranslatableContent | PromotionTranslatableContent | SaleTranslatableContent | ShippingMethodTranslatableContent | VoucherTranslatableContent;

export type TranslatableItemConnection = {
  readonly edges: ReadonlyArray<TranslatableItemEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TranslatableItemEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: TranslatableItem;
};

export type TranslatableKinds =
  | 'ATTRIBUTE'
  | 'ATTRIBUTE_VALUE'
  | 'CATEGORY'
  | 'COLLECTION'
  | 'MENU_ITEM'
  | 'PAGE'
  | 'PRODUCT'
  | 'PROMOTION'
  | 'PROMOTION_RULE'
  | 'SALE'
  | 'SHIPPING_METHOD'
  | 'VARIANT'
  | 'VOUCHER';

/** Event sent when new translation is created. */
export type TranslationCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The translation the event relates to. */
  readonly translation?: Maybe<TranslationTypes>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type TranslationError = {
  /** The error code. */
  readonly code: TranslationErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type TranslationErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type TranslationInput = {
  /**
   * Translated description.
   *
   * Rich text format. For reference see https://editorjs.io/
   */
  readonly description?: InputMaybe<Scalars['JSONString']['input']>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
  readonly seoDescription?: InputMaybe<Scalars['String']['input']>;
  readonly seoTitle?: InputMaybe<Scalars['String']['input']>;
  readonly slug?: InputMaybe<Scalars['String']['input']>;
};

export type TranslationTypes = AttributeTranslation | AttributeValueTranslation | CategoryTranslation | CollectionTranslation | MenuItemTranslation | PageTranslation | ProductTranslation | ProductVariantTranslation | PromotionRuleTranslation | PromotionTranslation | SaleTranslation | ShippingMethodTranslation | VoucherTranslation;

/** Event sent when translation is updated. */
export type TranslationUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** The translation the event relates to. */
  readonly translation?: Maybe<TranslationTypes>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** Define the filtering options for string fields. */
export type UuidFilterInput = {
  /** The value equal to. */
  readonly eq?: InputMaybe<Scalars['UUID']['input']>;
  /** The value included in. */
  readonly oneOf?: InputMaybe<ReadonlyArray<Scalars['UUID']['input']>>;
};

export type UpdateInvoiceInput = {
  /**
   * Fields required to update the invoice metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** Invoice number */
  readonly number?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the invoice private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** URL of an invoice to download. */
  readonly url?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Updates metadata of an object.Requires permissions to modify and to read the metadata of the object it's attached to.
 *
 * Warning: never store sensitive information, including financial data such as credit card details.
 */
export type UpdateMetadata = {
  readonly errors: ReadonlyArray<MetadataError>;
  readonly item?: Maybe<ObjectWithMetadata>;
  /** @deprecated Use `errors` field instead. */
  readonly metadataErrors: ReadonlyArray<MetadataError>;
};

/**
 * Updates private metadata of an object. Requires permissions to modify and to read the metadata of the object it's attached to.
 *
 * Warning: never store sensitive information, including financial data such as credit card details.
 */
export type UpdatePrivateMetadata = {
  readonly errors: ReadonlyArray<MetadataError>;
  readonly item?: Maybe<ObjectWithMetadata>;
  /** @deprecated Use `errors` field instead. */
  readonly metadataErrors: ReadonlyArray<MetadataError>;
};

export type UploadError = {
  /** The error code. */
  readonly code: UploadErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type UploadErrorCode =
  | 'GRAPHQL_ERROR';

/** Represents user data. */
export type User = Node & ObjectWithMetadata & {
  /** List of channels the user has access to. The sum of channels from all user groups. If at least one group has `restrictedAccessToChannels` set to False - all channels are returned. */
  readonly accessibleChannels?: Maybe<ReadonlyArray<Channel>>;
  /** List of all user's addresses. */
  readonly addresses: ReadonlyArray<Address>;
  /** The avatar of the user. */
  readonly avatar?: Maybe<Image>;
  /**
   * Returns the last open checkout of this user.
   * @deprecated Use the `checkoutTokens` field to fetch the user checkouts.
   */
  readonly checkout?: Maybe<Checkout>;
  /** Returns the checkout ID's assigned to this user. */
  readonly checkoutIds?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
  /**
   * Returns the checkout UUID's assigned to this user.
   * @deprecated Use `checkoutIds` instead.
   */
  readonly checkoutTokens?: Maybe<ReadonlyArray<Scalars['UUID']['output']>>;
  /** Returns checkouts assigned to this user. The query will not initiate any external requests, including fetching external shipping methods, filtering available shipping methods, or performing external tax calculations. */
  readonly checkouts?: Maybe<CheckoutCountableConnection>;
  /** The data when the user create account. */
  readonly dateJoined: Scalars['DateTime']['output'];
  /** The default billing address of the user. */
  readonly defaultBillingAddress?: Maybe<Address>;
  /** The default shipping address of the user. */
  readonly defaultShippingAddress?: Maybe<Address>;
  /** List of user's permission groups which user can manage. */
  readonly editableGroups?: Maybe<ReadonlyArray<Group>>;
  /** The email address of the user. */
  readonly email: Scalars['String']['output'];
  /**
   * List of events associated with the user.
   *
   * Requires one of the following permissions: MANAGE_USERS, MANAGE_STAFF.
   */
  readonly events?: Maybe<ReadonlyArray<CustomerEvent>>;
  /** External ID of this user. */
  readonly externalReference?: Maybe<Scalars['String']['output']>;
  /** The given name of the address. */
  readonly firstName: Scalars['String']['output'];
  /** List of the user gift cards. */
  readonly giftCards?: Maybe<GiftCardCountableConnection>;
  /** The ID of the user. */
  readonly id: Scalars['ID']['output'];
  /** Determine if the user is active. */
  readonly isActive: Scalars['Boolean']['output'];
  /** Determines if user has confirmed email. */
  readonly isConfirmed: Scalars['Boolean']['output'];
  /** Determine if the user is a staff admin. */
  readonly isStaff: Scalars['Boolean']['output'];
  /** User language code. */
  readonly languageCode: LanguageCodeEnum;
  /** The date when the user last time log in to the system. */
  readonly lastLogin?: Maybe<Scalars['DateTime']['output']>;
  /** The family name of the address. */
  readonly lastName: Scalars['String']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /**
   * A note about the customer.
   *
   * Requires one of the following permissions: MANAGE_USERS, MANAGE_STAFF.
   */
  readonly note?: Maybe<Scalars['String']['output']>;
  /** List of user's orders. The query will not initiate any external requests, including filtering available shipping methods, or performing external tax calculations. Requires one of the following permissions: MANAGE_STAFF, OWNER. */
  readonly orders?: Maybe<OrderCountableConnection>;
  /** List of user's permission groups. */
  readonly permissionGroups?: Maybe<ReadonlyArray<Group>>;
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Determine if user have restricted access to channels. False if at least one user group has `restrictedAccessToChannels` set to False. */
  readonly restrictedAccessToChannels: Scalars['Boolean']['output'];
  /** Returns a list of user's stored payment methods that can be used in provided channel. The field returns a list of stored payment methods by payment apps. When `amount` is not provided, 0 will be used as default value. */
  readonly storedPaymentMethods?: Maybe<ReadonlyArray<StoredPaymentMethod>>;
  /** List of stored payment sources. The field returns a list of payment sources stored for payment plugins. */
  readonly storedPaymentSources?: Maybe<ReadonlyArray<PaymentSource>>;
  /** The data when the user last update the account information. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** List of user's permissions. */
  readonly userPermissions?: Maybe<ReadonlyArray<UserPermission>>;
};


/** Represents user data. */
export type UserAvatarArgs = {
  format?: InputMaybe<ThumbnailFormatEnum>;
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents user data. */
export type UserCheckoutIdsArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};


/** Represents user data. */
export type UserCheckoutTokensArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};


/** Represents user data. */
export type UserCheckoutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  channel?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents user data. */
export type UserGiftCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents user data. */
export type UserMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents user data. */
export type UserMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents user data. */
export type UserOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents user data. */
export type UserPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents user data. */
export type UserPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents user data. */
export type UserStoredPaymentMethodsArgs = {
  channel: Scalars['String']['input'];
};


/** Represents user data. */
export type UserStoredPaymentSourcesArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Deletes a user avatar. Only for staff members.
 *
 * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
 */
export type UserAvatarDelete = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  /** An updated user instance. */
  readonly user?: Maybe<User>;
};

/**
 * Create a user avatar. Only for staff members. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec
 *
 * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
 */
export type UserAvatarUpdate = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  /** An updated user instance. */
  readonly user?: Maybe<User>;
};

/**
 * Activate or deactivate users.
 *
 * Requires one of the following permissions: MANAGE_USERS.
 */
export type UserBulkSetActive = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<AccountError>;
};

export type UserCountableConnection = {
  readonly edges: ReadonlyArray<UserCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type UserCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: User;
};

export type UserCreateInput = {
  /** Slug of a channel which will be used for notify user. Optional when only one channel exists. */
  readonly channel?: InputMaybe<Scalars['String']['input']>;
  /** Billing address of the customer. */
  readonly defaultBillingAddress?: InputMaybe<AddressInput>;
  /** Shipping address of the customer. */
  readonly defaultShippingAddress?: InputMaybe<AddressInput>;
  /** The unique email address of the user. */
  readonly email?: InputMaybe<Scalars['String']['input']>;
  /** External ID of the customer. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** Given name. */
  readonly firstName?: InputMaybe<Scalars['String']['input']>;
  /** User account is active. */
  readonly isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * User account is confirmed.
   * @deprecated The user will be always set as unconfirmed. The confirmation will take place when the user sets the password.
   */
  readonly isConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  /** User language code. */
  readonly languageCode?: InputMaybe<LanguageCodeEnum>;
  /** Family name. */
  readonly lastName?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the user metadata. Can be read by any API client authorized to read the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** A note about the user. */
  readonly note?: InputMaybe<Scalars['String']['input']>;
  /**
   * Fields required to update the user private metadata. Requires permissions to modify and to read the metadata of the object it's attached to.
   *
   * Warning: never store sensitive information, including financial data such as credit card details.
   */
  readonly privateMetadata?: InputMaybe<ReadonlyArray<MetadataInput>>;
  /** URL of a view where users should be redirected to set the password. URL in RFC 1808 format. */
  readonly redirectUrl?: InputMaybe<Scalars['String']['input']>;
};

export type UserOrApp = App | User;

/** Represents user's permissions. */
export type UserPermission = {
  /** Internal code for permission. */
  readonly code: PermissionEnum;
  /** Describe action(s) allowed to do by permission. */
  readonly name: Scalars['String']['output'];
  /** List of user permission groups which contains this permission. */
  readonly sourcePermissionGroups?: Maybe<ReadonlyArray<Group>>;
};


/** Represents user's permissions. */
export type UserPermissionSourcePermissionGroupsArgs = {
  userId: Scalars['ID']['input'];
};

export type UserSortField =
  /** Sort users by created at. */
  | 'CREATED_AT'
  /** Sort users by email. */
  | 'EMAIL'
  /** Sort users by first name. */
  | 'FIRST_NAME'
  /** Sort users by last modified at. */
  | 'LAST_MODIFIED_AT'
  /** Sort users by last name. */
  | 'LAST_NAME'
  /** Sort users by order count. */
  | 'ORDER_COUNT';

export type UserSortingInput = {
  /** Specifies the direction in which to sort users. */
  readonly direction: OrderDirection;
  /** Sort users by the selected field. */
  readonly field: UserSortField;
};

/** Represents a VAT rate for a country. */
export type Vat = {
  /** Country code. */
  readonly countryCode: Scalars['String']['output'];
  /** Country's VAT rate exceptions for specific types of goods. */
  readonly reducedRates: ReadonlyArray<ReducedRate>;
  /** Standard VAT rate in percent. */
  readonly standardRate?: Maybe<Scalars['Float']['output']>;
};

export type VariantAttributeScope =
  | 'ALL'
  | 'NOT_VARIANT_SELECTION'
  | 'VARIANT_SELECTION';

/**
 * Assign an media to a product variant.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type VariantMediaAssign = {
  readonly errors: ReadonlyArray<ProductError>;
  readonly media?: Maybe<ProductMedia>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  readonly productVariant?: Maybe<ProductVariant>;
};

/**
 * Unassign an media from a product variant.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type VariantMediaUnassign = {
  readonly errors: ReadonlyArray<ProductError>;
  readonly media?: Maybe<ProductMedia>;
  /** @deprecated Use `errors` field instead. */
  readonly productErrors: ReadonlyArray<ProductError>;
  readonly productVariant?: Maybe<ProductVariant>;
};

/** Represents availability of a variant in the storefront. */
export type VariantPricingInfo = {
  /** The discount amount if in sale (null otherwise). */
  readonly discount?: Maybe<TaxedMoney>;
  /**
   * The discount amount in the local currency.
   * @deprecated Always returns `null`.
   */
  readonly discountLocalCurrency?: Maybe<TaxedMoney>;
  /**
   * The discount amount compared to prior price. Null if product is not on sale or prior price was not provided in VariantChannelListing
   *
   * Added in Saleor 3.21.
   */
  readonly discountPrior?: Maybe<TaxedMoney>;
  /** Whether it is in sale or not. */
  readonly onSale?: Maybe<Scalars['Boolean']['output']>;
  /** The price, with any discount subtracted. */
  readonly price?: Maybe<TaxedMoney>;
  /**
   * The discounted price in the local currency.
   * @deprecated Always returns `null`.
   */
  readonly priceLocalCurrency?: Maybe<TaxedMoney>;
  /**
   * The price prior to discount.
   *
   * Added in Saleor 3.21.
   */
  readonly pricePrior?: Maybe<TaxedMoney>;
  /** The price without any discount. */
  readonly priceUndiscounted?: Maybe<TaxedMoney>;
};

/** Verify JWT token. */
export type VerifyToken = {
  /** @deprecated Use `errors` field instead. */
  readonly accountErrors: ReadonlyArray<AccountError>;
  readonly errors: ReadonlyArray<AccountError>;
  /** Determine if token is valid or not. */
  readonly isValid: Scalars['Boolean']['output'];
  /** JWT payload. */
  readonly payload?: Maybe<Scalars['GenericScalar']['output']>;
  /** User assigned to token. */
  readonly user?: Maybe<User>;
};

export type VolumeUnitsEnum =
  | 'ACRE_FT'
  | 'ACRE_IN'
  | 'CUBIC_CENTIMETER'
  | 'CUBIC_DECIMETER'
  | 'CUBIC_FOOT'
  | 'CUBIC_INCH'
  | 'CUBIC_METER'
  | 'CUBIC_MILLIMETER'
  | 'CUBIC_YARD'
  | 'FL_OZ'
  | 'LITER'
  | 'PINT'
  | 'QT';

/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type Voucher = Node & ObjectWithMetadata & {
  /** Determine if the voucher usage should be limited to one use per customer. */
  readonly applyOncePerCustomer: Scalars['Boolean']['output'];
  /** Determine if the voucher should be applied once per order. If set to True, the voucher is applied to a single cheapest eligible product in checkout. */
  readonly applyOncePerOrder: Scalars['Boolean']['output'];
  /** List of categories this voucher applies to. */
  readonly categories?: Maybe<CategoryCountableConnection>;
  /**
   * List of availability in channels for the voucher.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  readonly channelListings?: Maybe<ReadonlyArray<VoucherChannelListing>>;
  /** The code of the voucher. */
  readonly code?: Maybe<Scalars['String']['output']>;
  /**
   * List of codes available for this voucher.
   *
   * Added in Saleor 3.18.
   */
  readonly codes?: Maybe<VoucherCodeCountableConnection>;
  /**
   * List of collections this voucher applies to.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  readonly collections?: Maybe<CollectionCountableConnection>;
  /** List of countries available for the shipping voucher. */
  readonly countries?: Maybe<ReadonlyArray<CountryDisplay>>;
  /** Currency code for voucher. */
  readonly currency?: Maybe<Scalars['String']['output']>;
  /** Voucher value. */
  readonly discountValue?: Maybe<Scalars['Float']['output']>;
  /** Determines a type of discount for voucher - value or percentage */
  readonly discountValueType: DiscountValueTypeEnum;
  /** The end date and time of voucher. */
  readonly endDate?: Maybe<Scalars['DateTime']['output']>;
  /** The ID of the voucher. */
  readonly id: Scalars['ID']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Determine minimum quantity of items for checkout. */
  readonly minCheckoutItemsQuantity?: Maybe<Scalars['Int']['output']>;
  /** Minimum order value to apply voucher. */
  readonly minSpent?: Maybe<Money>;
  /** The name of the voucher. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Determine if the voucher is available only for staff members. */
  readonly onlyForStaff: Scalars['Boolean']['output'];
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /**
   * List of products this voucher applies to.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  readonly products?: Maybe<ProductCountableConnection>;
  /**
   * Determine if the voucher codes can be used once or multiple times.
   *
   * Added in Saleor 3.18.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly singleUse: Scalars['Boolean']['output'];
  /** The start date and time of voucher. */
  readonly startDate: Scalars['DateTime']['output'];
  /** Returns translated voucher fields for the given language code. */
  readonly translation?: Maybe<VoucherTranslation>;
  /** Determines a type of voucher. */
  readonly type: VoucherTypeEnum;
  /** The number of times a voucher can be used. */
  readonly usageLimit?: Maybe<Scalars['Int']['output']>;
  /** Usage count of the voucher. */
  readonly used: Scalars['Int']['output'];
  /**
   * List of product variants this voucher applies to.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   */
  readonly variants?: Maybe<ProductVariantCountableConnection>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherCategoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherCodesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherCollectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherPrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherPrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherTranslationArgs = {
  languageCode: LanguageCodeEnum;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * Adds products, categories, collections to a voucher.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_UPDATED (async): A voucher was updated.
 */
export type VoucherAddCatalogues = {
  /** @deprecated Use `errors` field instead. */
  readonly discountErrors: ReadonlyArray<DiscountError>;
  readonly errors: ReadonlyArray<DiscountError>;
  /** Voucher of which catalogue IDs will be modified. */
  readonly voucher?: Maybe<Voucher>;
};

/**
 * Deletes vouchers.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_DELETED (async): A voucher was deleted.
 */
export type VoucherBulkDelete = {
  /** Returns how many objects were affected. */
  readonly count: Scalars['Int']['output'];
  /** @deprecated Use `errors` field instead. */
  readonly discountErrors: ReadonlyArray<DiscountError>;
  readonly errors: ReadonlyArray<DiscountError>;
};

/** Represents voucher channel listing. */
export type VoucherChannelListing = Node & {
  /** The channel in which voucher can be applied. */
  readonly channel: Channel;
  /** Currency code for voucher in a channel. */
  readonly currency: Scalars['String']['output'];
  /** The value of the discount on voucher in a channel. */
  readonly discountValue: Scalars['Float']['output'];
  /** The ID of channel listing. */
  readonly id: Scalars['ID']['output'];
  /** Minimum order value for voucher to apply in channel. */
  readonly minSpent?: Maybe<Money>;
};

export type VoucherChannelListingAddInput = {
  /** ID of a channel. */
  readonly channelId: Scalars['ID']['input'];
  /** Value of the voucher. */
  readonly discountValue?: InputMaybe<Scalars['PositiveDecimal']['input']>;
  /** Min purchase amount required to apply the voucher. */
  readonly minAmountSpent?: InputMaybe<Scalars['PositiveDecimal']['input']>;
};

export type VoucherChannelListingInput = {
  /** List of channels to which the voucher should be assigned. */
  readonly addChannels?: InputMaybe<ReadonlyArray<VoucherChannelListingAddInput>>;
  /** List of channels from which the voucher should be unassigned. */
  readonly removeChannels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/**
 * Manage voucher's availability in channels.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_UPDATED (async): A voucher was updated.
 */
export type VoucherChannelListingUpdate = {
  /** @deprecated Use `errors` field instead. */
  readonly discountErrors: ReadonlyArray<DiscountError>;
  readonly errors: ReadonlyArray<DiscountError>;
  /** An updated voucher instance. */
  readonly voucher?: Maybe<Voucher>;
};

/**
 * Represents voucher code.
 *
 * Added in Saleor 3.18.
 *
 * Note: this API is currently in Feature Preview and can be subject to changes at later point.
 */
export type VoucherCode = {
  /** Code to use the voucher. */
  readonly code?: Maybe<Scalars['String']['output']>;
  /** Date time of code creation. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The ID of the voucher code. */
  readonly id: Scalars['ID']['output'];
  /** Whether a code is active or not. */
  readonly isActive?: Maybe<Scalars['Boolean']['output']>;
  /** Number of times a code has been used. */
  readonly used?: Maybe<Scalars['Int']['output']>;
};

/**
 * Deletes voucher codes.
 *
 * Added in Saleor 3.18.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_CODES_DELETED (async): A voucher codes were deleted.
 */
export type VoucherCodeBulkDelete = {
  /** Returns how many codes were deleted. */
  readonly count: Scalars['Int']['output'];
  readonly errors: ReadonlyArray<VoucherCodeBulkDeleteError>;
};

export type VoucherCodeBulkDeleteError = {
  /** The error code. */
  readonly code: VoucherCodeBulkDeleteErrorCode;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** Path to field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly path?: Maybe<Scalars['String']['output']>;
  /** List of voucher codes which causes the error. */
  readonly voucherCodes?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

export type VoucherCodeBulkDeleteErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND';

export type VoucherCodeCountableConnection = {
  readonly edges: ReadonlyArray<VoucherCodeCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type VoucherCodeCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: VoucherCode;
};

/**
 * Event sent when voucher code export is completed.
 *
 * Added in Saleor 3.18.
 */
export type VoucherCodeExportCompleted = Event & {
  /** The export file for voucher codes. */
  readonly export?: Maybe<ExportFile>;
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
};

/**
 * Event sent when new voucher codes were created.
 *
 * Added in Saleor 3.19.
 */
export type VoucherCodesCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
  /** The voucher codes the event relates to. */
  readonly voucherCodes?: Maybe<ReadonlyArray<VoucherCode>>;
};

/**
 * Event sent when voucher codes were deleted.
 *
 * Added in Saleor 3.19.
 */
export type VoucherCodesDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
  /** The voucher codes the event relates to. */
  readonly voucherCodes?: Maybe<ReadonlyArray<VoucherCode>>;
};

export type VoucherCountableConnection = {
  readonly edges: ReadonlyArray<VoucherCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type VoucherCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Voucher;
};

/**
 * Creates a new voucher.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_CREATED (async): A voucher was created.
 * - VOUCHER_CODES_CREATED (async): A voucher codes were created.
 */
export type VoucherCreate = {
  /** @deprecated Use `errors` field instead. */
  readonly discountErrors: ReadonlyArray<DiscountError>;
  readonly errors: ReadonlyArray<DiscountError>;
  readonly voucher?: Maybe<Voucher>;
};

/** Event sent when new voucher is created. */
export type VoucherCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
  /** The voucher the event relates to. */
  readonly voucher?: Maybe<Voucher>;
};


/** Event sent when new voucher is created. */
export type VoucherCreatedVoucherArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Deletes a voucher.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_DELETED (async): A voucher was deleted.
 */
export type VoucherDelete = {
  /** @deprecated Use `errors` field instead. */
  readonly discountErrors: ReadonlyArray<DiscountError>;
  readonly errors: ReadonlyArray<DiscountError>;
  readonly voucher?: Maybe<Voucher>;
};

/** Event sent when voucher is deleted. */
export type VoucherDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
  /** The voucher the event relates to. */
  readonly voucher?: Maybe<Voucher>;
};


/** Event sent when voucher is deleted. */
export type VoucherDeletedVoucherArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

export type VoucherDiscountType =
  | 'FIXED'
  | 'PERCENTAGE'
  | 'SHIPPING';

export type VoucherFilterInput = {
  readonly discountType?: InputMaybe<ReadonlyArray<VoucherDiscountType>>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly started?: InputMaybe<DateTimeRangeInput>;
  readonly status?: InputMaybe<ReadonlyArray<DiscountStatusEnum>>;
  readonly timesUsed?: InputMaybe<IntRangeInput>;
};

export type VoucherInput = {
  /**
   * List of codes to add.
   *
   * Added in Saleor 3.18.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly addCodes?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** Voucher should be applied once per customer. */
  readonly applyOncePerCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  /** Voucher should be applied to the cheapest item or entire order. */
  readonly applyOncePerOrder?: InputMaybe<Scalars['Boolean']['input']>;
  /** Categories discounted by the voucher. */
  readonly categories?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /**
   * Code to use the voucher.
   * @deprecated Use `addCodes` instead.
   */
  readonly code?: InputMaybe<Scalars['String']['input']>;
  /** Collections discounted by the voucher. */
  readonly collections?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Country codes that can be used with the shipping voucher. */
  readonly countries?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** Choices: fixed or percentage. */
  readonly discountValueType?: InputMaybe<DiscountValueTypeEnum>;
  /** End date of the voucher in ISO 8601 format. */
  readonly endDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Minimal quantity of checkout items required to apply the voucher. */
  readonly minCheckoutItemsQuantity?: InputMaybe<Scalars['Int']['input']>;
  /** Voucher name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Voucher can be used only by staff user. */
  readonly onlyForStaff?: InputMaybe<Scalars['Boolean']['input']>;
  /** Products discounted by the voucher. */
  readonly products?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /**
   * When set to 'True', each voucher code can be used only once; otherwise, codes can be used multiple times depending on `usageLimit`.
   *
   * The option can only be changed if none of the voucher codes have been used.
   *
   * Added in Saleor 3.18.
   *
   * Note: this API is currently in Feature Preview and can be subject to changes at later point.
   */
  readonly singleUse?: InputMaybe<Scalars['Boolean']['input']>;
  /** Start date of the voucher in ISO 8601 format. */
  readonly startDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Voucher type: PRODUCT, CATEGORY SHIPPING or ENTIRE_ORDER. */
  readonly type?: InputMaybe<VoucherTypeEnum>;
  /** Limit number of times this voucher can be used in total. */
  readonly usageLimit?: InputMaybe<Scalars['Int']['input']>;
  /** Variants discounted by the voucher. */
  readonly variants?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/** Event sent when voucher metadata is updated. */
export type VoucherMetadataUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
  /** The voucher the event relates to. */
  readonly voucher?: Maybe<Voucher>;
};


/** Event sent when voucher metadata is updated. */
export type VoucherMetadataUpdatedVoucherArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Removes products, categories, collections from a voucher.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_UPDATED (async): A voucher was updated.
 */
export type VoucherRemoveCatalogues = {
  /** @deprecated Use `errors` field instead. */
  readonly discountErrors: ReadonlyArray<DiscountError>;
  readonly errors: ReadonlyArray<DiscountError>;
  /** Voucher of which catalogue IDs will be modified. */
  readonly voucher?: Maybe<Voucher>;
};

export type VoucherSortField =
  /** Sort vouchers by code. */
  | 'CODE'
  /** Sort vouchers by end date. */
  | 'END_DATE'
  /**
   * Sort vouchers by minimum spent amount.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'MINIMUM_SPENT_AMOUNT'
  /**
   * Sort vouchers by name.
   *
   * Added in Saleor 3.18.
   */
  | 'NAME'
  /** Sort vouchers by start date. */
  | 'START_DATE'
  /** Sort vouchers by type. */
  | 'TYPE'
  /** Sort vouchers by usage limit. */
  | 'USAGE_LIMIT'
  /**
   * Sort vouchers by value.
   *
   * This option requires a channel filter to work as the values can vary between channels.
   */
  | 'VALUE';

export type VoucherSortingInput = {
  /**
   * Specifies the channel in which to sort the data.
   * @deprecated Use root-level channel argument instead.
   */
  readonly channel?: InputMaybe<Scalars['String']['input']>;
  /** Specifies the direction in which to sort vouchers. */
  readonly direction: OrderDirection;
  /** Sort vouchers by the selected field. */
  readonly field: VoucherSortField;
};

/** Represents voucher's original translatable fields and related translations. */
export type VoucherTranslatableContent = Node & {
  /** The ID of the voucher translatable content. */
  readonly id: Scalars['ID']['output'];
  /** Voucher name to translate. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Returns translated voucher fields for the given language code. */
  readonly translation?: Maybe<VoucherTranslation>;
  /**
   * Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes.
   *
   * Requires one of the following permissions: MANAGE_DISCOUNTS.
   * @deprecated Get model fields from the root level queries.
   */
  readonly voucher?: Maybe<Voucher>;
  /** The ID of the voucher to translate. */
  readonly voucherId: Scalars['ID']['output'];
};


/** Represents voucher's original translatable fields and related translations. */
export type VoucherTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/**
 * Creates/updates translations for a voucher.
 *
 * Requires one of the following permissions: MANAGE_TRANSLATIONS.
 */
export type VoucherTranslate = {
  readonly errors: ReadonlyArray<TranslationError>;
  /** @deprecated Use `errors` field instead. */
  readonly translationErrors: ReadonlyArray<TranslationError>;
  readonly voucher?: Maybe<Voucher>;
};

/** Represents voucher translations. */
export type VoucherTranslation = Node & {
  /** The ID of the voucher translation. */
  readonly id: Scalars['ID']['output'];
  /** Translation language. */
  readonly language: LanguageDisplay;
  /** Translated voucher name. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Represents the voucher fields to translate. */
  readonly translatableContent?: Maybe<VoucherTranslatableContent>;
};

export type VoucherTypeEnum =
  | 'ENTIRE_ORDER'
  | 'SHIPPING'
  | 'SPECIFIC_PRODUCT';

/**
 * Updates a voucher.
 *
 * Requires one of the following permissions: MANAGE_DISCOUNTS.
 *
 * Triggers the following webhook events:
 * - VOUCHER_UPDATED (async): A voucher was updated.
 * - VOUCHER_CODES_CREATED (async): A voucher code was created.
 */
export type VoucherUpdate = {
  /** @deprecated Use `errors` field instead. */
  readonly discountErrors: ReadonlyArray<DiscountError>;
  readonly errors: ReadonlyArray<DiscountError>;
  readonly voucher?: Maybe<Voucher>;
};

/** Event sent when voucher is updated. */
export type VoucherUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
  /** The voucher the event relates to. */
  readonly voucher?: Maybe<Voucher>;
};


/** Event sent when voucher is updated. */
export type VoucherUpdatedVoucherArgs = {
  channel?: InputMaybe<Scalars['String']['input']>;
};

/** Represents warehouse. */
export type Warehouse = Node & ObjectWithMetadata & {
  /** Address of the warehouse. */
  readonly address: Address;
  /** Click and collect options: local, all or disabled. */
  readonly clickAndCollectOption: WarehouseClickAndCollectOptionEnum;
  /**
   * Warehouse company name.
   * @deprecated Use `Address.companyName` instead.
   */
  readonly companyName: Scalars['String']['output'];
  /** Warehouse email. */
  readonly email: Scalars['String']['output'];
  /** External ID of this warehouse. */
  readonly externalReference?: Maybe<Scalars['String']['output']>;
  /** The ID of the warehouse. */
  readonly id: Scalars['ID']['output'];
  /** Determine if the warehouse is private. */
  readonly isPrivate: Scalars['Boolean']['output'];
  /** List of public metadata items. Can be accessed without permissions. */
  readonly metadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly metafield?: Maybe<Scalars['String']['output']>;
  /** Public metadata. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly metafields?: Maybe<Scalars['Metadata']['output']>;
  /** Warehouse name. */
  readonly name: Scalars['String']['output'];
  /** List of private metadata items. Requires staff permissions to access. */
  readonly privateMetadata: ReadonlyArray<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   */
  readonly privateMetafield?: Maybe<Scalars['String']['output']>;
  /** Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything. */
  readonly privateMetafields?: Maybe<Scalars['Metadata']['output']>;
  /** Shipping zones supported by the warehouse. */
  readonly shippingZones: ShippingZoneCountableConnection;
  /** Warehouse slug. */
  readonly slug: Scalars['String']['output'];
  /**
   * Stocks that belong to this warehouse.
   *
   * Added in Saleor 3.20.
   *
   * Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS.
   */
  readonly stocks?: Maybe<StockCountableConnection>;
};


/** Represents warehouse. */
export type WarehouseMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents warehouse. */
export type WarehouseMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents warehouse. */
export type WarehousePrivateMetafieldArgs = {
  key: Scalars['String']['input'];
};


/** Represents warehouse. */
export type WarehousePrivateMetafieldsArgs = {
  keys?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** Represents warehouse. */
export type WarehouseShippingZonesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents warehouse. */
export type WarehouseStocksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type WarehouseClickAndCollectOptionEnum =
  | 'ALL'
  | 'DISABLED'
  | 'LOCAL';

export type WarehouseCountableConnection = {
  readonly edges: ReadonlyArray<WarehouseCountableEdge>;
  /** Pagination data for this connection. */
  readonly pageInfo: PageInfo;
  /** A total count of items in the collection. */
  readonly totalCount?: Maybe<Scalars['Int']['output']>;
};

export type WarehouseCountableEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node: Warehouse;
};

/**
 * Creates a new warehouse.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type WarehouseCreate = {
  readonly errors: ReadonlyArray<WarehouseError>;
  readonly warehouse?: Maybe<Warehouse>;
  /** @deprecated Use `errors` field instead. */
  readonly warehouseErrors: ReadonlyArray<WarehouseError>;
};

export type WarehouseCreateInput = {
  /** Address of the warehouse. */
  readonly address: AddressInput;
  /** The email address of the warehouse. */
  readonly email?: InputMaybe<Scalars['String']['input']>;
  /** External ID of the warehouse. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** Warehouse name. */
  readonly name: Scalars['String']['input'];
  /**
   * Shipping zones supported by the warehouse.
   * @deprecated Providing the zone ids will raise a ValidationError.
   */
  readonly shippingZones?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Warehouse slug. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when new warehouse is created. */
export type WarehouseCreated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
  /** The warehouse the event relates to. */
  readonly warehouse?: Maybe<Warehouse>;
};

/**
 * Deletes selected warehouse.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type WarehouseDelete = {
  readonly errors: ReadonlyArray<WarehouseError>;
  readonly warehouse?: Maybe<Warehouse>;
  /** @deprecated Use `errors` field instead. */
  readonly warehouseErrors: ReadonlyArray<WarehouseError>;
};

/** Event sent when warehouse is deleted. */
export type WarehouseDeleted = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
  /** The warehouse the event relates to. */
  readonly warehouse?: Maybe<Warehouse>;
};

export type WarehouseError = {
  /** The error code. */
  readonly code: WarehouseErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** List of shipping zones IDs which causes the error. */
  readonly shippingZones?: Maybe<ReadonlyArray<Scalars['ID']['output']>>;
};

export type WarehouseErrorCode =
  | 'ALREADY_EXISTS'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'UNIQUE';

export type WarehouseFilterInput = {
  readonly channels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly clickAndCollectOption?: InputMaybe<WarehouseClickAndCollectOptionEnum>;
  readonly ids?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  readonly metadata?: InputMaybe<ReadonlyArray<MetadataFilter>>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly slugs?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** Event sent when warehouse metadata is updated. */
export type WarehouseMetadataUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
  /** The warehouse the event relates to. */
  readonly warehouse?: Maybe<Warehouse>;
};

/**
 * Add shipping zone to given warehouse.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type WarehouseShippingZoneAssign = {
  readonly errors: ReadonlyArray<WarehouseError>;
  readonly warehouse?: Maybe<Warehouse>;
  /** @deprecated Use `errors` field instead. */
  readonly warehouseErrors: ReadonlyArray<WarehouseError>;
};

/**
 * Remove shipping zone from given warehouse.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type WarehouseShippingZoneUnassign = {
  readonly errors: ReadonlyArray<WarehouseError>;
  readonly warehouse?: Maybe<Warehouse>;
  /** @deprecated Use `errors` field instead. */
  readonly warehouseErrors: ReadonlyArray<WarehouseError>;
};

export type WarehouseSortField =
  /** Sort warehouses by name. */
  | 'NAME';

export type WarehouseSortingInput = {
  /** Specifies the direction in which to sort warehouses. */
  readonly direction: OrderDirection;
  /** Sort warehouses by the selected field. */
  readonly field: WarehouseSortField;
};

/**
 * Updates given warehouse.
 *
 * Requires one of the following permissions: MANAGE_PRODUCTS.
 */
export type WarehouseUpdate = {
  readonly errors: ReadonlyArray<WarehouseError>;
  readonly warehouse?: Maybe<Warehouse>;
  /** @deprecated Use `errors` field instead. */
  readonly warehouseErrors: ReadonlyArray<WarehouseError>;
};

export type WarehouseUpdateInput = {
  /** Address of the warehouse. */
  readonly address?: InputMaybe<AddressInput>;
  /** Click and collect options: local, all or disabled. */
  readonly clickAndCollectOption?: InputMaybe<WarehouseClickAndCollectOptionEnum>;
  /** The email address of the warehouse. */
  readonly email?: InputMaybe<Scalars['String']['input']>;
  /** External ID of the warehouse. */
  readonly externalReference?: InputMaybe<Scalars['String']['input']>;
  /** Visibility of warehouse stocks. */
  readonly isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  /** Warehouse name. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Warehouse slug. */
  readonly slug?: InputMaybe<Scalars['String']['input']>;
};

/** Event sent when warehouse is updated. */
export type WarehouseUpdated = Event & {
  /** Time of the event. */
  readonly issuedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user or application that triggered the event. */
  readonly issuingPrincipal?: Maybe<IssuingPrincipal>;
  /** The application receiving the webhook. */
  readonly recipient?: Maybe<App>;
  /** Saleor version that triggered the event. */
  readonly version?: Maybe<Scalars['String']['output']>;
  /** The warehouse the event relates to. */
  readonly warehouse?: Maybe<Warehouse>;
};

/** Webhook. */
export type Webhook = Node & {
  /** The app associated with Webhook. */
  readonly app: App;
  /** List of asynchronous webhook events. */
  readonly asyncEvents: ReadonlyArray<WebhookEventAsync>;
  /** Custom headers, which will be added to HTTP request. */
  readonly customHeaders?: Maybe<Scalars['JSONString']['output']>;
  /** Event deliveries. */
  readonly eventDeliveries?: Maybe<EventDeliveryCountableConnection>;
  /**
   * List of webhook events.
   * @deprecated Use `asyncEvents` or `syncEvents` instead.
   */
  readonly events: ReadonlyArray<WebhookEvent>;
  /** The ID of webhook. */
  readonly id: Scalars['ID']['output'];
  /** Informs if webhook is activated. */
  readonly isActive: Scalars['Boolean']['output'];
  /** The name of webhook. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /**
   * Used to create a hash signature for each payload.
   * @deprecated As of Saleor 3.5, webhook payloads default to signing using a verifiable JWS.
   */
  readonly secretKey?: Maybe<Scalars['String']['output']>;
  /** Used to define payloads for specific events. */
  readonly subscriptionQuery?: Maybe<Scalars['String']['output']>;
  /** List of synchronous webhook events. */
  readonly syncEvents: ReadonlyArray<WebhookEventSync>;
  /** Target URL for webhook. */
  readonly targetUrl: Scalars['String']['output'];
};


/** Webhook. */
export type WebhookEventDeliveriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EventDeliveryFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<EventDeliverySortingInput>;
};

/**
 * Creates a new webhook subscription.
 *
 * Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP.
 */
export type WebhookCreate = {
  readonly errors: ReadonlyArray<WebhookError>;
  readonly webhook?: Maybe<Webhook>;
  /** @deprecated Use `errors` field instead. */
  readonly webhookErrors: ReadonlyArray<WebhookError>;
};

export type WebhookCreateInput = {
  /** ID of the app to which webhook belongs. */
  readonly app?: InputMaybe<Scalars['ID']['input']>;
  /** The asynchronous events that webhook wants to subscribe. */
  readonly asyncEvents?: InputMaybe<ReadonlyArray<WebhookEventTypeAsyncEnum>>;
  /** Custom headers, which will be added to HTTP request. There is a limitation of 5 headers per webhook and 998 characters per header.Only `X-*`, `Authorization*`, and `BrokerProperties` keys are allowed. */
  readonly customHeaders?: InputMaybe<Scalars['JSONString']['input']>;
  /**
   * The events that webhook wants to subscribe.
   * @deprecated Use `asyncEvents` or `syncEvents` instead.
   */
  readonly events?: InputMaybe<ReadonlyArray<WebhookEventTypeEnum>>;
  /** Determine if webhook will be set active or not. */
  readonly isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of the webhook. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Subscription query used to define a webhook payload. */
  readonly query?: InputMaybe<Scalars['String']['input']>;
  /**
   * The secret key used to create a hash signature with each payload.
   * @deprecated As of Saleor 3.5, webhook payloads default to signing using a verifiable JWS.
   */
  readonly secretKey?: InputMaybe<Scalars['String']['input']>;
  /** The synchronous events that webhook wants to subscribe. */
  readonly syncEvents?: InputMaybe<ReadonlyArray<WebhookEventTypeSyncEnum>>;
  /** The url to receive the payload. */
  readonly targetUrl?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Deletes a webhook. Before the deletion, the webhook is deactivated to pause any deliveries that are already scheduled. The deletion might fail if delivery is in progress. In such a case, the webhook is not deleted but remains deactivated.
 *
 * Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP.
 */
export type WebhookDelete = {
  readonly errors: ReadonlyArray<WebhookError>;
  readonly webhook?: Maybe<Webhook>;
  /** @deprecated Use `errors` field instead. */
  readonly webhookErrors: ReadonlyArray<WebhookError>;
};

/**
 * Performs a dry run of a webhook event. Supports a single event (the first, if multiple provided in the `query`). Requires permission relevant to processed event.
 *
 * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
 */
export type WebhookDryRun = {
  readonly errors: ReadonlyArray<WebhookDryRunError>;
  /** JSON payload, that would be sent out to webhook's target URL. */
  readonly payload?: Maybe<Scalars['JSONString']['output']>;
};

export type WebhookDryRunError = {
  /** The error code. */
  readonly code: WebhookDryRunErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type WebhookDryRunErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID_ID'
  | 'MISSING_EVENT'
  | 'MISSING_PERMISSION'
  | 'MISSING_SUBSCRIPTION'
  | 'NOT_FOUND'
  | 'SYNTAX'
  | 'TYPE_NOT_SUPPORTED'
  | 'UNABLE_TO_PARSE';

export type WebhookError = {
  /** The error code. */
  readonly code: WebhookErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type WebhookErrorCode =
  | 'DELETE_FAILED'
  | 'GRAPHQL_ERROR'
  | 'INVALID'
  | 'INVALID_CUSTOM_HEADERS'
  | 'INVALID_NOTIFY_WITH_SUBSCRIPTION'
  | 'MISSING_EVENT'
  | 'MISSING_SUBSCRIPTION'
  | 'NOT_FOUND'
  | 'REQUIRED'
  | 'SYNTAX'
  | 'UNABLE_TO_PARSE'
  | 'UNIQUE';

/** Webhook event. */
export type WebhookEvent = {
  /** Internal name of the event type. */
  readonly eventType: WebhookEventTypeEnum;
  /** Display name of the event. */
  readonly name: Scalars['String']['output'];
};

/** Asynchronous webhook event. */
export type WebhookEventAsync = {
  /** Internal name of the event type. */
  readonly eventType: WebhookEventTypeAsyncEnum;
  /** Display name of the event. */
  readonly name: Scalars['String']['output'];
};

/** Synchronous webhook event. */
export type WebhookEventSync = {
  /** Internal name of the event type. */
  readonly eventType: WebhookEventTypeSyncEnum;
  /** Display name of the event. */
  readonly name: Scalars['String']['output'];
};

/** Enum determining type of webhook. */
export type WebhookEventTypeAsyncEnum =
  /** An account email change is requested. */
  | 'ACCOUNT_CHANGE_EMAIL_REQUESTED'
  /** An account confirmation is requested. */
  | 'ACCOUNT_CONFIRMATION_REQUESTED'
  /** An account is confirmed. */
  | 'ACCOUNT_CONFIRMED'
  /** An account is deleted. */
  | 'ACCOUNT_DELETED'
  /** An account delete is requested. */
  | 'ACCOUNT_DELETE_REQUESTED'
  /** An account email was changed */
  | 'ACCOUNT_EMAIL_CHANGED'
  /** Setting a new password for the account is requested. */
  | 'ACCOUNT_SET_PASSWORD_REQUESTED'
  /** A new address created. */
  | 'ADDRESS_CREATED'
  /** An address deleted. */
  | 'ADDRESS_DELETED'
  /** An address updated. */
  | 'ADDRESS_UPDATED'
  /** All the events. */
  | 'ANY_EVENTS'
  /** An app deleted. */
  | 'APP_DELETED'
  /** A new app installed. */
  | 'APP_INSTALLED'
  /** An app status is changed. */
  | 'APP_STATUS_CHANGED'
  /** An app updated. */
  | 'APP_UPDATED'
  /** A new attribute is created. */
  | 'ATTRIBUTE_CREATED'
  /** An attribute is deleted. */
  | 'ATTRIBUTE_DELETED'
  /** An attribute is updated. */
  | 'ATTRIBUTE_UPDATED'
  /** A new attribute value is created. */
  | 'ATTRIBUTE_VALUE_CREATED'
  /** An attribute value is deleted. */
  | 'ATTRIBUTE_VALUE_DELETED'
  /** An attribute value is updated. */
  | 'ATTRIBUTE_VALUE_UPDATED'
  /** A new category created. */
  | 'CATEGORY_CREATED'
  /** A category is deleted. */
  | 'CATEGORY_DELETED'
  /** A category is updated. */
  | 'CATEGORY_UPDATED'
  /** A new channel created. */
  | 'CHANNEL_CREATED'
  /** A channel is deleted. */
  | 'CHANNEL_DELETED'
  /** A channel metadata is updated. */
  | 'CHANNEL_METADATA_UPDATED'
  /** A channel status is changed. */
  | 'CHANNEL_STATUS_CHANGED'
  /** A channel is updated. */
  | 'CHANNEL_UPDATED'
  /** A new checkout is created. */
  | 'CHECKOUT_CREATED'
  /**
   * A checkout was fully authorized (its `authorizeStatus` is `FULL`).
   *
   * This event is emitted only for checkouts whose payments are processed through the Transaction API.
   */
  | 'CHECKOUT_FULLY_AUTHORIZED'
  /**
   * A checkout was fully paid (its `chargeStatus` is `FULL` or `OVERCHARGED`). This event is not sent if payments are only authorized but not fully charged.
   *
   * This event is emitted only for checkouts whose payments are processed through the Transaction API.
   */
  | 'CHECKOUT_FULLY_PAID'
  /** A checkout metadata is updated. */
  | 'CHECKOUT_METADATA_UPDATED'
  /** A checkout is updated. It also triggers all updates related to the checkout. */
  | 'CHECKOUT_UPDATED'
  /** A new collection is created. */
  | 'COLLECTION_CREATED'
  /** A collection is deleted. */
  | 'COLLECTION_DELETED'
  /** A collection metadata is updated. */
  | 'COLLECTION_METADATA_UPDATED'
  /** A collection is updated. */
  | 'COLLECTION_UPDATED'
  /** A new customer account is created. */
  | 'CUSTOMER_CREATED'
  /** A customer account is deleted. */
  | 'CUSTOMER_DELETED'
  /** A customer account metadata is updated. */
  | 'CUSTOMER_METADATA_UPDATED'
  /** A customer account is updated. */
  | 'CUSTOMER_UPDATED'
  /** A draft order is created. */
  | 'DRAFT_ORDER_CREATED'
  /** A draft order is deleted. */
  | 'DRAFT_ORDER_DELETED'
  /** A draft order is updated. */
  | 'DRAFT_ORDER_UPDATED'
  /** A fulfillment is approved. */
  | 'FULFILLMENT_APPROVED'
  /** A fulfillment is cancelled. */
  | 'FULFILLMENT_CANCELED'
  /** A new fulfillment is created. */
  | 'FULFILLMENT_CREATED'
  /** A fulfillment metadata is updated. */
  | 'FULFILLMENT_METADATA_UPDATED'
  | 'FULFILLMENT_TRACKING_NUMBER_UPDATED'
  /** A new gift card created. */
  | 'GIFT_CARD_CREATED'
  /** A gift card is deleted. */
  | 'GIFT_CARD_DELETED'
  /** A gift card export is completed. */
  | 'GIFT_CARD_EXPORT_COMPLETED'
  /** A gift card metadata is updated. */
  | 'GIFT_CARD_METADATA_UPDATED'
  /** A gift card has been sent. */
  | 'GIFT_CARD_SENT'
  /** A gift card status is changed. */
  | 'GIFT_CARD_STATUS_CHANGED'
  /** A gift card is updated. */
  | 'GIFT_CARD_UPDATED'
  /** An invoice is deleted. */
  | 'INVOICE_DELETED'
  /** An invoice for order requested. */
  | 'INVOICE_REQUESTED'
  /** Invoice has been sent. */
  | 'INVOICE_SENT'
  /** A new menu created. */
  | 'MENU_CREATED'
  /** A menu is deleted. */
  | 'MENU_DELETED'
  /** A new menu item created. */
  | 'MENU_ITEM_CREATED'
  /** A menu item is deleted. */
  | 'MENU_ITEM_DELETED'
  /** A menu item is updated. */
  | 'MENU_ITEM_UPDATED'
  /** A menu is updated. */
  | 'MENU_UPDATED'
  /** User notification triggered. */
  | 'NOTIFY_USER'
  /** An observability event is created. */
  | 'OBSERVABILITY'
  /** Orders are imported. */
  | 'ORDER_BULK_CREATED'
  /** An order is cancelled. */
  | 'ORDER_CANCELLED'
  /** An order is confirmed (status change unconfirmed -> unfulfilled) by a staff user using the OrderConfirm mutation. It also triggers when the user completes the checkout and the shop setting `automatically_confirm_all_new_orders` is enabled. */
  | 'ORDER_CONFIRMED'
  /** A new order is placed. */
  | 'ORDER_CREATED'
  /** An order is expired. */
  | 'ORDER_EXPIRED'
  /** An order is fulfilled. */
  | 'ORDER_FULFILLED'
  /** Payment is made and an order is fully paid. */
  | 'ORDER_FULLY_PAID'
  /** The order is fully refunded. */
  | 'ORDER_FULLY_REFUNDED'
  /** An order metadata is updated. */
  | 'ORDER_METADATA_UPDATED'
  /** Payment has been made. The order may be partially or fully paid. */
  | 'ORDER_PAID'
  /** The order received a refund. The order may be partially or fully refunded. */
  | 'ORDER_REFUNDED'
  /** An order is updated; triggered for all changes related to an order; covers all other order webhooks, except for ORDER_CREATED. */
  | 'ORDER_UPDATED'
  /** A new page is created. */
  | 'PAGE_CREATED'
  /** A page is deleted. */
  | 'PAGE_DELETED'
  /** A new page type is created. */
  | 'PAGE_TYPE_CREATED'
  /** A page type is deleted. */
  | 'PAGE_TYPE_DELETED'
  /** A page type is updated. */
  | 'PAGE_TYPE_UPDATED'
  /** A page is updated. */
  | 'PAGE_UPDATED'
  /** A new permission group is created. */
  | 'PERMISSION_GROUP_CREATED'
  /** A permission group is deleted. */
  | 'PERMISSION_GROUP_DELETED'
  /** A permission group is updated. */
  | 'PERMISSION_GROUP_UPDATED'
  /** A new product is created. */
  | 'PRODUCT_CREATED'
  /** A product is deleted. */
  | 'PRODUCT_DELETED'
  /** A product export is completed. */
  | 'PRODUCT_EXPORT_COMPLETED'
  /** A new product media is created. */
  | 'PRODUCT_MEDIA_CREATED'
  /** A product media is deleted. */
  | 'PRODUCT_MEDIA_DELETED'
  /** A product media is updated. */
  | 'PRODUCT_MEDIA_UPDATED'
  /** A product metadata is updated. */
  | 'PRODUCT_METADATA_UPDATED'
  /** A product is updated. */
  | 'PRODUCT_UPDATED'
  /** A product variant is back in stock. */
  | 'PRODUCT_VARIANT_BACK_IN_STOCK'
  /** A new product variant is created. */
  | 'PRODUCT_VARIANT_CREATED'
  /** A product variant is deleted. Warning: this event will not be executed when parent product has been deleted. Check PRODUCT_DELETED. */
  | 'PRODUCT_VARIANT_DELETED'
  /** A product variant metadata is updated. */
  | 'PRODUCT_VARIANT_METADATA_UPDATED'
  /** A product variant is out of stock. */
  | 'PRODUCT_VARIANT_OUT_OF_STOCK'
  /** A product variant stock is updated */
  | 'PRODUCT_VARIANT_STOCK_UPDATED'
  /** A product variant is updated. */
  | 'PRODUCT_VARIANT_UPDATED'
  /** A promotion is created. */
  | 'PROMOTION_CREATED'
  /** A promotion is deleted. */
  | 'PROMOTION_DELETED'
  /** A promotion is deactivated. */
  | 'PROMOTION_ENDED'
  /** A promotion rule is created. */
  | 'PROMOTION_RULE_CREATED'
  /** A promotion rule is deleted. */
  | 'PROMOTION_RULE_DELETED'
  /** A promotion rule is updated. */
  | 'PROMOTION_RULE_UPDATED'
  /** A promotion is activated. */
  | 'PROMOTION_STARTED'
  /** A promotion is updated. */
  | 'PROMOTION_UPDATED'
  /** A sale is created. */
  | 'SALE_CREATED'
  /** A sale is deleted. */
  | 'SALE_DELETED'
  /** A sale is activated or deactivated. */
  | 'SALE_TOGGLE'
  /** A sale is updated. */
  | 'SALE_UPDATED'
  /** A new shipping price is created. */
  | 'SHIPPING_PRICE_CREATED'
  /** A shipping price is deleted. */
  | 'SHIPPING_PRICE_DELETED'
  /** A shipping price is updated. */
  | 'SHIPPING_PRICE_UPDATED'
  /** A new shipping zone is created. */
  | 'SHIPPING_ZONE_CREATED'
  /** A shipping zone is deleted. */
  | 'SHIPPING_ZONE_DELETED'
  /** A shipping zone metadata is updated. */
  | 'SHIPPING_ZONE_METADATA_UPDATED'
  /** A shipping zone is updated. */
  | 'SHIPPING_ZONE_UPDATED'
  /** Shop metadata is updated. */
  | 'SHOP_METADATA_UPDATED'
  /** A new staff user is created. */
  | 'STAFF_CREATED'
  /** A staff user is deleted. */
  | 'STAFF_DELETED'
  /** Setting a new password for the staff account is requested. */
  | 'STAFF_SET_PASSWORD_REQUESTED'
  /** A staff user is updated. */
  | 'STAFF_UPDATED'
  /** A thumbnail is created. */
  | 'THUMBNAIL_CREATED'
  /** Transaction item metadata is updated. */
  | 'TRANSACTION_ITEM_METADATA_UPDATED'
  /** A new translation is created. */
  | 'TRANSLATION_CREATED'
  /** A translation is updated. */
  | 'TRANSLATION_UPDATED'
  | 'VOUCHER_CODES_CREATED'
  | 'VOUCHER_CODES_DELETED'
  /**
   * A voucher code export is completed.
   *
   * Added in Saleor 3.18.
   */
  | 'VOUCHER_CODE_EXPORT_COMPLETED'
  /** A new voucher created. */
  | 'VOUCHER_CREATED'
  /** A voucher is deleted. */
  | 'VOUCHER_DELETED'
  /** A voucher metadata is updated. */
  | 'VOUCHER_METADATA_UPDATED'
  /** A voucher is updated. */
  | 'VOUCHER_UPDATED'
  /** A new warehouse created. */
  | 'WAREHOUSE_CREATED'
  /** A warehouse is deleted. */
  | 'WAREHOUSE_DELETED'
  /** A warehouse metadata is updated. */
  | 'WAREHOUSE_METADATA_UPDATED'
  /** A warehouse is updated. */
  | 'WAREHOUSE_UPDATED';

/** Enum determining type of webhook. */
export type WebhookEventTypeEnum =
  /** An account email change is requested. */
  | 'ACCOUNT_CHANGE_EMAIL_REQUESTED'
  /** An account confirmation is requested. */
  | 'ACCOUNT_CONFIRMATION_REQUESTED'
  /** An account is confirmed. */
  | 'ACCOUNT_CONFIRMED'
  /** An account is deleted. */
  | 'ACCOUNT_DELETED'
  /** An account delete is requested. */
  | 'ACCOUNT_DELETE_REQUESTED'
  /** An account email was changed */
  | 'ACCOUNT_EMAIL_CHANGED'
  /** Setting a new password for the account is requested. */
  | 'ACCOUNT_SET_PASSWORD_REQUESTED'
  /** A new address created. */
  | 'ADDRESS_CREATED'
  /** An address deleted. */
  | 'ADDRESS_DELETED'
  /** An address updated. */
  | 'ADDRESS_UPDATED'
  /** All the events. */
  | 'ANY_EVENTS'
  /** An app deleted. */
  | 'APP_DELETED'
  /** A new app installed. */
  | 'APP_INSTALLED'
  /** An app status is changed. */
  | 'APP_STATUS_CHANGED'
  /** An app updated. */
  | 'APP_UPDATED'
  /** A new attribute is created. */
  | 'ATTRIBUTE_CREATED'
  /** An attribute is deleted. */
  | 'ATTRIBUTE_DELETED'
  /** An attribute is updated. */
  | 'ATTRIBUTE_UPDATED'
  /** A new attribute value is created. */
  | 'ATTRIBUTE_VALUE_CREATED'
  /** An attribute value is deleted. */
  | 'ATTRIBUTE_VALUE_DELETED'
  /** An attribute value is updated. */
  | 'ATTRIBUTE_VALUE_UPDATED'
  /** A new category created. */
  | 'CATEGORY_CREATED'
  /** A category is deleted. */
  | 'CATEGORY_DELETED'
  /** A category is updated. */
  | 'CATEGORY_UPDATED'
  /** A new channel created. */
  | 'CHANNEL_CREATED'
  /** A channel is deleted. */
  | 'CHANNEL_DELETED'
  /** A channel metadata is updated. */
  | 'CHANNEL_METADATA_UPDATED'
  /** A channel status is changed. */
  | 'CHANNEL_STATUS_CHANGED'
  /** A channel is updated. */
  | 'CHANNEL_UPDATED'
  /** Event called for checkout tax calculation. */
  | 'CHECKOUT_CALCULATE_TAXES'
  /** A new checkout is created. */
  | 'CHECKOUT_CREATED'
  /** Filter shipping methods for checkout. */
  | 'CHECKOUT_FILTER_SHIPPING_METHODS'
  /**
   * A checkout was fully authorized (its `authorizeStatus` is `FULL`).
   *
   * This event is emitted only for checkouts whose payments are processed through the Transaction API.
   */
  | 'CHECKOUT_FULLY_AUTHORIZED'
  /**
   * A checkout was fully paid (its `chargeStatus` is `FULL` or `OVERCHARGED`). This event is not sent if payments are only authorized but not fully charged.
   *
   * This event is emitted only for checkouts whose payments are processed through the Transaction API.
   */
  | 'CHECKOUT_FULLY_PAID'
  /** A checkout metadata is updated. */
  | 'CHECKOUT_METADATA_UPDATED'
  /** A checkout is updated. It also triggers all updates related to the checkout. */
  | 'CHECKOUT_UPDATED'
  /** A new collection is created. */
  | 'COLLECTION_CREATED'
  /** A collection is deleted. */
  | 'COLLECTION_DELETED'
  /** A collection metadata is updated. */
  | 'COLLECTION_METADATA_UPDATED'
  /** A collection is updated. */
  | 'COLLECTION_UPDATED'
  /** A new customer account is created. */
  | 'CUSTOMER_CREATED'
  /** A customer account is deleted. */
  | 'CUSTOMER_DELETED'
  /** A customer account metadata is updated. */
  | 'CUSTOMER_METADATA_UPDATED'
  /** A customer account is updated. */
  | 'CUSTOMER_UPDATED'
  /** A draft order is created. */
  | 'DRAFT_ORDER_CREATED'
  /** A draft order is deleted. */
  | 'DRAFT_ORDER_DELETED'
  /** A draft order is updated. */
  | 'DRAFT_ORDER_UPDATED'
  /** A fulfillment is approved. */
  | 'FULFILLMENT_APPROVED'
  /** A fulfillment is cancelled. */
  | 'FULFILLMENT_CANCELED'
  /** A new fulfillment is created. */
  | 'FULFILLMENT_CREATED'
  /** A fulfillment metadata is updated. */
  | 'FULFILLMENT_METADATA_UPDATED'
  | 'FULFILLMENT_TRACKING_NUMBER_UPDATED'
  /** A new gift card created. */
  | 'GIFT_CARD_CREATED'
  /** A gift card is deleted. */
  | 'GIFT_CARD_DELETED'
  /** A gift card export is completed. */
  | 'GIFT_CARD_EXPORT_COMPLETED'
  /** A gift card metadata is updated. */
  | 'GIFT_CARD_METADATA_UPDATED'
  /** A gift card has been sent. */
  | 'GIFT_CARD_SENT'
  /** A gift card status is changed. */
  | 'GIFT_CARD_STATUS_CHANGED'
  /** A gift card is updated. */
  | 'GIFT_CARD_UPDATED'
  /** An invoice is deleted. */
  | 'INVOICE_DELETED'
  /** An invoice for order requested. */
  | 'INVOICE_REQUESTED'
  /** Invoice has been sent. */
  | 'INVOICE_SENT'
  | 'LIST_STORED_PAYMENT_METHODS'
  /** A new menu created. */
  | 'MENU_CREATED'
  /** A menu is deleted. */
  | 'MENU_DELETED'
  /** A new menu item created. */
  | 'MENU_ITEM_CREATED'
  /** A menu item is deleted. */
  | 'MENU_ITEM_DELETED'
  /** A menu item is updated. */
  | 'MENU_ITEM_UPDATED'
  /** A menu is updated. */
  | 'MENU_UPDATED'
  /** User notification triggered. */
  | 'NOTIFY_USER'
  /** An observability event is created. */
  | 'OBSERVABILITY'
  /** Orders are imported. */
  | 'ORDER_BULK_CREATED'
  /** Event called for order tax calculation. */
  | 'ORDER_CALCULATE_TAXES'
  /** An order is cancelled. */
  | 'ORDER_CANCELLED'
  /** An order is confirmed (status change unconfirmed -> unfulfilled) by a staff user using the OrderConfirm mutation. It also triggers when the user completes the checkout and the shop setting `automatically_confirm_all_new_orders` is enabled. */
  | 'ORDER_CONFIRMED'
  /** A new order is placed. */
  | 'ORDER_CREATED'
  /** An order is expired. */
  | 'ORDER_EXPIRED'
  /** Filter shipping methods for order. */
  | 'ORDER_FILTER_SHIPPING_METHODS'
  /** An order is fulfilled. */
  | 'ORDER_FULFILLED'
  /** Payment is made and an order is fully paid. */
  | 'ORDER_FULLY_PAID'
  /** The order is fully refunded. */
  | 'ORDER_FULLY_REFUNDED'
  /** An order metadata is updated. */
  | 'ORDER_METADATA_UPDATED'
  /** Payment has been made. The order may be partially or fully paid. */
  | 'ORDER_PAID'
  /** The order received a refund. The order may be partially or fully refunded. */
  | 'ORDER_REFUNDED'
  /** An order is updated; triggered for all changes related to an order; covers all other order webhooks, except for ORDER_CREATED. */
  | 'ORDER_UPDATED'
  /** A new page is created. */
  | 'PAGE_CREATED'
  /** A page is deleted. */
  | 'PAGE_DELETED'
  /** A new page type is created. */
  | 'PAGE_TYPE_CREATED'
  /** A page type is deleted. */
  | 'PAGE_TYPE_DELETED'
  /** A page type is updated. */
  | 'PAGE_TYPE_UPDATED'
  /** A page is updated. */
  | 'PAGE_UPDATED'
  /** Authorize payment. */
  | 'PAYMENT_AUTHORIZE'
  /** Capture payment. */
  | 'PAYMENT_CAPTURE'
  /** Confirm payment. */
  | 'PAYMENT_CONFIRM'
  | 'PAYMENT_GATEWAY_INITIALIZE_SESSION'
  | 'PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION'
  /** Listing available payment gateways. */
  | 'PAYMENT_LIST_GATEWAYS'
  | 'PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION'
  | 'PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION'
  /** Process payment. */
  | 'PAYMENT_PROCESS'
  /** Refund payment. */
  | 'PAYMENT_REFUND'
  /** Void payment. */
  | 'PAYMENT_VOID'
  /** A new permission group is created. */
  | 'PERMISSION_GROUP_CREATED'
  /** A permission group is deleted. */
  | 'PERMISSION_GROUP_DELETED'
  /** A permission group is updated. */
  | 'PERMISSION_GROUP_UPDATED'
  /** A new product is created. */
  | 'PRODUCT_CREATED'
  /** A product is deleted. */
  | 'PRODUCT_DELETED'
  /** A product export is completed. */
  | 'PRODUCT_EXPORT_COMPLETED'
  /** A new product media is created. */
  | 'PRODUCT_MEDIA_CREATED'
  /** A product media is deleted. */
  | 'PRODUCT_MEDIA_DELETED'
  /** A product media is updated. */
  | 'PRODUCT_MEDIA_UPDATED'
  /** A product metadata is updated. */
  | 'PRODUCT_METADATA_UPDATED'
  /** A product is updated. */
  | 'PRODUCT_UPDATED'
  /** A product variant is back in stock. */
  | 'PRODUCT_VARIANT_BACK_IN_STOCK'
  /** A new product variant is created. */
  | 'PRODUCT_VARIANT_CREATED'
  /** A product variant is deleted. Warning: this event will not be executed when parent product has been deleted. Check PRODUCT_DELETED. */
  | 'PRODUCT_VARIANT_DELETED'
  /** A product variant metadata is updated. */
  | 'PRODUCT_VARIANT_METADATA_UPDATED'
  /** A product variant is out of stock. */
  | 'PRODUCT_VARIANT_OUT_OF_STOCK'
  /** A product variant stock is updated */
  | 'PRODUCT_VARIANT_STOCK_UPDATED'
  /** A product variant is updated. */
  | 'PRODUCT_VARIANT_UPDATED'
  /** A promotion is created. */
  | 'PROMOTION_CREATED'
  /** A promotion is deleted. */
  | 'PROMOTION_DELETED'
  /** A promotion is deactivated. */
  | 'PROMOTION_ENDED'
  /** A promotion rule is created. */
  | 'PROMOTION_RULE_CREATED'
  /** A promotion rule is deleted. */
  | 'PROMOTION_RULE_DELETED'
  /** A promotion rule is updated. */
  | 'PROMOTION_RULE_UPDATED'
  /** A promotion is activated. */
  | 'PROMOTION_STARTED'
  /** A promotion is updated. */
  | 'PROMOTION_UPDATED'
  /** A sale is created. */
  | 'SALE_CREATED'
  /** A sale is deleted. */
  | 'SALE_DELETED'
  /** A sale is activated or deactivated. */
  | 'SALE_TOGGLE'
  /** A sale is updated. */
  | 'SALE_UPDATED'
  /** Fetch external shipping methods for checkout. */
  | 'SHIPPING_LIST_METHODS_FOR_CHECKOUT'
  /** A new shipping price is created. */
  | 'SHIPPING_PRICE_CREATED'
  /** A shipping price is deleted. */
  | 'SHIPPING_PRICE_DELETED'
  /** A shipping price is updated. */
  | 'SHIPPING_PRICE_UPDATED'
  /** A new shipping zone is created. */
  | 'SHIPPING_ZONE_CREATED'
  /** A shipping zone is deleted. */
  | 'SHIPPING_ZONE_DELETED'
  /** A shipping zone metadata is updated. */
  | 'SHIPPING_ZONE_METADATA_UPDATED'
  /** A shipping zone is updated. */
  | 'SHIPPING_ZONE_UPDATED'
  /** Shop metadata is updated. */
  | 'SHOP_METADATA_UPDATED'
  /** A new staff user is created. */
  | 'STAFF_CREATED'
  /** A staff user is deleted. */
  | 'STAFF_DELETED'
  /** Setting a new password for the staff account is requested. */
  | 'STAFF_SET_PASSWORD_REQUESTED'
  /** A staff user is updated. */
  | 'STAFF_UPDATED'
  | 'STORED_PAYMENT_METHOD_DELETE_REQUESTED'
  /** A thumbnail is created. */
  | 'THUMBNAIL_CREATED'
  /** Event called when cancel has been requested for transaction. */
  | 'TRANSACTION_CANCELATION_REQUESTED'
  /** Event called when charge has been requested for transaction. */
  | 'TRANSACTION_CHARGE_REQUESTED'
  | 'TRANSACTION_INITIALIZE_SESSION'
  /** Transaction item metadata is updated. */
  | 'TRANSACTION_ITEM_METADATA_UPDATED'
  | 'TRANSACTION_PROCESS_SESSION'
  /** Event called when refund has been requested for transaction. */
  | 'TRANSACTION_REFUND_REQUESTED'
  /** A new translation is created. */
  | 'TRANSLATION_CREATED'
  /** A translation is updated. */
  | 'TRANSLATION_UPDATED'
  | 'VOUCHER_CODES_CREATED'
  | 'VOUCHER_CODES_DELETED'
  /**
   * A voucher code export is completed.
   *
   * Added in Saleor 3.18.
   */
  | 'VOUCHER_CODE_EXPORT_COMPLETED'
  /** A new voucher created. */
  | 'VOUCHER_CREATED'
  /** A voucher is deleted. */
  | 'VOUCHER_DELETED'
  /** A voucher metadata is updated. */
  | 'VOUCHER_METADATA_UPDATED'
  /** A voucher is updated. */
  | 'VOUCHER_UPDATED'
  /** A new warehouse created. */
  | 'WAREHOUSE_CREATED'
  /** A warehouse is deleted. */
  | 'WAREHOUSE_DELETED'
  /** A warehouse metadata is updated. */
  | 'WAREHOUSE_METADATA_UPDATED'
  /** A warehouse is updated. */
  | 'WAREHOUSE_UPDATED';

/** Enum determining type of webhook. */
export type WebhookEventTypeSyncEnum =
  /** Event called for checkout tax calculation. */
  | 'CHECKOUT_CALCULATE_TAXES'
  /** Filter shipping methods for checkout. */
  | 'CHECKOUT_FILTER_SHIPPING_METHODS'
  | 'LIST_STORED_PAYMENT_METHODS'
  /** Event called for order tax calculation. */
  | 'ORDER_CALCULATE_TAXES'
  /** Filter shipping methods for order. */
  | 'ORDER_FILTER_SHIPPING_METHODS'
  /** Authorize payment. */
  | 'PAYMENT_AUTHORIZE'
  /** Capture payment. */
  | 'PAYMENT_CAPTURE'
  /** Confirm payment. */
  | 'PAYMENT_CONFIRM'
  | 'PAYMENT_GATEWAY_INITIALIZE_SESSION'
  | 'PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION'
  /** Listing available payment gateways. */
  | 'PAYMENT_LIST_GATEWAYS'
  | 'PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION'
  | 'PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION'
  /** Process payment. */
  | 'PAYMENT_PROCESS'
  /** Refund payment. */
  | 'PAYMENT_REFUND'
  /** Void payment. */
  | 'PAYMENT_VOID'
  /** Fetch external shipping methods for checkout. */
  | 'SHIPPING_LIST_METHODS_FOR_CHECKOUT'
  | 'STORED_PAYMENT_METHOD_DELETE_REQUESTED'
  /** Event called when cancel has been requested for transaction. */
  | 'TRANSACTION_CANCELATION_REQUESTED'
  /** Event called when charge has been requested for transaction. */
  | 'TRANSACTION_CHARGE_REQUESTED'
  | 'TRANSACTION_INITIALIZE_SESSION'
  | 'TRANSACTION_PROCESS_SESSION'
  /** Event called when refund has been requested for transaction. */
  | 'TRANSACTION_REFUND_REQUESTED';

export type WebhookSampleEventTypeEnum =
  | 'ACCOUNT_CHANGE_EMAIL_REQUESTED'
  | 'ACCOUNT_CONFIRMATION_REQUESTED'
  | 'ACCOUNT_CONFIRMED'
  | 'ACCOUNT_DELETED'
  | 'ACCOUNT_DELETE_REQUESTED'
  | 'ACCOUNT_EMAIL_CHANGED'
  | 'ACCOUNT_SET_PASSWORD_REQUESTED'
  | 'ADDRESS_CREATED'
  | 'ADDRESS_DELETED'
  | 'ADDRESS_UPDATED'
  | 'APP_DELETED'
  | 'APP_INSTALLED'
  | 'APP_STATUS_CHANGED'
  | 'APP_UPDATED'
  | 'ATTRIBUTE_CREATED'
  | 'ATTRIBUTE_DELETED'
  | 'ATTRIBUTE_UPDATED'
  | 'ATTRIBUTE_VALUE_CREATED'
  | 'ATTRIBUTE_VALUE_DELETED'
  | 'ATTRIBUTE_VALUE_UPDATED'
  | 'CATEGORY_CREATED'
  | 'CATEGORY_DELETED'
  | 'CATEGORY_UPDATED'
  | 'CHANNEL_CREATED'
  | 'CHANNEL_DELETED'
  | 'CHANNEL_METADATA_UPDATED'
  | 'CHANNEL_STATUS_CHANGED'
  | 'CHANNEL_UPDATED'
  | 'CHECKOUT_CREATED'
  | 'CHECKOUT_FULLY_AUTHORIZED'
  | 'CHECKOUT_FULLY_PAID'
  | 'CHECKOUT_METADATA_UPDATED'
  | 'CHECKOUT_UPDATED'
  | 'COLLECTION_CREATED'
  | 'COLLECTION_DELETED'
  | 'COLLECTION_METADATA_UPDATED'
  | 'COLLECTION_UPDATED'
  | 'CUSTOMER_CREATED'
  | 'CUSTOMER_DELETED'
  | 'CUSTOMER_METADATA_UPDATED'
  | 'CUSTOMER_UPDATED'
  | 'DRAFT_ORDER_CREATED'
  | 'DRAFT_ORDER_DELETED'
  | 'DRAFT_ORDER_UPDATED'
  | 'FULFILLMENT_APPROVED'
  | 'FULFILLMENT_CANCELED'
  | 'FULFILLMENT_CREATED'
  | 'FULFILLMENT_METADATA_UPDATED'
  | 'FULFILLMENT_TRACKING_NUMBER_UPDATED'
  | 'GIFT_CARD_CREATED'
  | 'GIFT_CARD_DELETED'
  | 'GIFT_CARD_EXPORT_COMPLETED'
  | 'GIFT_CARD_METADATA_UPDATED'
  | 'GIFT_CARD_SENT'
  | 'GIFT_CARD_STATUS_CHANGED'
  | 'GIFT_CARD_UPDATED'
  | 'INVOICE_DELETED'
  | 'INVOICE_REQUESTED'
  | 'INVOICE_SENT'
  | 'MENU_CREATED'
  | 'MENU_DELETED'
  | 'MENU_ITEM_CREATED'
  | 'MENU_ITEM_DELETED'
  | 'MENU_ITEM_UPDATED'
  | 'MENU_UPDATED'
  | 'NOTIFY_USER'
  | 'OBSERVABILITY'
  | 'ORDER_BULK_CREATED'
  | 'ORDER_CANCELLED'
  | 'ORDER_CONFIRMED'
  | 'ORDER_CREATED'
  | 'ORDER_EXPIRED'
  | 'ORDER_FULFILLED'
  | 'ORDER_FULLY_PAID'
  | 'ORDER_FULLY_REFUNDED'
  | 'ORDER_METADATA_UPDATED'
  | 'ORDER_PAID'
  | 'ORDER_REFUNDED'
  | 'ORDER_UPDATED'
  | 'PAGE_CREATED'
  | 'PAGE_DELETED'
  | 'PAGE_TYPE_CREATED'
  | 'PAGE_TYPE_DELETED'
  | 'PAGE_TYPE_UPDATED'
  | 'PAGE_UPDATED'
  | 'PERMISSION_GROUP_CREATED'
  | 'PERMISSION_GROUP_DELETED'
  | 'PERMISSION_GROUP_UPDATED'
  | 'PRODUCT_CREATED'
  | 'PRODUCT_DELETED'
  | 'PRODUCT_EXPORT_COMPLETED'
  | 'PRODUCT_MEDIA_CREATED'
  | 'PRODUCT_MEDIA_DELETED'
  | 'PRODUCT_MEDIA_UPDATED'
  | 'PRODUCT_METADATA_UPDATED'
  | 'PRODUCT_UPDATED'
  | 'PRODUCT_VARIANT_BACK_IN_STOCK'
  | 'PRODUCT_VARIANT_CREATED'
  | 'PRODUCT_VARIANT_DELETED'
  | 'PRODUCT_VARIANT_METADATA_UPDATED'
  | 'PRODUCT_VARIANT_OUT_OF_STOCK'
  | 'PRODUCT_VARIANT_STOCK_UPDATED'
  | 'PRODUCT_VARIANT_UPDATED'
  | 'PROMOTION_CREATED'
  | 'PROMOTION_DELETED'
  | 'PROMOTION_ENDED'
  | 'PROMOTION_RULE_CREATED'
  | 'PROMOTION_RULE_DELETED'
  | 'PROMOTION_RULE_UPDATED'
  | 'PROMOTION_STARTED'
  | 'PROMOTION_UPDATED'
  | 'SALE_CREATED'
  | 'SALE_DELETED'
  | 'SALE_TOGGLE'
  | 'SALE_UPDATED'
  | 'SHIPPING_PRICE_CREATED'
  | 'SHIPPING_PRICE_DELETED'
  | 'SHIPPING_PRICE_UPDATED'
  | 'SHIPPING_ZONE_CREATED'
  | 'SHIPPING_ZONE_DELETED'
  | 'SHIPPING_ZONE_METADATA_UPDATED'
  | 'SHIPPING_ZONE_UPDATED'
  | 'SHOP_METADATA_UPDATED'
  | 'STAFF_CREATED'
  | 'STAFF_DELETED'
  | 'STAFF_SET_PASSWORD_REQUESTED'
  | 'STAFF_UPDATED'
  | 'THUMBNAIL_CREATED'
  | 'TRANSACTION_ITEM_METADATA_UPDATED'
  | 'TRANSLATION_CREATED'
  | 'TRANSLATION_UPDATED'
  | 'VOUCHER_CODES_CREATED'
  | 'VOUCHER_CODES_DELETED'
  | 'VOUCHER_CODE_EXPORT_COMPLETED'
  | 'VOUCHER_CREATED'
  | 'VOUCHER_DELETED'
  | 'VOUCHER_METADATA_UPDATED'
  | 'VOUCHER_UPDATED'
  | 'WAREHOUSE_CREATED'
  | 'WAREHOUSE_DELETED'
  | 'WAREHOUSE_METADATA_UPDATED'
  | 'WAREHOUSE_UPDATED';

/**
 * Trigger a webhook event. Supports a single event (the first, if multiple provided in the `webhook.subscription_query`). Requires permission relevant to processed event. Successfully delivered webhook returns `delivery` with status='PENDING' and empty payload.
 *
 * Requires one of the following permissions: AUTHENTICATED_STAFF_USER.
 */
export type WebhookTrigger = {
  readonly delivery?: Maybe<EventDelivery>;
  readonly errors: ReadonlyArray<WebhookTriggerError>;
};

export type WebhookTriggerError = {
  /** The error code. */
  readonly code: WebhookTriggerErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  readonly field?: Maybe<Scalars['String']['output']>;
  /** The error message. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

export type WebhookTriggerErrorCode =
  | 'GRAPHQL_ERROR'
  | 'INVALID_ID'
  | 'MISSING_EVENT'
  | 'MISSING_PERMISSION'
  | 'MISSING_QUERY'
  | 'MISSING_SUBSCRIPTION'
  | 'NOT_FOUND'
  | 'SYNTAX'
  | 'TYPE_NOT_SUPPORTED'
  | 'UNABLE_TO_PARSE';

/**
 * Updates a webhook subscription.
 *
 * Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP.
 */
export type WebhookUpdate = {
  readonly errors: ReadonlyArray<WebhookError>;
  readonly webhook?: Maybe<Webhook>;
  /** @deprecated Use `errors` field instead. */
  readonly webhookErrors: ReadonlyArray<WebhookError>;
};

export type WebhookUpdateInput = {
  /** ID of the app to which webhook belongs. */
  readonly app?: InputMaybe<Scalars['ID']['input']>;
  /** The asynchronous events that webhook wants to subscribe. */
  readonly asyncEvents?: InputMaybe<ReadonlyArray<WebhookEventTypeAsyncEnum>>;
  /** Custom headers, which will be added to HTTP request. There is a limitation of 5 headers per webhook and 998 characters per header.Only `X-*`, `Authorization*`, and `BrokerProperties` keys are allowed. */
  readonly customHeaders?: InputMaybe<Scalars['JSONString']['input']>;
  /**
   * The events that webhook wants to subscribe.
   * @deprecated Use `asyncEvents` or `syncEvents` instead.
   */
  readonly events?: InputMaybe<ReadonlyArray<WebhookEventTypeEnum>>;
  /** Determine if webhook will be set active or not. */
  readonly isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** The new name of the webhook. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Subscription query used to define a webhook payload. */
  readonly query?: InputMaybe<Scalars['String']['input']>;
  /**
   * Use to create a hash signature with each payload.
   * @deprecated As of Saleor 3.5, webhook payloads default to signing using a verifiable JWS.
   */
  readonly secretKey?: InputMaybe<Scalars['String']['input']>;
  /** The synchronous events that webhook wants to subscribe. */
  readonly syncEvents?: InputMaybe<ReadonlyArray<WebhookEventTypeSyncEnum>>;
  /** The url to receive the payload. */
  readonly targetUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Represents weight value in a specific weight unit. */
export type Weight = {
  /** Weight unit. */
  readonly unit: WeightUnitsEnum;
  /** Weight value. Returns a value with maximal three decimal places */
  readonly value: Scalars['Float']['output'];
};

export type WeightUnitsEnum =
  | 'G'
  | 'KG'
  | 'LB'
  | 'OZ'
  | 'TONNE';

/** Represents the WIDGET target options for an app extension. */
export type WidgetTargetOptions = {
  /** HTTP method for Widget target (GET or POST) */
  readonly method: HttpMethod;
};

/** _Entity union as defined by Federation spec. */
export type _Entity = Address | App | Category | Collection | Group | Order | PageType | Product | ProductMedia | ProductType | ProductVariant | User;

/** _Service manifest as defined by Federation spec. */
export type _Service = {
  readonly sdl?: Maybe<Scalars['String']['output']>;
};

export type AddressFragment = { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } };

export type ChannelFragment = { readonly id: string, readonly slug: string, readonly currencyCode: string };

type EventMetadata_AccountChangeEmailRequested_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AccountConfirmationRequested_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AccountConfirmed_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AccountDeleteRequested_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AccountDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AccountEmailChanged_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AccountSetPasswordRequested_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AddressCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AddressDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AddressUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AppDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AppInstalled_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AppStatusChanged_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AppUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AttributeCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AttributeDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AttributeUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AttributeValueCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AttributeValueDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_AttributeValueUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CalculateTaxes_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CategoryCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CategoryDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CategoryUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ChannelCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ChannelDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ChannelMetadataUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ChannelStatusChanged_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ChannelUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CheckoutCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CheckoutFilterShippingMethods_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CheckoutFullyAuthorized_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CheckoutFullyPaid_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CheckoutMetadataUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CheckoutUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CollectionCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CollectionDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CollectionMetadataUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CollectionUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CustomerCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CustomerMetadataUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_CustomerUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_DraftOrderCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_DraftOrderDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_DraftOrderUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_FulfillmentApproved_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_FulfillmentCanceled_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_FulfillmentCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_FulfillmentMetadataUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_FulfillmentTrackingNumberUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_GiftCardCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_GiftCardDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_GiftCardExportCompleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_GiftCardMetadataUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_GiftCardSent_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_GiftCardStatusChanged_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_GiftCardUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_InvoiceDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_InvoiceRequested_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_InvoiceSent_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ListStoredPaymentMethods_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_MenuCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_MenuDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_MenuItemCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_MenuItemDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_MenuItemUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_MenuUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_OrderBulkCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_OrderCancelled_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_OrderConfirmed_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_OrderCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_OrderExpired_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_OrderFilterShippingMethods_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_OrderFulfilled_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_OrderFullyPaid_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_OrderFullyRefunded_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_OrderMetadataUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_OrderPaid_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_OrderRefunded_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_OrderUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PageCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PageDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PageTypeCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PageTypeDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PageTypeUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PageUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PaymentAuthorize_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PaymentCaptureEvent_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PaymentConfirmEvent_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PaymentGatewayInitializeSession_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PaymentGatewayInitializeTokenizationSession_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PaymentListGateways_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PaymentMethodInitializeTokenizationSession_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PaymentMethodProcessTokenizationSession_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PaymentProcessEvent_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PaymentRefundEvent_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PaymentVoidEvent_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PermissionGroupCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PermissionGroupDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PermissionGroupUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductExportCompleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductMediaCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductMediaDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductMediaUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductMetadataUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductVariantBackInStock_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductVariantCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductVariantDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductVariantMetadataUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductVariantOutOfStock_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductVariantStockUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ProductVariantUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PromotionCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PromotionDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PromotionEnded_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PromotionRuleCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PromotionRuleDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PromotionRuleUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PromotionStarted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_PromotionUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_SaleCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_SaleDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_SaleToggle_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_SaleUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ShippingListMethodsForCheckout_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ShippingPriceCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ShippingPriceDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ShippingPriceUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ShippingZoneCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ShippingZoneDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ShippingZoneMetadataUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ShippingZoneUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ShopMetadataUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_StaffCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_StaffDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_StaffSetPasswordRequested_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_StaffUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_StoredPaymentMethodDeleteRequested_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_ThumbnailCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_TransactionCancelationRequested_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_TransactionChargeRequested_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_TransactionInitializeSession_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_TransactionItemMetadataUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_TransactionProcessSession_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_TransactionRefundRequested_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_TranslationCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_TranslationUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_VoucherCodeExportCompleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_VoucherCodesCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_VoucherCodesDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_VoucherCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_VoucherDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_VoucherMetadataUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_VoucherUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_WarehouseCreated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_WarehouseDeleted_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_WarehouseMetadataUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

type EventMetadata_WarehouseUpdated_Fragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly recipient?: { readonly id: string } | null };

export type EventMetadataFragment = EventMetadata_AccountChangeEmailRequested_Fragment | EventMetadata_AccountConfirmationRequested_Fragment | EventMetadata_AccountConfirmed_Fragment | EventMetadata_AccountDeleteRequested_Fragment | EventMetadata_AccountDeleted_Fragment | EventMetadata_AccountEmailChanged_Fragment | EventMetadata_AccountSetPasswordRequested_Fragment | EventMetadata_AddressCreated_Fragment | EventMetadata_AddressDeleted_Fragment | EventMetadata_AddressUpdated_Fragment | EventMetadata_AppDeleted_Fragment | EventMetadata_AppInstalled_Fragment | EventMetadata_AppStatusChanged_Fragment | EventMetadata_AppUpdated_Fragment | EventMetadata_AttributeCreated_Fragment | EventMetadata_AttributeDeleted_Fragment | EventMetadata_AttributeUpdated_Fragment | EventMetadata_AttributeValueCreated_Fragment | EventMetadata_AttributeValueDeleted_Fragment | EventMetadata_AttributeValueUpdated_Fragment | EventMetadata_CalculateTaxes_Fragment | EventMetadata_CategoryCreated_Fragment | EventMetadata_CategoryDeleted_Fragment | EventMetadata_CategoryUpdated_Fragment | EventMetadata_ChannelCreated_Fragment | EventMetadata_ChannelDeleted_Fragment | EventMetadata_ChannelMetadataUpdated_Fragment | EventMetadata_ChannelStatusChanged_Fragment | EventMetadata_ChannelUpdated_Fragment | EventMetadata_CheckoutCreated_Fragment | EventMetadata_CheckoutFilterShippingMethods_Fragment | EventMetadata_CheckoutFullyAuthorized_Fragment | EventMetadata_CheckoutFullyPaid_Fragment | EventMetadata_CheckoutMetadataUpdated_Fragment | EventMetadata_CheckoutUpdated_Fragment | EventMetadata_CollectionCreated_Fragment | EventMetadata_CollectionDeleted_Fragment | EventMetadata_CollectionMetadataUpdated_Fragment | EventMetadata_CollectionUpdated_Fragment | EventMetadata_CustomerCreated_Fragment | EventMetadata_CustomerMetadataUpdated_Fragment | EventMetadata_CustomerUpdated_Fragment | EventMetadata_DraftOrderCreated_Fragment | EventMetadata_DraftOrderDeleted_Fragment | EventMetadata_DraftOrderUpdated_Fragment | EventMetadata_FulfillmentApproved_Fragment | EventMetadata_FulfillmentCanceled_Fragment | EventMetadata_FulfillmentCreated_Fragment | EventMetadata_FulfillmentMetadataUpdated_Fragment | EventMetadata_FulfillmentTrackingNumberUpdated_Fragment | EventMetadata_GiftCardCreated_Fragment | EventMetadata_GiftCardDeleted_Fragment | EventMetadata_GiftCardExportCompleted_Fragment | EventMetadata_GiftCardMetadataUpdated_Fragment | EventMetadata_GiftCardSent_Fragment | EventMetadata_GiftCardStatusChanged_Fragment | EventMetadata_GiftCardUpdated_Fragment | EventMetadata_InvoiceDeleted_Fragment | EventMetadata_InvoiceRequested_Fragment | EventMetadata_InvoiceSent_Fragment | EventMetadata_ListStoredPaymentMethods_Fragment | EventMetadata_MenuCreated_Fragment | EventMetadata_MenuDeleted_Fragment | EventMetadata_MenuItemCreated_Fragment | EventMetadata_MenuItemDeleted_Fragment | EventMetadata_MenuItemUpdated_Fragment | EventMetadata_MenuUpdated_Fragment | EventMetadata_OrderBulkCreated_Fragment | EventMetadata_OrderCancelled_Fragment | EventMetadata_OrderConfirmed_Fragment | EventMetadata_OrderCreated_Fragment | EventMetadata_OrderExpired_Fragment | EventMetadata_OrderFilterShippingMethods_Fragment | EventMetadata_OrderFulfilled_Fragment | EventMetadata_OrderFullyPaid_Fragment | EventMetadata_OrderFullyRefunded_Fragment | EventMetadata_OrderMetadataUpdated_Fragment | EventMetadata_OrderPaid_Fragment | EventMetadata_OrderRefunded_Fragment | EventMetadata_OrderUpdated_Fragment | EventMetadata_PageCreated_Fragment | EventMetadata_PageDeleted_Fragment | EventMetadata_PageTypeCreated_Fragment | EventMetadata_PageTypeDeleted_Fragment | EventMetadata_PageTypeUpdated_Fragment | EventMetadata_PageUpdated_Fragment | EventMetadata_PaymentAuthorize_Fragment | EventMetadata_PaymentCaptureEvent_Fragment | EventMetadata_PaymentConfirmEvent_Fragment | EventMetadata_PaymentGatewayInitializeSession_Fragment | EventMetadata_PaymentGatewayInitializeTokenizationSession_Fragment | EventMetadata_PaymentListGateways_Fragment | EventMetadata_PaymentMethodInitializeTokenizationSession_Fragment | EventMetadata_PaymentMethodProcessTokenizationSession_Fragment | EventMetadata_PaymentProcessEvent_Fragment | EventMetadata_PaymentRefundEvent_Fragment | EventMetadata_PaymentVoidEvent_Fragment | EventMetadata_PermissionGroupCreated_Fragment | EventMetadata_PermissionGroupDeleted_Fragment | EventMetadata_PermissionGroupUpdated_Fragment | EventMetadata_ProductCreated_Fragment | EventMetadata_ProductDeleted_Fragment | EventMetadata_ProductExportCompleted_Fragment | EventMetadata_ProductMediaCreated_Fragment | EventMetadata_ProductMediaDeleted_Fragment | EventMetadata_ProductMediaUpdated_Fragment | EventMetadata_ProductMetadataUpdated_Fragment | EventMetadata_ProductUpdated_Fragment | EventMetadata_ProductVariantBackInStock_Fragment | EventMetadata_ProductVariantCreated_Fragment | EventMetadata_ProductVariantDeleted_Fragment | EventMetadata_ProductVariantMetadataUpdated_Fragment | EventMetadata_ProductVariantOutOfStock_Fragment | EventMetadata_ProductVariantStockUpdated_Fragment | EventMetadata_ProductVariantUpdated_Fragment | EventMetadata_PromotionCreated_Fragment | EventMetadata_PromotionDeleted_Fragment | EventMetadata_PromotionEnded_Fragment | EventMetadata_PromotionRuleCreated_Fragment | EventMetadata_PromotionRuleDeleted_Fragment | EventMetadata_PromotionRuleUpdated_Fragment | EventMetadata_PromotionStarted_Fragment | EventMetadata_PromotionUpdated_Fragment | EventMetadata_SaleCreated_Fragment | EventMetadata_SaleDeleted_Fragment | EventMetadata_SaleToggle_Fragment | EventMetadata_SaleUpdated_Fragment | EventMetadata_ShippingListMethodsForCheckout_Fragment | EventMetadata_ShippingPriceCreated_Fragment | EventMetadata_ShippingPriceDeleted_Fragment | EventMetadata_ShippingPriceUpdated_Fragment | EventMetadata_ShippingZoneCreated_Fragment | EventMetadata_ShippingZoneDeleted_Fragment | EventMetadata_ShippingZoneMetadataUpdated_Fragment | EventMetadata_ShippingZoneUpdated_Fragment | EventMetadata_ShopMetadataUpdated_Fragment | EventMetadata_StaffCreated_Fragment | EventMetadata_StaffDeleted_Fragment | EventMetadata_StaffSetPasswordRequested_Fragment | EventMetadata_StaffUpdated_Fragment | EventMetadata_StoredPaymentMethodDeleteRequested_Fragment | EventMetadata_ThumbnailCreated_Fragment | EventMetadata_TransactionCancelationRequested_Fragment | EventMetadata_TransactionChargeRequested_Fragment | EventMetadata_TransactionInitializeSession_Fragment | EventMetadata_TransactionItemMetadataUpdated_Fragment | EventMetadata_TransactionProcessSession_Fragment | EventMetadata_TransactionRefundRequested_Fragment | EventMetadata_TranslationCreated_Fragment | EventMetadata_TranslationUpdated_Fragment | EventMetadata_VoucherCodeExportCompleted_Fragment | EventMetadata_VoucherCodesCreated_Fragment | EventMetadata_VoucherCodesDeleted_Fragment | EventMetadata_VoucherCreated_Fragment | EventMetadata_VoucherDeleted_Fragment | EventMetadata_VoucherMetadataUpdated_Fragment | EventMetadata_VoucherUpdated_Fragment | EventMetadata_WarehouseCreated_Fragment | EventMetadata_WarehouseDeleted_Fragment | EventMetadata_WarehouseMetadataUpdated_Fragment | EventMetadata_WarehouseUpdated_Fragment;

export type OrderGrantedRefundFragment = { readonly shippingCostsIncluded: boolean, readonly lines?: ReadonlyArray<{ readonly quantity: number, readonly orderLine: { readonly id: string } }> | null };

type SourceObject_Checkout_Fragment = { readonly __typename: 'Checkout', readonly id: string, readonly email?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly totalPrice: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'CheckoutLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly checkoutVariant: { readonly sku?: string | null, readonly product: { readonly name: string } } }> };

type SourceObject_Order_Fragment = { readonly __typename: 'Order', readonly id: string, readonly userEmail?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly total: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'OrderLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly orderVariant?: { readonly sku?: string | null, readonly product: { readonly name: string } } | null }> };

export type SourceObjectFragment = SourceObject_Checkout_Fragment | SourceObject_Order_Fragment;

export type OrderNoteAddMutationVariables = Exact<{
  order: Scalars['ID']['input'];
  input: OrderNoteInput;
}>;


export type OrderNoteAddMutation = { readonly orderNoteAdd?: { readonly event?: { readonly id: string } | null, readonly errors: ReadonlyArray<{ readonly field?: string | null, readonly message?: string | null, readonly code?: OrderNoteAddErrorCode | null }> } | null };

export type FetchChannelsQueryVariables = Exact<{ [key: string]: never; }>;


export type FetchChannelsQuery = { readonly channels?: ReadonlyArray<{ readonly id: string, readonly slug: string, readonly currencyCode: string }> | null };

export type FulfillmentTrackingNumberUpdatedEventFragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly fulfillment?: { readonly trackingNumber: string, readonly atobaraiPDCompanyCode?: string | null } | null, readonly order?: { readonly id: string, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly transactions: ReadonlyArray<{ readonly pspReference: string, readonly createdBy?: { readonly __typename: 'App', readonly id: string } | { readonly __typename: 'User' } | null }> } | null, readonly recipient?: { readonly id: string } | null };

export type FulfillmentTrackingNumberUpdatedSubscriptionVariables = Exact<{ [key: string]: never; }>;


export type FulfillmentTrackingNumberUpdatedSubscription = { readonly event?: { readonly version?: string | null, readonly issuedAt?: string | null, readonly fulfillment?: { readonly trackingNumber: string, readonly atobaraiPDCompanyCode?: string | null } | null, readonly order?: { readonly id: string, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly transactions: ReadonlyArray<{ readonly pspReference: string, readonly createdBy?: { readonly __typename: 'App', readonly id: string } | { readonly __typename: 'User' } | null }> } | null, readonly recipient?: { readonly id: string } | null } | {} | null };

export type PaymentGatewayInitializeSessionEventFragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly sourceObject: { readonly __typename: 'Checkout', readonly id: string, readonly email?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly totalPrice: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'CheckoutLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly checkoutVariant: { readonly sku?: string | null, readonly product: { readonly name: string } } }> } | { readonly __typename: 'Order', readonly id: string, readonly userEmail?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly total: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'OrderLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly orderVariant?: { readonly sku?: string | null, readonly product: { readonly name: string } } | null }> }, readonly recipient?: { readonly id: string } | null };

export type PaymentGatewayInitializeSessionSubscriptionVariables = Exact<{ [key: string]: never; }>;


export type PaymentGatewayInitializeSessionSubscription = { readonly event?: { readonly version?: string | null, readonly issuedAt?: string | null, readonly sourceObject: { readonly __typename: 'Checkout', readonly id: string, readonly email?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly totalPrice: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'CheckoutLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly checkoutVariant: { readonly sku?: string | null, readonly product: { readonly name: string } } }> } | { readonly __typename: 'Order', readonly id: string, readonly userEmail?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly total: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'OrderLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly orderVariant?: { readonly sku?: string | null, readonly product: { readonly name: string } } | null }> }, readonly recipient?: { readonly id: string } | null } | {} | null };

export type TransactionInitializeSessionEventFragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly action: { readonly amount: number, readonly currency: string }, readonly transaction: { readonly token: string }, readonly sourceObject: { readonly __typename: 'Checkout', readonly id: string, readonly email?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly totalPrice: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'CheckoutLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly checkoutVariant: { readonly sku?: string | null, readonly product: { readonly name: string } } }> } | { readonly __typename: 'Order', readonly id: string, readonly userEmail?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly total: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'OrderLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly orderVariant?: { readonly sku?: string | null, readonly product: { readonly name: string } } | null }> }, readonly recipient?: { readonly id: string } | null };

export type TransactionInitializeSessionSubscriptionVariables = Exact<{ [key: string]: never; }>;


export type TransactionInitializeSessionSubscription = { readonly event?: { readonly version?: string | null, readonly issuedAt?: string | null, readonly action: { readonly amount: number, readonly currency: string }, readonly transaction: { readonly token: string }, readonly sourceObject: { readonly __typename: 'Checkout', readonly id: string, readonly email?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly totalPrice: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'CheckoutLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly checkoutVariant: { readonly sku?: string | null, readonly product: { readonly name: string } } }> } | { readonly __typename: 'Order', readonly id: string, readonly userEmail?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly total: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'OrderLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly orderVariant?: { readonly sku?: string | null, readonly product: { readonly name: string } } | null }> }, readonly recipient?: { readonly id: string } | null } | {} | null };

export type TransactionProcessSessionEventFragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly action: { readonly amount: number, readonly currency: string }, readonly transaction: { readonly token: string, readonly pspReference: string }, readonly sourceObject: { readonly __typename: 'Checkout', readonly id: string, readonly email?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly totalPrice: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'CheckoutLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly checkoutVariant: { readonly sku?: string | null, readonly product: { readonly name: string } } }> } | { readonly __typename: 'Order', readonly id: string, readonly userEmail?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly total: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'OrderLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly orderVariant?: { readonly sku?: string | null, readonly product: { readonly name: string } } | null }> }, readonly recipient?: { readonly id: string } | null };

export type TransactionProcessSessionSubscriptionVariables = Exact<{ [key: string]: never; }>;


export type TransactionProcessSessionSubscription = { readonly event?: { readonly version?: string | null, readonly issuedAt?: string | null, readonly action: { readonly amount: number, readonly currency: string }, readonly transaction: { readonly token: string, readonly pspReference: string }, readonly sourceObject: { readonly __typename: 'Checkout', readonly id: string, readonly email?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly totalPrice: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'CheckoutLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly checkoutVariant: { readonly sku?: string | null, readonly product: { readonly name: string } } }> } | { readonly __typename: 'Order', readonly id: string, readonly userEmail?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly total: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'OrderLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly orderVariant?: { readonly sku?: string | null, readonly product: { readonly name: string } } | null }> }, readonly recipient?: { readonly id: string } | null } | {} | null };

export type TransactionRefundRequestedEventFragment = { readonly version?: string | null, readonly issuedAt?: string | null, readonly action: { readonly amount: number, readonly currency: string }, readonly grantedRefund?: { readonly shippingCostsIncluded: boolean, readonly lines?: ReadonlyArray<{ readonly quantity: number, readonly orderLine: { readonly id: string } }> | null } | null, readonly transaction?: { readonly token: string, readonly pspReference: string, readonly chargedAmount: { readonly amount: number }, readonly checkout?: { readonly __typename: 'Checkout', readonly id: string, readonly email?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly totalPrice: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'CheckoutLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly checkoutVariant: { readonly sku?: string | null, readonly product: { readonly name: string } } }> } | null, readonly order?: { readonly __typename: 'Order', readonly id: string, readonly userEmail?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly total: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'OrderLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly orderVariant?: { readonly sku?: string | null, readonly product: { readonly name: string } } | null }> } | null } | null, readonly recipient?: { readonly id: string } | null };

export type TransactionRefundRequestedSubscriptionVariables = Exact<{ [key: string]: never; }>;


export type TransactionRefundRequestedSubscription = { readonly event?: { readonly version?: string | null, readonly issuedAt?: string | null, readonly action: { readonly amount: number, readonly currency: string }, readonly grantedRefund?: { readonly shippingCostsIncluded: boolean, readonly lines?: ReadonlyArray<{ readonly quantity: number, readonly orderLine: { readonly id: string } }> | null } | null, readonly transaction?: { readonly token: string, readonly pspReference: string, readonly chargedAmount: { readonly amount: number }, readonly checkout?: { readonly __typename: 'Checkout', readonly id: string, readonly email?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly totalPrice: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'CheckoutLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly checkoutVariant: { readonly sku?: string | null, readonly product: { readonly name: string } } }> } | null, readonly order?: { readonly __typename: 'Order', readonly id: string, readonly userEmail?: string | null, readonly channel: { readonly id: string, readonly slug: string, readonly currencyCode: string }, readonly billingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly shippingAddress?: { readonly firstName: string, readonly lastName: string, readonly companyName: string, readonly postalCode: string, readonly countryArea: string, readonly streetAddress1: string, readonly streetAddress2: string, readonly phone?: string | null, readonly city: string, readonly cityArea: string, readonly country: { readonly code: string } } | null, readonly discount?: { readonly amount: number } | null, readonly shippingPrice: { readonly gross: { readonly amount: number } }, readonly total: { readonly gross: { readonly amount: number } }, readonly lines: ReadonlyArray<{ readonly __typename: 'OrderLine', readonly id: string, readonly quantity: number, readonly unitPrice: { readonly gross: { readonly amount: number } }, readonly orderVariant?: { readonly sku?: string | null, readonly product: { readonly name: string } } | null }> } | null } | null, readonly recipient?: { readonly id: string } | null } | {} | null };

export const UntypedEventMetadataFragmentDoc = gql`
    fragment EventMetadata on Event {
  version
  issuedAt
  recipient {
    id
  }
}
    `;
export const UntypedChannelFragmentDoc = gql`
    fragment Channel on Channel {
  id
  slug
  currencyCode
}
    `;
export const UntypedFulfillmentTrackingNumberUpdatedEventFragmentDoc = gql`
    fragment FulfillmentTrackingNumberUpdatedEvent on FulfillmentTrackingNumberUpdated {
  ...EventMetadata
  fulfillment {
    trackingNumber
    atobaraiPDCompanyCode: privateMetafield(key: "np-atobarai.pd-company-code")
  }
  order {
    id
    channel {
      ...Channel
    }
    transactions {
      pspReference
      createdBy {
        ... on App {
          __typename
          id
        }
        ... on User {
          __typename
        }
      }
    }
  }
}
    `;
export const UntypedAddressFragmentDoc = gql`
    fragment Address on Address {
  firstName
  lastName
  companyName
  postalCode
  countryArea
  streetAddress1
  streetAddress2
  phone
  city
  cityArea
  country {
    code
  }
}
    `;
export const UntypedSourceObjectFragmentDoc = gql`
    fragment SourceObject on OrderOrCheckout {
  ... on Checkout {
    __typename
    id
    channel {
      ...Channel
    }
    email
    billingAddress {
      ...Address
    }
    shippingAddress {
      ...Address
    }
    discount {
      amount
    }
    shippingPrice {
      gross {
        amount
      }
    }
    totalPrice {
      gross {
        amount
      }
    }
    lines {
      __typename
      id
      quantity
      unitPrice {
        gross {
          amount
        }
      }
      checkoutVariant: variant {
        sku
        product {
          name
        }
      }
    }
  }
  ... on Order {
    __typename
    id
    channel {
      ...Channel
    }
    userEmail
    billingAddress {
      ...Address
    }
    shippingAddress {
      ...Address
    }
    discount {
      amount
    }
    shippingPrice {
      gross {
        amount
      }
    }
    total {
      gross {
        amount
      }
    }
    lines {
      __typename
      id
      quantity
      unitPrice {
        gross {
          amount
        }
      }
      orderVariant: variant {
        sku
        product {
          name
        }
      }
    }
  }
}
    `;
export const UntypedPaymentGatewayInitializeSessionEventFragmentDoc = gql`
    fragment PaymentGatewayInitializeSessionEvent on PaymentGatewayInitializeSession {
  ...EventMetadata
  sourceObject {
    ...SourceObject
  }
}
    `;
export const UntypedTransactionInitializeSessionEventFragmentDoc = gql`
    fragment TransactionInitializeSessionEvent on TransactionInitializeSession {
  ...EventMetadata
  action {
    amount
    currency
  }
  transaction {
    token
  }
  sourceObject {
    ...SourceObject
  }
}
    `;
export const UntypedTransactionProcessSessionEventFragmentDoc = gql`
    fragment TransactionProcessSessionEvent on TransactionProcessSession {
  ...EventMetadata
  action {
    amount
    currency
  }
  transaction {
    token
    pspReference
  }
  sourceObject {
    ...SourceObject
  }
}
    `;
export const UntypedOrderGrantedRefundFragmentDoc = gql`
    fragment OrderGrantedRefund on OrderGrantedRefund {
  shippingCostsIncluded
  lines {
    quantity
    orderLine {
      id
    }
  }
}
    `;
export const UntypedTransactionRefundRequestedEventFragmentDoc = gql`
    fragment TransactionRefundRequestedEvent on TransactionRefundRequested {
  ...EventMetadata
  action {
    amount
    currency
  }
  grantedRefund {
    ...OrderGrantedRefund
  }
  transaction {
    token
    pspReference
    chargedAmount {
      amount
    }
    checkout {
      ...SourceObject
    }
    order {
      ...SourceObject
    }
  }
}
    `;
export const UntypedOrderNoteAddDocument = gql`
    mutation OrderNoteAdd($order: ID!, $input: OrderNoteInput!) {
  orderNoteAdd(order: $order, input: $input) {
    event {
      id
    }
    errors {
      field
      message
      code
    }
  }
}
    `;
export const UntypedFetchChannelsDocument = gql`
    query FetchChannels {
  channels {
    ...Channel
  }
}
    ${UntypedChannelFragmentDoc}`;
export const UntypedFulfillmentTrackingNumberUpdatedDocument = gql`
    subscription FulfillmentTrackingNumberUpdated {
  event {
    ...FulfillmentTrackingNumberUpdatedEvent
  }
}
    ${UntypedFulfillmentTrackingNumberUpdatedEventFragmentDoc}
${UntypedEventMetadataFragmentDoc}
${UntypedChannelFragmentDoc}`;
export const UntypedPaymentGatewayInitializeSessionDocument = gql`
    subscription PaymentGatewayInitializeSession {
  event {
    ...PaymentGatewayInitializeSessionEvent
  }
}
    ${UntypedPaymentGatewayInitializeSessionEventFragmentDoc}
${UntypedEventMetadataFragmentDoc}
${UntypedSourceObjectFragmentDoc}
${UntypedChannelFragmentDoc}
${UntypedAddressFragmentDoc}`;
export const UntypedTransactionInitializeSessionDocument = gql`
    subscription TransactionInitializeSession {
  event {
    ...TransactionInitializeSessionEvent
  }
}
    ${UntypedTransactionInitializeSessionEventFragmentDoc}
${UntypedEventMetadataFragmentDoc}
${UntypedSourceObjectFragmentDoc}
${UntypedChannelFragmentDoc}
${UntypedAddressFragmentDoc}`;
export const UntypedTransactionProcessSessionDocument = gql`
    subscription TransactionProcessSession {
  event {
    ...TransactionProcessSessionEvent
  }
}
    ${UntypedTransactionProcessSessionEventFragmentDoc}
${UntypedEventMetadataFragmentDoc}
${UntypedSourceObjectFragmentDoc}
${UntypedChannelFragmentDoc}
${UntypedAddressFragmentDoc}`;
export const UntypedTransactionRefundRequestedDocument = gql`
    subscription TransactionRefundRequested {
  event {
    ...TransactionRefundRequestedEvent
  }
}
    ${UntypedTransactionRefundRequestedEventFragmentDoc}
${UntypedEventMetadataFragmentDoc}
${UntypedOrderGrantedRefundFragmentDoc}
${UntypedSourceObjectFragmentDoc}
${UntypedChannelFragmentDoc}
${UntypedAddressFragmentDoc}`;
export const EventMetadataFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"EventMetadata"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Event"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"version"}},{"kind":"Field","name":{"kind":"Name","value":"issuedAt"}},{"kind":"Field","name":{"kind":"Name","value":"recipient"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}}]} as unknown as DocumentNode<EventMetadataFragment, unknown>;
export const ChannelFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Channel"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Channel"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"slug"}},{"kind":"Field","name":{"kind":"Name","value":"currencyCode"}}]}}]} as unknown as DocumentNode<ChannelFragment, unknown>;
export const FulfillmentTrackingNumberUpdatedEventFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"FulfillmentTrackingNumberUpdatedEvent"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"FulfillmentTrackingNumberUpdated"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"EventMetadata"}},{"kind":"Field","name":{"kind":"Name","value":"fulfillment"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"trackingNumber"}},{"kind":"Field","alias":{"kind":"Name","value":"atobaraiPDCompanyCode"},"name":{"kind":"Name","value":"privateMetafield"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"key"},"value":{"kind":"StringValue","value":"np-atobarai.pd-company-code","block":false}}]}]}},{"kind":"Field","name":{"kind":"Name","value":"order"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"transactions"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"pspReference"}},{"kind":"Field","name":{"kind":"Name","value":"createdBy"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"App"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"User"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}}]}}]}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"EventMetadata"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Event"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"version"}},{"kind":"Field","name":{"kind":"Name","value":"issuedAt"}},{"kind":"Field","name":{"kind":"Name","value":"recipient"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Channel"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Channel"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"slug"}},{"kind":"Field","name":{"kind":"Name","value":"currencyCode"}}]}}]} as unknown as DocumentNode<FulfillmentTrackingNumberUpdatedEventFragment, unknown>;
export const AddressFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Address"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Address"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"companyName"}},{"kind":"Field","name":{"kind":"Name","value":"postalCode"}},{"kind":"Field","name":{"kind":"Name","value":"countryArea"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress1"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress2"}},{"kind":"Field","name":{"kind":"Name","value":"phone"}},{"kind":"Field","name":{"kind":"Name","value":"city"}},{"kind":"Field","name":{"kind":"Name","value":"cityArea"}},{"kind":"Field","name":{"kind":"Name","value":"country"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}}]}}]}}]} as unknown as DocumentNode<AddressFragment, unknown>;
export const SourceObjectFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"SourceObject"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"OrderOrCheckout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Checkout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"totalPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"checkoutVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Order"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"userEmail"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"total"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"orderVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Channel"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Channel"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"slug"}},{"kind":"Field","name":{"kind":"Name","value":"currencyCode"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Address"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Address"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"companyName"}},{"kind":"Field","name":{"kind":"Name","value":"postalCode"}},{"kind":"Field","name":{"kind":"Name","value":"countryArea"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress1"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress2"}},{"kind":"Field","name":{"kind":"Name","value":"phone"}},{"kind":"Field","name":{"kind":"Name","value":"city"}},{"kind":"Field","name":{"kind":"Name","value":"cityArea"}},{"kind":"Field","name":{"kind":"Name","value":"country"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}}]}}]}}]} as unknown as DocumentNode<SourceObjectFragment, unknown>;
export const PaymentGatewayInitializeSessionEventFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PaymentGatewayInitializeSessionEvent"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"PaymentGatewayInitializeSession"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"EventMetadata"}},{"kind":"Field","name":{"kind":"Name","value":"sourceObject"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"SourceObject"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Channel"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Channel"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"slug"}},{"kind":"Field","name":{"kind":"Name","value":"currencyCode"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Address"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Address"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"companyName"}},{"kind":"Field","name":{"kind":"Name","value":"postalCode"}},{"kind":"Field","name":{"kind":"Name","value":"countryArea"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress1"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress2"}},{"kind":"Field","name":{"kind":"Name","value":"phone"}},{"kind":"Field","name":{"kind":"Name","value":"city"}},{"kind":"Field","name":{"kind":"Name","value":"cityArea"}},{"kind":"Field","name":{"kind":"Name","value":"country"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"EventMetadata"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Event"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"version"}},{"kind":"Field","name":{"kind":"Name","value":"issuedAt"}},{"kind":"Field","name":{"kind":"Name","value":"recipient"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"SourceObject"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"OrderOrCheckout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Checkout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"totalPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"checkoutVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Order"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"userEmail"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"total"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"orderVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<PaymentGatewayInitializeSessionEventFragment, unknown>;
export const TransactionInitializeSessionEventFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"TransactionInitializeSessionEvent"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"TransactionInitializeSession"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"EventMetadata"}},{"kind":"Field","name":{"kind":"Name","value":"action"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}},{"kind":"Field","name":{"kind":"Name","value":"currency"}}]}},{"kind":"Field","name":{"kind":"Name","value":"transaction"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"token"}}]}},{"kind":"Field","name":{"kind":"Name","value":"sourceObject"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"SourceObject"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Channel"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Channel"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"slug"}},{"kind":"Field","name":{"kind":"Name","value":"currencyCode"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Address"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Address"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"companyName"}},{"kind":"Field","name":{"kind":"Name","value":"postalCode"}},{"kind":"Field","name":{"kind":"Name","value":"countryArea"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress1"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress2"}},{"kind":"Field","name":{"kind":"Name","value":"phone"}},{"kind":"Field","name":{"kind":"Name","value":"city"}},{"kind":"Field","name":{"kind":"Name","value":"cityArea"}},{"kind":"Field","name":{"kind":"Name","value":"country"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"EventMetadata"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Event"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"version"}},{"kind":"Field","name":{"kind":"Name","value":"issuedAt"}},{"kind":"Field","name":{"kind":"Name","value":"recipient"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"SourceObject"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"OrderOrCheckout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Checkout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"totalPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"checkoutVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Order"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"userEmail"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"total"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"orderVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<TransactionInitializeSessionEventFragment, unknown>;
export const TransactionProcessSessionEventFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"TransactionProcessSessionEvent"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"TransactionProcessSession"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"EventMetadata"}},{"kind":"Field","name":{"kind":"Name","value":"action"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}},{"kind":"Field","name":{"kind":"Name","value":"currency"}}]}},{"kind":"Field","name":{"kind":"Name","value":"transaction"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"token"}},{"kind":"Field","name":{"kind":"Name","value":"pspReference"}}]}},{"kind":"Field","name":{"kind":"Name","value":"sourceObject"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"SourceObject"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Channel"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Channel"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"slug"}},{"kind":"Field","name":{"kind":"Name","value":"currencyCode"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Address"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Address"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"companyName"}},{"kind":"Field","name":{"kind":"Name","value":"postalCode"}},{"kind":"Field","name":{"kind":"Name","value":"countryArea"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress1"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress2"}},{"kind":"Field","name":{"kind":"Name","value":"phone"}},{"kind":"Field","name":{"kind":"Name","value":"city"}},{"kind":"Field","name":{"kind":"Name","value":"cityArea"}},{"kind":"Field","name":{"kind":"Name","value":"country"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"EventMetadata"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Event"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"version"}},{"kind":"Field","name":{"kind":"Name","value":"issuedAt"}},{"kind":"Field","name":{"kind":"Name","value":"recipient"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"SourceObject"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"OrderOrCheckout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Checkout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"totalPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"checkoutVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Order"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"userEmail"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"total"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"orderVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<TransactionProcessSessionEventFragment, unknown>;
export const OrderGrantedRefundFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"OrderGrantedRefund"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"OrderGrantedRefund"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"shippingCostsIncluded"}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"orderLine"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}}]}}]} as unknown as DocumentNode<OrderGrantedRefundFragment, unknown>;
export const TransactionRefundRequestedEventFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"TransactionRefundRequestedEvent"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"TransactionRefundRequested"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"EventMetadata"}},{"kind":"Field","name":{"kind":"Name","value":"action"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}},{"kind":"Field","name":{"kind":"Name","value":"currency"}}]}},{"kind":"Field","name":{"kind":"Name","value":"grantedRefund"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"OrderGrantedRefund"}}]}},{"kind":"Field","name":{"kind":"Name","value":"transaction"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"token"}},{"kind":"Field","name":{"kind":"Name","value":"pspReference"}},{"kind":"Field","name":{"kind":"Name","value":"chargedAmount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"checkout"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"SourceObject"}}]}},{"kind":"Field","name":{"kind":"Name","value":"order"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"SourceObject"}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Channel"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Channel"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"slug"}},{"kind":"Field","name":{"kind":"Name","value":"currencyCode"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Address"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Address"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"companyName"}},{"kind":"Field","name":{"kind":"Name","value":"postalCode"}},{"kind":"Field","name":{"kind":"Name","value":"countryArea"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress1"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress2"}},{"kind":"Field","name":{"kind":"Name","value":"phone"}},{"kind":"Field","name":{"kind":"Name","value":"city"}},{"kind":"Field","name":{"kind":"Name","value":"cityArea"}},{"kind":"Field","name":{"kind":"Name","value":"country"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"EventMetadata"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Event"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"version"}},{"kind":"Field","name":{"kind":"Name","value":"issuedAt"}},{"kind":"Field","name":{"kind":"Name","value":"recipient"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"OrderGrantedRefund"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"OrderGrantedRefund"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"shippingCostsIncluded"}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"orderLine"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"SourceObject"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"OrderOrCheckout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Checkout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"totalPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"checkoutVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Order"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"userEmail"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"total"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"orderVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<TransactionRefundRequestedEventFragment, unknown>;
export const OrderNoteAddDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"OrderNoteAdd"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"order"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"OrderNoteInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"orderNoteAdd"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"order"},"value":{"kind":"Variable","name":{"kind":"Name","value":"order"}}},{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"event"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}},{"kind":"Field","name":{"kind":"Name","value":"errors"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"field"}},{"kind":"Field","name":{"kind":"Name","value":"message"}},{"kind":"Field","name":{"kind":"Name","value":"code"}}]}}]}}]}}]} as unknown as DocumentNode<OrderNoteAddMutation, OrderNoteAddMutationVariables>;
export const FetchChannelsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"FetchChannels"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"channels"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Channel"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Channel"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"slug"}},{"kind":"Field","name":{"kind":"Name","value":"currencyCode"}}]}}]} as unknown as DocumentNode<FetchChannelsQuery, FetchChannelsQueryVariables>;
export const FulfillmentTrackingNumberUpdatedDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"FulfillmentTrackingNumberUpdated"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"event"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"FulfillmentTrackingNumberUpdatedEvent"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"EventMetadata"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Event"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"version"}},{"kind":"Field","name":{"kind":"Name","value":"issuedAt"}},{"kind":"Field","name":{"kind":"Name","value":"recipient"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Channel"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Channel"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"slug"}},{"kind":"Field","name":{"kind":"Name","value":"currencyCode"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"FulfillmentTrackingNumberUpdatedEvent"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"FulfillmentTrackingNumberUpdated"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"EventMetadata"}},{"kind":"Field","name":{"kind":"Name","value":"fulfillment"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"trackingNumber"}},{"kind":"Field","alias":{"kind":"Name","value":"atobaraiPDCompanyCode"},"name":{"kind":"Name","value":"privateMetafield"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"key"},"value":{"kind":"StringValue","value":"np-atobarai.pd-company-code","block":false}}]}]}},{"kind":"Field","name":{"kind":"Name","value":"order"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"transactions"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"pspReference"}},{"kind":"Field","name":{"kind":"Name","value":"createdBy"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"App"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"User"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<FulfillmentTrackingNumberUpdatedSubscription, FulfillmentTrackingNumberUpdatedSubscriptionVariables>;
export const PaymentGatewayInitializeSessionDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"PaymentGatewayInitializeSession"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"event"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"PaymentGatewayInitializeSessionEvent"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"EventMetadata"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Event"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"version"}},{"kind":"Field","name":{"kind":"Name","value":"issuedAt"}},{"kind":"Field","name":{"kind":"Name","value":"recipient"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Channel"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Channel"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"slug"}},{"kind":"Field","name":{"kind":"Name","value":"currencyCode"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Address"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Address"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"companyName"}},{"kind":"Field","name":{"kind":"Name","value":"postalCode"}},{"kind":"Field","name":{"kind":"Name","value":"countryArea"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress1"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress2"}},{"kind":"Field","name":{"kind":"Name","value":"phone"}},{"kind":"Field","name":{"kind":"Name","value":"city"}},{"kind":"Field","name":{"kind":"Name","value":"cityArea"}},{"kind":"Field","name":{"kind":"Name","value":"country"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"SourceObject"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"OrderOrCheckout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Checkout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"totalPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"checkoutVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Order"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"userEmail"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"total"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"orderVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PaymentGatewayInitializeSessionEvent"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"PaymentGatewayInitializeSession"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"EventMetadata"}},{"kind":"Field","name":{"kind":"Name","value":"sourceObject"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"SourceObject"}}]}}]}}]} as unknown as DocumentNode<PaymentGatewayInitializeSessionSubscription, PaymentGatewayInitializeSessionSubscriptionVariables>;
export const TransactionInitializeSessionDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"TransactionInitializeSession"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"event"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"TransactionInitializeSessionEvent"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"EventMetadata"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Event"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"version"}},{"kind":"Field","name":{"kind":"Name","value":"issuedAt"}},{"kind":"Field","name":{"kind":"Name","value":"recipient"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Channel"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Channel"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"slug"}},{"kind":"Field","name":{"kind":"Name","value":"currencyCode"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Address"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Address"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"companyName"}},{"kind":"Field","name":{"kind":"Name","value":"postalCode"}},{"kind":"Field","name":{"kind":"Name","value":"countryArea"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress1"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress2"}},{"kind":"Field","name":{"kind":"Name","value":"phone"}},{"kind":"Field","name":{"kind":"Name","value":"city"}},{"kind":"Field","name":{"kind":"Name","value":"cityArea"}},{"kind":"Field","name":{"kind":"Name","value":"country"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"SourceObject"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"OrderOrCheckout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Checkout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"totalPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"checkoutVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Order"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"userEmail"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"total"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"orderVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"TransactionInitializeSessionEvent"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"TransactionInitializeSession"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"EventMetadata"}},{"kind":"Field","name":{"kind":"Name","value":"action"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}},{"kind":"Field","name":{"kind":"Name","value":"currency"}}]}},{"kind":"Field","name":{"kind":"Name","value":"transaction"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"token"}}]}},{"kind":"Field","name":{"kind":"Name","value":"sourceObject"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"SourceObject"}}]}}]}}]} as unknown as DocumentNode<TransactionInitializeSessionSubscription, TransactionInitializeSessionSubscriptionVariables>;
export const TransactionProcessSessionDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"TransactionProcessSession"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"event"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"TransactionProcessSessionEvent"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"EventMetadata"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Event"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"version"}},{"kind":"Field","name":{"kind":"Name","value":"issuedAt"}},{"kind":"Field","name":{"kind":"Name","value":"recipient"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Channel"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Channel"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"slug"}},{"kind":"Field","name":{"kind":"Name","value":"currencyCode"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Address"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Address"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"companyName"}},{"kind":"Field","name":{"kind":"Name","value":"postalCode"}},{"kind":"Field","name":{"kind":"Name","value":"countryArea"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress1"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress2"}},{"kind":"Field","name":{"kind":"Name","value":"phone"}},{"kind":"Field","name":{"kind":"Name","value":"city"}},{"kind":"Field","name":{"kind":"Name","value":"cityArea"}},{"kind":"Field","name":{"kind":"Name","value":"country"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"SourceObject"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"OrderOrCheckout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Checkout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"totalPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"checkoutVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Order"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"userEmail"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"total"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"orderVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"TransactionProcessSessionEvent"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"TransactionProcessSession"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"EventMetadata"}},{"kind":"Field","name":{"kind":"Name","value":"action"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}},{"kind":"Field","name":{"kind":"Name","value":"currency"}}]}},{"kind":"Field","name":{"kind":"Name","value":"transaction"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"token"}},{"kind":"Field","name":{"kind":"Name","value":"pspReference"}}]}},{"kind":"Field","name":{"kind":"Name","value":"sourceObject"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"SourceObject"}}]}}]}}]} as unknown as DocumentNode<TransactionProcessSessionSubscription, TransactionProcessSessionSubscriptionVariables>;
export const TransactionRefundRequestedDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"TransactionRefundRequested"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"event"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"TransactionRefundRequestedEvent"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"EventMetadata"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Event"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"version"}},{"kind":"Field","name":{"kind":"Name","value":"issuedAt"}},{"kind":"Field","name":{"kind":"Name","value":"recipient"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"OrderGrantedRefund"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"OrderGrantedRefund"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"shippingCostsIncluded"}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"orderLine"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Channel"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Channel"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"slug"}},{"kind":"Field","name":{"kind":"Name","value":"currencyCode"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"Address"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Address"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"companyName"}},{"kind":"Field","name":{"kind":"Name","value":"postalCode"}},{"kind":"Field","name":{"kind":"Name","value":"countryArea"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress1"}},{"kind":"Field","name":{"kind":"Name","value":"streetAddress2"}},{"kind":"Field","name":{"kind":"Name","value":"phone"}},{"kind":"Field","name":{"kind":"Name","value":"city"}},{"kind":"Field","name":{"kind":"Name","value":"cityArea"}},{"kind":"Field","name":{"kind":"Name","value":"country"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"SourceObject"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"OrderOrCheckout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Checkout"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"totalPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"checkoutVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Order"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"channel"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Channel"}}]}},{"kind":"Field","name":{"kind":"Name","value":"userEmail"}},{"kind":"Field","name":{"kind":"Name","value":"billingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingAddress"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"Address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"discount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"shippingPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"total"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"lines"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"quantity"}},{"kind":"Field","name":{"kind":"Name","value":"unitPrice"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"gross"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"orderVariant"},"name":{"kind":"Name","value":"variant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sku"}},{"kind":"Field","name":{"kind":"Name","value":"product"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"TransactionRefundRequestedEvent"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"TransactionRefundRequested"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"EventMetadata"}},{"kind":"Field","name":{"kind":"Name","value":"action"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}},{"kind":"Field","name":{"kind":"Name","value":"currency"}}]}},{"kind":"Field","name":{"kind":"Name","value":"grantedRefund"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"OrderGrantedRefund"}}]}},{"kind":"Field","name":{"kind":"Name","value":"transaction"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"token"}},{"kind":"Field","name":{"kind":"Name","value":"pspReference"}},{"kind":"Field","name":{"kind":"Name","value":"chargedAmount"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"checkout"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"SourceObject"}}]}},{"kind":"Field","name":{"kind":"Name","value":"order"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"SourceObject"}}]}}]}}]}}]} as unknown as DocumentNode<TransactionRefundRequestedSubscription, TransactionRefundRequestedSubscriptionVariables>;